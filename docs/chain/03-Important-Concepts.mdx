---
id: docs-chain-important-concepts
title: Important Concepts
hide_title: true
slug: ./important-concepts
displayed_sidebar: pushChainSidebar
sidebar_position: 3
image: "/assets/docs/previews/docs_notifications--important_concepts.png"
---

# Important Concepts

Before diving into the SDK and integrating Push Chain to build the next wave of consumer-centric applications, let's review some fundamental concepts unique to Push Chain.

> Note: For additional insights into Push Chain fundamentals, deep dives, and comprehensive developer resources, visit our [Knowledge Base](https://push.org/knowledge).

<head>
  <title>
    {'Important Concepts | Push Chain | Push Documentation'}
  </title>
</head>

## Wallet Interactions from Any Layer 1

Push Chain introduces groundbreaking support for wallets from different Layer 1 blockchains, enabling them to transact directly on Push Chain. Users can leverage their existing wallets, whether Ethereum-based (MetaMask), Solana-based (Phantom), or wallets from other chains, to execute transactions seamlessly on Push Chain. This cross-chain wallet integration is part of Push Chain's broader vision for universal interoperability.

## Account Types on Push Chain

As an EVM-compatible Universal Layer 1 blockchain, Push Chain naturally supports standard Ethereum accounts:

- **Externally Owned Accounts (EOAs)**: Traditional wallet addresses controlled by private keys.

- **Smart Contract Accounts (Smart Accounts)**: Addresses controlled by deployed smart contracts, enabling programmable logic and complex interactions.

Additionally, Push Chain innovates by introducing:

- **Universal External Accounts (UEAs)**: These accounts uniquely allow wallets from different Layer 1 chains (like Ethereum, Solana, and others) to interact and transact on Push Chain seamlessly. UEAs enable users to execute smart contracts on Push Chain without needing a native Push Chain wallet, significantly enhancing accessibility and user experience.

## Fee Abstraction and Cross-Chain Execution

Push Chain lets users execute contracts without holding PUSH tokens. Instead, users can initiate transactions from their source chains, such as Goerli or Solana Devnet, and pay gas fees in their native tokens like ETH or SOL.

When a user signs a transaction from a source chain such as Goerli or Solana Devnet, the orchestrator deploys a smart wallet (NMSC) on Push Chain for that user, locks the required gas fees in their native tokens, and executes the contract on Push Chain using the signed payload. This allows the user to interact with Push Chain entirely from their original chain, using only their existing wallet and tokens.


## What is `UniversalAccount`?

The `UniversalAccount` is a chain-agnostic way of representing an address, designed to work seamlessly across multiple blockchain ecosystems. It abstracts the details of the underlying blockchain, enabling developers to interact with addresses in a unified manner, regardless of the chain they belong to.

### Interface Structure

The UniversalAccount interface consists of two key properties:

- `chain`: A fully qualified chain identifier that combines both the blockchain type and specific network (e.g., `CONSTANTS.CHAIN.ETHEREUM_SEPOLIA`, `CONSTANTS.CHAIN.SOLANA_TESTNET`, `CONSTANTS.CHAIN.PUSH_TESTNET`)
- `address`: The address on the respective chain, formatted according to chain standards (EVM addresses are checksummed, Solana addresses are base58-encoded, etc.)

### Example Usage
Here are examples of how to use the `createUniversalAccount` utility function to represent recipients on different blockchain networks:

```typescript
import { CONSTANTS, createUniversalAccount } from '@pushchain/core';

const ethereumAccount = createUniversalAccount({
  chain: CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,
  address: '0x742d35Cc6370C742Fc60f8b67da6c68F091C42b5',
});

const solanaAccount = createUniversalAccount({
  chain: CONSTANTS.CHAIN.SOLANA_TESTNET,
  address: 'ySYrGNLLJSK9hvGGpoxg8TzWfRe8ftBtDSMECtx2eJR',
});
```

## What is `UniversalSigner`?

The `UniversalSigner` is a chain-agnostic way of representing a signer, designed to facilitate signing operations across multiple blockchain ecosystems. It abstracts the underlying blockchain-specific details, providing a unified approach to handle signing logic, regardless of the chain involved.

### Interface Structure

The UniversalSigner interface extends UniversalAccount and includes the following key properties:

- `chain`: A fully qualified chain identifier (e.g., `CONSTANTS.CHAIN.ETHEREUM_SEPOLIA`, `CONSTANTS.CHAIN.SOLANA_TESTNET`, `CONSTANTS.CHAIN.PUSH_TESTNET`)
- `address`: The signer's address, formatted according to chain standards
- `signMessage`: Function to sign arbitrary binary data (Uint8Array)
- `signTransaction`: Function to sign transaction bytes

### Example Usage

Here are examples of how to create signers for different blockchain networks using the helper functions:

For Ethereum using `viem` library:

```typescript
import { PushChain, CONSTANTS } from '@pushchain/core';
import { privateKeyToAccount } from 'viem/accounts';

const account = privateKeyToAccount('0x...');
const ethereumSigner = await PushChain.utils.signer.toUniversalFromViem(
  account,
  CONSTANTS.CHAIN.ETHEREUM_SEPOLIA
);
```

For Solana using `@solana/web3.js` library:

```typescript
import { PushChain, CONSTANTS } from '@pushchain/core';
import { Keypair } from '@solana/web3.js';

const privateKeyHex = '...';
const privateKey = Uint8Array.from(Buffer.from(privateKeyHex, 'hex'));
const keypair = Keypair.fromSecretKey(privateKey);
const solanaSigner = PushChain.utils.signer.toUniversalFromSolanaKeypair(
  keypair,
  CONSTANTS.CHAIN.SOLANA_TESTNET
);
```

## Learn More

For additional insights into Push Chain fundamentals, deep dives, and comprehensive developer resources, visit our [Knowledge Base](https://push.org/knowledge).
