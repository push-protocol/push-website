exports.id = 3895;
exports.ids = [3895];
exports.modules = {

/***/ 25905:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ FetchUtil)
/* harmony export */ });
async function fetchData(...args) {
    const response = await fetch(...args);
    if (!response.ok) {
        // Create error object and reject if not a 2xx response code
        const err = new Error(`HTTP status code: ${response.status}`, {
            cause: response
        });
        throw err;
    }
    return response;
}
// -- Utility --------------------------------------------------------------------
class FetchUtil {
    constructor({ baseUrl, clientId }) {
        this.baseUrl = baseUrl;
        this.clientId = clientId;
    }
    async get({ headers, signal, cache, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, { method: 'GET', headers, signal, cache });
        return response.json();
    }
    async getBlob({ headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, { method: 'GET', headers, signal });
        return response.blob();
    }
    async post({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
            method: 'POST',
            headers,
            body: body ? JSON.stringify(body) : undefined,
            signal
        });
        return response.json();
    }
    async put({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
            method: 'PUT',
            headers,
            body: body ? JSON.stringify(body) : undefined,
            signal
        });
        return response.json();
    }
    async delete({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
            method: 'DELETE',
            headers,
            body: body ? JSON.stringify(body) : undefined,
            signal
        });
        return response.json();
    }
    createUrl({ path, params }) {
        const url = new URL(path, this.baseUrl);
        if (params) {
            Object.entries(params).forEach(([key, value]) => {
                if (value) {
                    url.searchParams.append(key, value);
                }
            });
        }
        if (this.clientId) {
            url.searchParams.append('clientId', this.clientId);
        }
        return url;
    }
}
//# sourceMappingURL=FetchUtil.js.map

/***/ }),

/***/ 46036:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IP: () => (/* binding */ isSafe),
/* harmony export */   T8: () => (/* binding */ getSafeConnectorIdKey),
/* harmony export */   Ud: () => (/* binding */ SafeLocalStorage),
/* harmony export */   Ws: () => (/* binding */ SafeLocalStorageKeys)
/* harmony export */ });
const SafeLocalStorageKeys = {
    WALLET_ID: '@appkit/wallet_id',
    WALLET_NAME: '@appkit/wallet_name',
    SOLANA_WALLET: '@appkit/solana_wallet',
    SOLANA_CAIP_CHAIN: '@appkit/solana_caip_chain',
    ACTIVE_CAIP_NETWORK_ID: '@appkit/active_caip_network_id',
    CONNECTED_SOCIAL: '@appkit/connected_social',
    CONNECTED_SOCIAL_USERNAME: '@appkit-wallet/SOCIAL_USERNAME',
    RECENT_WALLETS: '@appkit/recent_wallets',
    DEEPLINK_CHOICE: 'WALLETCONNECT_DEEPLINK_CHOICE',
    ACTIVE_NAMESPACE: '@appkit/active_namespace',
    CONNECTED_NAMESPACES: '@appkit/connected_namespaces',
    CONNECTION_STATUS: '@appkit/connection_status',
    SIWX_AUTH_TOKEN: '@appkit/siwx-auth-token',
    SIWX_NONCE_TOKEN: '@appkit/siwx-nonce-token',
    TELEGRAM_SOCIAL_PROVIDER: '@appkit/social_provider',
    NATIVE_BALANCE_CACHE: '@appkit/native_balance_cache',
    PORTFOLIO_CACHE: '@appkit/portfolio_cache',
    ENS_CACHE: '@appkit/ens_cache',
    IDENTITY_CACHE: '@appkit/identity_cache',
    PREFERRED_ACCOUNT_TYPES: '@appkit/preferred_account_types',
    CONNECTIONS: '@appkit/connections'
};
function getSafeConnectorIdKey(namespace) {
    if (!namespace) {
        throw new Error('Namespace is required for CONNECTED_CONNECTOR_ID');
    }
    return `@appkit/${namespace}:connected_connector_id`;
}
const SafeLocalStorage = {
    setItem(key, value) {
        if (isSafe() && value !== undefined) {
            localStorage.setItem(key, value);
        }
    },
    getItem(key) {
        if (isSafe()) {
            return localStorage.getItem(key) || undefined;
        }
        return undefined;
    },
    removeItem(key) {
        if (isSafe()) {
            localStorage.removeItem(key);
        }
    },
    clear() {
        if (isSafe()) {
            localStorage.clear();
        }
    }
};
function isSafe() {
    return typeof window !== 'undefined' && typeof localStorage !== 'undefined';
}
//# sourceMappingURL=SafeLocalStorage.js.map

/***/ }),

/***/ 56092:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ ConnectorUtil)
/* harmony export */ });
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(824376);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(500026);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127508);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188249);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(226742);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(627987);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(806056);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(236010);
/* harmony import */ var _reown_appkit_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(335306);
/* harmony import */ var _WalletUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(665042);




const ConnectorUtil = {
    getConnectorsByType(connectors, recommended, featured) {
        const { customWallets } = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state;
        const recent = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.getRecentWallets();
        const filteredRecommended = _WalletUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .WalletUtil */ .A.filterOutDuplicateWallets(recommended);
        const filteredFeatured = _WalletUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .WalletUtil */ .A.filterOutDuplicateWallets(featured);
        const multiChain = connectors.filter(connector => connector.type === 'MULTI_CHAIN');
        const announced = connectors.filter(connector => connector.type === 'ANNOUNCED');
        const injected = connectors.filter(connector => connector.type === 'INJECTED');
        const external = connectors.filter(connector => connector.type === 'EXTERNAL');
        return {
            custom: customWallets,
            recent,
            external,
            multiChain,
            announced,
            injected,
            recommended: filteredRecommended,
            featured: filteredFeatured
        };
    },
    showConnector(connector) {
        const rdns = connector.info?.rdns;
        const isRDNSExcluded = Boolean(rdns) &&
            _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ApiController */ .N.state.excludedWallets.some(wallet => Boolean(wallet.rdns) && wallet.rdns === rdns);
        const isNameExcluded = Boolean(connector.name) &&
            _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ApiController */ .N.state.excludedWallets.some(wallet => _reown_appkit_utils__WEBPACK_IMPORTED_MODULE_4__/* .HelpersUtil */ .y.isLowerCaseMatch(wallet.name, connector.name));
        if (connector.type === 'INJECTED') {
            const isBrowserWallet = connector.name === 'Browser Wallet';
            if (isBrowserWallet) {
                if (!_reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_5__/* .CoreHelperUtil */ .w.isMobile()) {
                    return false;
                }
                if (_reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_5__/* .CoreHelperUtil */ .w.isMobile() && !rdns && !_reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__/* .ConnectionController */ .x.checkInstalled()) {
                    return false;
                }
            }
            if (isRDNSExcluded || isNameExcluded) {
                return false;
            }
        }
        if ((connector.type === 'ANNOUNCED' || connector.type === 'EXTERNAL') &&
            (isRDNSExcluded || isNameExcluded)) {
            return false;
        }
        return true;
    },
    getIsConnectedWithWC() {
        const chains = Array.from(_reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.state.chains.values());
        const isConnectedWithWC = chains.some(chain => {
            const connectorId = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_8__/* .ConnectorController */ .a.getConnectorId(chain.namespace);
            return connectorId === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_9__/* .ConstantsUtil */ .o.CONNECTOR_ID.WALLET_CONNECT;
        });
        return isConnectedWithWC;
    },
    getConnectorTypeOrder({ recommended, featured, custom, recent, announced, injected, multiChain, external, overriddenConnectors = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.features?.connectorTypeOrder ?? [] }) {
        const isConnectedWithWC = ConnectorUtil.getIsConnectedWithWC();
        const isWCEnabled = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.enableWalletConnect;
        const allConnectors = [
            { type: 'walletConnect', isEnabled: isWCEnabled && !isConnectedWithWC },
            { type: 'recent', isEnabled: recent.length > 0 },
            { type: 'injected', isEnabled: [...injected, ...announced, ...multiChain].length > 0 },
            { type: 'featured', isEnabled: featured.length > 0 },
            { type: 'custom', isEnabled: custom && custom.length > 0 },
            { type: 'external', isEnabled: external.length > 0 },
            { type: 'recommended', isEnabled: recommended.length > 0 }
        ];
        const enabledConnectors = allConnectors.filter(option => option.isEnabled);
        const enabledConnectorTypes = new Set(enabledConnectors.map(option => option.type));
        const prioritizedConnectors = overriddenConnectors
            .filter(type => enabledConnectorTypes.has(type))
            .map(type => ({ type, isEnabled: true }));
        const remainingConnectors = enabledConnectors.filter(({ type: enabledConnectorType }) => {
            const hasPrioritizedConnector = prioritizedConnectors.some(({ type: prioritizedConnectorType }) => prioritizedConnectorType === enabledConnectorType);
            return !hasPrioritizedConnector;
        });
        return Array.from(new Set([...prioritizedConnectors, ...remainingConnectors].map(({ type }) => type)));
    }
};
//# sourceMappingURL=ConnectorUtil.js.map

/***/ }),

/***/ 91111:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ ModalController)
});

// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = __webpack_require__(824376);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var AccountController = __webpack_require__(863450);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var ChainController = __webpack_require__(806056);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var ConnectorController = __webpack_require__(236010);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var RouterController = __webpack_require__(778508);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/NetworkUtil.js





const NetworkUtil = {
    /**
     * Function to handle the network switch.
     * This function has variety of conditions to handle the network switch depending on the connectors or namespace's connection states.
     * @param args.network - The network to switch to.
     * @param args.shouldConfirmSwitch - Whether to confirm the switch. If true, the user will be asked to confirm the switch if necessary.
     * @returns void
     */
    onSwitchNetwork({ network, ignoreSwitchConfirmation = false }) {
        const currentNetwork = ChainController/* ChainController */.W.state.activeCaipNetwork;
        const routerData = RouterController/* RouterController */.I.state.data;
        const isSameNetwork = network.id === currentNetwork?.id;
        if (isSameNetwork) {
            return;
        }
        const isCurrentNamespaceConnected = AccountController/* AccountController */.U.getCaipAddress(ChainController/* ChainController */.W.state.activeChain);
        const isDifferentNamespace = network.chainNamespace !== ChainController/* ChainController */.W.state.activeChain;
        const isNextNamespaceConnected = AccountController/* AccountController */.U.getCaipAddress(network.chainNamespace);
        const connectorId = ConnectorController/* ConnectorController */.a.getConnectorId(ChainController/* ChainController */.W.state.activeChain);
        /**
         * If the network is supported by the auth connector, we don't need to show switch active chain view.
         * But there are some cases like switching from Ethereum to Bitcoin where Bitcoin is not supported by the auth connector and users should connect with another connector.
         */
        const isConnectedWithAuth = connectorId === ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH;
        const isSupportedForAuthConnector = ConstantsUtil/* ConstantsUtil */.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(c => c === network.chainNamespace);
        /**
         * 1. If the ignoreSwitchConfirmation is set to true, we should switch to the network,
         * 2. If user connected with auth connector and the next network is supported by the auth connector,
         * we should switch to the network without confirmation screen.
         */
        if (ignoreSwitchConfirmation || (isConnectedWithAuth && isSupportedForAuthConnector)) {
            RouterController/* RouterController */.I.push('SwitchNetwork', { ...routerData, network });
        }
        else if (
        /**
         * If user switching to a different namespace and next namespace is not connected, we need to show switch active chain view for confirmation first.
         */
        isCurrentNamespaceConnected &&
            isDifferentNamespace &&
            !isNextNamespaceConnected) {
            RouterController/* RouterController */.I.push('SwitchActiveChain', {
                switchToChain: network.chainNamespace,
                navigateTo: 'Connect',
                navigateWithReplace: true,
                network
            });
        }
        else {
            RouterController/* RouterController */.I.push('SwitchNetwork', { ...routerData, network });
        }
    }
};
//# sourceMappingURL=NetworkUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js + 1 modules
var withErrorBoundary = __webpack_require__(923082);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var ApiController = __webpack_require__(188249);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js + 1 modules
var ConnectionController = __webpack_require__(627987);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var EventsController = __webpack_require__(390184);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js + 1 modules
var OptionsController = __webpack_require__(500026);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js
var PublicStateController = __webpack_require__(698467);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js















// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    loading: false,
    loadingNamespaceMap: new Map(),
    open: false,
    shake: false,
    namespace: undefined
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(state, () => callback(state));
    },
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(state, key, callback);
    },
    async open(options) {
        const isConnected = AccountController/* AccountController */.U.state.status === 'connected';
        const namespace = options?.namespace;
        const currentNamespace = ChainController/* ChainController */.W.state.activeChain;
        const isSwitchingNamespace = namespace && namespace !== currentNamespace;
        const caipAddress = ChainController/* ChainController */.W.getAccountData(options?.namespace)?.caipAddress;
        if (ConnectionController/* ConnectionController */.x.state.wcBasic) {
            // No need to add an await here if we are use basic
            ApiController/* ApiController */.N.prefetch({ fetchNetworkImages: false, fetchConnectorImages: false });
        }
        else {
            await ApiController/* ApiController */.N.prefetch({
                fetchConnectorImages: !isConnected,
                fetchFeaturedWallets: !isConnected,
                fetchRecommendedWallets: !isConnected
            });
        }
        ConnectorController/* ConnectorController */.a.setFilterByNamespace(options?.namespace);
        ModalController.setLoading(true, namespace);
        if (namespace && isSwitchingNamespace) {
            const namespaceNetwork = ChainController/* ChainController */.W.getNetworkData(namespace)?.caipNetwork ||
                ChainController/* ChainController */.W.getRequestedCaipNetworks(namespace)[0];
            if (namespaceNetwork) {
                NetworkUtil.onSwitchNetwork({ network: namespaceNetwork, ignoreSwitchConfirmation: true });
            }
        }
        else {
            const hasNoAdapters = ChainController/* ChainController */.W.state.noAdapters;
            if (OptionsController/* OptionsController */.H.state.manualWCControl || (hasNoAdapters && !caipAddress)) {
                if (CoreHelperUtil/* CoreHelperUtil */.w.isMobile()) {
                    RouterController/* RouterController */.I.reset('AllWallets');
                }
                else {
                    RouterController/* RouterController */.I.reset('ConnectingWalletConnectBasic');
                }
            }
            else if (options?.view) {
                RouterController/* RouterController */.I.reset(options.view, options.data);
            }
            else if (caipAddress) {
                RouterController/* RouterController */.I.reset('Account');
            }
            else {
                RouterController/* RouterController */.I.reset('Connect');
            }
        }
        state.open = true;
        PublicStateController/* PublicStateController */.z.set({ open: true });
        EventsController/* EventsController */.E.sendEvent({
            type: 'track',
            event: 'MODAL_OPEN',
            properties: { connected: Boolean(caipAddress) }
        });
    },
    close() {
        const isEmbeddedEnabled = OptionsController/* OptionsController */.H.state.enableEmbedded;
        const isConnected = Boolean(ChainController/* ChainController */.W.state.activeCaipAddress);
        // Only send the event if the modal is open and is about to be closed
        if (state.open) {
            EventsController/* EventsController */.E.sendEvent({
                type: 'track',
                event: 'MODAL_CLOSE',
                properties: { connected: isConnected }
            });
        }
        state.open = false;
        RouterController/* RouterController */.I.reset('Connect');
        ModalController.clearLoading();
        if (isEmbeddedEnabled) {
            if (isConnected) {
                RouterController/* RouterController */.I.replace('Account');
            }
            else {
                RouterController/* RouterController */.I.push('Connect');
            }
        }
        else {
            PublicStateController/* PublicStateController */.z.set({ open: false });
        }
        ConnectionController/* ConnectionController */.x.resetUri();
    },
    setLoading(loading, namespace) {
        if (namespace) {
            state.loadingNamespaceMap.set(namespace, loading);
        }
        state.loading = loading;
        PublicStateController/* PublicStateController */.z.set({ loading });
    },
    clearLoading() {
        state.loadingNamespaceMap.clear();
        state.loading = false;
    },
    shake() {
        if (state.shake) {
            return;
        }
        state.shake = true;
        setTimeout(() => {
            state.shake = false;
        }, 500);
    }
};
// Export the controller wrapped with our error boundary
const ModalController = (0,withErrorBoundary/* withErrorBoundary */.X)(controller);
//# sourceMappingURL=ModalController.js.map

/***/ }),

/***/ 110152:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vl: () => (/* binding */ W3mFrameRpcConstants)
/* harmony export */ });
/* unused harmony exports SECURE_SITE_SDK, DEFAULT_LOG_LEVEL, SECURE_SITE_SDK_VERSION, W3mFrameConstants */
const DEFAULT_SDK_URL = 'https://secure.walletconnect.org/sdk';
const SECURE_SITE_SDK = (typeof process !== 'undefined' && typeof process.env !== 'undefined'
    ? process.env['NEXT_PUBLIC_SECURE_SITE_SDK_URL']
    : undefined) || DEFAULT_SDK_URL;
const DEFAULT_LOG_LEVEL = (typeof process !== 'undefined' && typeof process.env !== 'undefined'
    ? process.env['NEXT_PUBLIC_DEFAULT_LOG_LEVEL']
    : undefined) || 'error';
const SECURE_SITE_SDK_VERSION = (typeof process !== 'undefined' && typeof process.env !== 'undefined'
    ? process.env['NEXT_PUBLIC_SECURE_SITE_SDK_VERSION']
    : undefined) || '4';
const W3mFrameConstants = {
    APP_EVENT_KEY: '@w3m-app/',
    FRAME_EVENT_KEY: '@w3m-frame/',
    RPC_METHOD_KEY: 'RPC_',
    STORAGE_KEY: '@appkit-wallet/',
    SESSION_TOKEN_KEY: 'SESSION_TOKEN_KEY',
    EMAIL_LOGIN_USED_KEY: 'EMAIL_LOGIN_USED_KEY',
    LAST_USED_CHAIN_KEY: 'LAST_USED_CHAIN_KEY',
    LAST_EMAIL_LOGIN_TIME: 'LAST_EMAIL_LOGIN_TIME',
    EMAIL: 'EMAIL',
    PREFERRED_ACCOUNT_TYPE: 'PREFERRED_ACCOUNT_TYPE',
    SMART_ACCOUNT_ENABLED: 'SMART_ACCOUNT_ENABLED',
    SMART_ACCOUNT_ENABLED_NETWORKS: 'SMART_ACCOUNT_ENABLED_NETWORKS',
    SOCIAL_USERNAME: 'SOCIAL_USERNAME',
    APP_SWITCH_NETWORK: '@w3m-app/SWITCH_NETWORK',
    APP_CONNECT_EMAIL: '@w3m-app/CONNECT_EMAIL',
    APP_CONNECT_DEVICE: '@w3m-app/CONNECT_DEVICE',
    APP_CONNECT_OTP: '@w3m-app/CONNECT_OTP',
    APP_CONNECT_SOCIAL: '@w3m-app/CONNECT_SOCIAL',
    APP_GET_SOCIAL_REDIRECT_URI: '@w3m-app/GET_SOCIAL_REDIRECT_URI',
    APP_GET_USER: '@w3m-app/GET_USER',
    APP_SIGN_OUT: '@w3m-app/SIGN_OUT',
    APP_IS_CONNECTED: '@w3m-app/IS_CONNECTED',
    APP_GET_CHAIN_ID: '@w3m-app/GET_CHAIN_ID',
    APP_RPC_REQUEST: '@w3m-app/RPC_REQUEST',
    APP_UPDATE_EMAIL: '@w3m-app/UPDATE_EMAIL',
    APP_UPDATE_EMAIL_PRIMARY_OTP: '@w3m-app/UPDATE_EMAIL_PRIMARY_OTP',
    APP_UPDATE_EMAIL_SECONDARY_OTP: '@w3m-app/UPDATE_EMAIL_SECONDARY_OTP',
    APP_AWAIT_UPDATE_EMAIL: '@w3m-app/AWAIT_UPDATE_EMAIL',
    APP_SYNC_THEME: '@w3m-app/SYNC_THEME',
    APP_SYNC_DAPP_DATA: '@w3m-app/SYNC_DAPP_DATA',
    APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: '@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS',
    APP_INIT_SMART_ACCOUNT: '@w3m-app/INIT_SMART_ACCOUNT',
    APP_SET_PREFERRED_ACCOUNT: '@w3m-app/SET_PREFERRED_ACCOUNT',
    APP_CONNECT_FARCASTER: '@w3m-app/CONNECT_FARCASTER',
    APP_GET_FARCASTER_URI: '@w3m-app/GET_FARCASTER_URI',
    APP_RELOAD: '@w3m-app/RELOAD',
    FRAME_SWITCH_NETWORK_ERROR: '@w3m-frame/SWITCH_NETWORK_ERROR',
    FRAME_SWITCH_NETWORK_SUCCESS: '@w3m-frame/SWITCH_NETWORK_SUCCESS',
    FRAME_CONNECT_EMAIL_ERROR: '@w3m-frame/CONNECT_EMAIL_ERROR',
    FRAME_CONNECT_EMAIL_SUCCESS: '@w3m-frame/CONNECT_EMAIL_SUCCESS',
    FRAME_CONNECT_DEVICE_ERROR: '@w3m-frame/CONNECT_DEVICE_ERROR',
    FRAME_CONNECT_DEVICE_SUCCESS: '@w3m-frame/CONNECT_DEVICE_SUCCESS',
    FRAME_CONNECT_OTP_SUCCESS: '@w3m-frame/CONNECT_OTP_SUCCESS',
    FRAME_CONNECT_OTP_ERROR: '@w3m-frame/CONNECT_OTP_ERROR',
    FRAME_CONNECT_SOCIAL_SUCCESS: '@w3m-frame/CONNECT_SOCIAL_SUCCESS',
    FRAME_CONNECT_SOCIAL_ERROR: '@w3m-frame/CONNECT_SOCIAL_ERROR',
    FRAME_CONNECT_FARCASTER_SUCCESS: '@w3m-frame/CONNECT_FARCASTER_SUCCESS',
    FRAME_CONNECT_FARCASTER_ERROR: '@w3m-frame/CONNECT_FARCASTER_ERROR',
    FRAME_GET_FARCASTER_URI_SUCCESS: '@w3m-frame/GET_FARCASTER_URI_SUCCESS',
    FRAME_GET_FARCASTER_URI_ERROR: '@w3m-frame/GET_FARCASTER_URI_ERROR',
    FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS',
    FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: '@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR',
    FRAME_GET_USER_SUCCESS: '@w3m-frame/GET_USER_SUCCESS',
    FRAME_GET_USER_ERROR: '@w3m-frame/GET_USER_ERROR',
    FRAME_SIGN_OUT_SUCCESS: '@w3m-frame/SIGN_OUT_SUCCESS',
    FRAME_SIGN_OUT_ERROR: '@w3m-frame/SIGN_OUT_ERROR',
    FRAME_IS_CONNECTED_SUCCESS: '@w3m-frame/IS_CONNECTED_SUCCESS',
    FRAME_IS_CONNECTED_ERROR: '@w3m-frame/IS_CONNECTED_ERROR',
    FRAME_GET_CHAIN_ID_SUCCESS: '@w3m-frame/GET_CHAIN_ID_SUCCESS',
    FRAME_GET_CHAIN_ID_ERROR: '@w3m-frame/GET_CHAIN_ID_ERROR',
    FRAME_RPC_REQUEST_SUCCESS: '@w3m-frame/RPC_REQUEST_SUCCESS',
    FRAME_RPC_REQUEST_ERROR: '@w3m-frame/RPC_REQUEST_ERROR',
    FRAME_SESSION_UPDATE: '@w3m-frame/SESSION_UPDATE',
    FRAME_UPDATE_EMAIL_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SUCCESS',
    FRAME_UPDATE_EMAIL_ERROR: '@w3m-frame/UPDATE_EMAIL_ERROR',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS',
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR',
    FRAME_SYNC_THEME_SUCCESS: '@w3m-frame/SYNC_THEME_SUCCESS',
    FRAME_SYNC_THEME_ERROR: '@w3m-frame/SYNC_THEME_ERROR',
    FRAME_SYNC_DAPP_DATA_SUCCESS: '@w3m-frame/SYNC_DAPP_DATA_SUCCESS',
    FRAME_SYNC_DAPP_DATA_ERROR: '@w3m-frame/SYNC_DAPP_DATA_ERROR',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS',
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR',
    FRAME_INIT_SMART_ACCOUNT_SUCCESS: '@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS',
    FRAME_INIT_SMART_ACCOUNT_ERROR: '@w3m-frame/INIT_SMART_ACCOUNT_ERROR',
    FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: '@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS',
    FRAME_SET_PREFERRED_ACCOUNT_ERROR: '@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR',
    FRAME_READY: '@w3m-frame/READY',
    FRAME_RELOAD_SUCCESS: '@w3m-frame/RELOAD_SUCCESS',
    FRAME_RELOAD_ERROR: '@w3m-frame/RELOAD_ERROR',
    RPC_RESPONSE_TYPE_ERROR: 'RPC_RESPONSE_ERROR',
    RPC_RESPONSE_TYPE_TX: 'RPC_RESPONSE_TRANSACTION_HASH',
    RPC_RESPONSE_TYPE_OBJECT: 'RPC_RESPONSE_OBJECT'
};
const W3mFrameRpcConstants = {
    SAFE_RPC_METHODS: [
        'eth_accounts',
        'eth_blockNumber',
        'eth_call',
        'eth_chainId',
        'eth_estimateGas',
        'eth_feeHistory',
        'eth_gasPrice',
        'eth_getAccount',
        'eth_getBalance',
        'eth_getBlockByHash',
        'eth_getBlockByNumber',
        'eth_getBlockReceipts',
        'eth_getBlockTransactionCountByHash',
        'eth_getBlockTransactionCountByNumber',
        'eth_getCode',
        'eth_getFilterChanges',
        'eth_getFilterLogs',
        'eth_getLogs',
        'eth_getProof',
        'eth_getStorageAt',
        'eth_getTransactionByBlockHashAndIndex',
        'eth_getTransactionByBlockNumberAndIndex',
        'eth_getTransactionByHash',
        'eth_getTransactionCount',
        'eth_getTransactionReceipt',
        'eth_getUncleCountByBlockHash',
        'eth_getUncleCountByBlockNumber',
        'eth_maxPriorityFeePerGas',
        'eth_newBlockFilter',
        'eth_newFilter',
        'eth_newPendingTransactionFilter',
        'eth_sendRawTransaction',
        'eth_syncing',
        'eth_uninstallFilter',
        'wallet_getCapabilities',
        'wallet_getCallsStatus',
        'eth_getUserOperationReceipt',
        'eth_estimateUserOperationGas',
        'eth_getUserOperationByHash',
        'eth_supportedEntryPoints',
        'wallet_getAssets'
    ],
    NOT_SAFE_RPC_METHODS: [
        'personal_sign',
        'eth_signTypedData_v4',
        'eth_sendTransaction',
        'solana_signMessage',
        'solana_signTransaction',
        'solana_signAllTransactions',
        'solana_signAndSendTransaction',
        'wallet_sendCalls',
        'wallet_grantPermissions',
        'wallet_revokePermissions',
        'eth_sendUserOperation'
    ],
    GET_CHAIN_ID: 'eth_chainId',
    RPC_METHOD_NOT_ALLOWED_MESSAGE: 'Requested RPC call is not allowed',
    RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: 'Action not allowed',
    ACCOUNT_TYPES: {
        EOA: 'eoa',
        SMART_ACCOUNT: 'smartAccount'
    }
};
//# sourceMappingURL=W3mFrameConstants.js.map

/***/ }),

/***/ 121871:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ SnackController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(226742);



// -- Constants ----------------------------------------- //
const DEFAULT_STATE = Object.freeze({
    message: '',
    variant: 'success',
    svg: undefined,
    open: false,
    autoClose: true
});
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    ...DEFAULT_STATE
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    showLoading(message, options = {}) {
        this._showMessage({ message, variant: 'loading', ...options });
    },
    showSuccess(message) {
        this._showMessage({ message, variant: 'success' });
    },
    showSvg(message, svg) {
        this._showMessage({ message, svg });
    },
    showError(message) {
        const errorMessage = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .CoreHelperUtil */ .w.parseError(message);
        this._showMessage({ message: errorMessage, variant: 'error' });
    },
    hide() {
        state.message = DEFAULT_STATE.message;
        state.variant = DEFAULT_STATE.variant;
        state.svg = DEFAULT_STATE.svg;
        state.open = DEFAULT_STATE.open;
        state.autoClose = DEFAULT_STATE.autoClose;
    },
    _showMessage({ message, svg, variant = 'success', autoClose = DEFAULT_STATE.autoClose }) {
        if (state.open) {
            state.open = false;
            setTimeout(() => {
                state.message = message;
                state.variant = variant;
                state.svg = svg;
                state.open = true;
                state.autoClose = autoClose;
            }, 150);
        }
        else {
            state.message = message;
            state.variant = variant;
            state.svg = svg;
            state.open = true;
            state.autoClose = autoClose;
        }
    }
};
const SnackController = controller;
//# sourceMappingURL=SnackController.js.map

/***/ }),

/***/ 127508:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ StorageUtil)
/* harmony export */ });
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46036);
/* eslint-disable no-console */

// -- Utility -----------------------------------------------------------------
const StorageUtil = {
    // Cache expiry in milliseconds
    cacheExpiry: {
        portfolio: 30000,
        nativeBalance: 30000,
        ens: 300000,
        identity: 300000
    },
    isCacheExpired(timestamp, cacheExpiry) {
        return Date.now() - timestamp > cacheExpiry;
    },
    getActiveNetworkProps() {
        const namespace = StorageUtil.getActiveNamespace();
        const caipNetworkId = StorageUtil.getActiveCaipNetworkId();
        const stringChainId = caipNetworkId ? caipNetworkId.split(':')[1] : undefined;
        // eslint-disable-next-line no-nested-ternary
        const chainId = stringChainId
            ? isNaN(Number(stringChainId))
                ? stringChainId
                : Number(stringChainId)
            : undefined;
        return {
            namespace,
            caipNetworkId,
            chainId
        };
    },
    setWalletConnectDeepLink({ name, href }) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.DEEPLINK_CHOICE, JSON.stringify({ href, name }));
        }
        catch {
            console.info('Unable to set WalletConnect deep link');
        }
    },
    getWalletConnectDeepLink() {
        try {
            const deepLink = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.DEEPLINK_CHOICE);
            if (deepLink) {
                return JSON.parse(deepLink);
            }
        }
        catch {
            console.info('Unable to get WalletConnect deep link');
        }
        return undefined;
    },
    deleteWalletConnectDeepLink() {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.DEEPLINK_CHOICE);
        }
        catch {
            console.info('Unable to delete WalletConnect deep link');
        }
    },
    setActiveNamespace(namespace) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_NAMESPACE, namespace);
        }
        catch {
            console.info('Unable to set active namespace');
        }
    },
    setActiveCaipNetworkId(caipNetworkId) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_CAIP_NETWORK_ID, caipNetworkId);
            StorageUtil.setActiveNamespace(caipNetworkId.split(':')[0]);
        }
        catch {
            console.info('Unable to set active caip network id');
        }
    },
    getActiveCaipNetworkId() {
        try {
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_CAIP_NETWORK_ID);
        }
        catch {
            console.info('Unable to get active caip network id');
            return undefined;
        }
    },
    deleteActiveCaipNetworkId() {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_CAIP_NETWORK_ID);
        }
        catch {
            console.info('Unable to delete active caip network id');
        }
    },
    deleteConnectedConnectorId(namespace) {
        try {
            const key = (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .getSafeConnectorIdKey */ .T8)(namespace);
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(key);
        }
        catch {
            console.info('Unable to delete connected connector id');
        }
    },
    setAppKitRecent(wallet) {
        try {
            const recentWallets = StorageUtil.getRecentWallets();
            const exists = recentWallets.find(w => w.id === wallet.id);
            if (!exists) {
                recentWallets.unshift(wallet);
                if (recentWallets.length > 2) {
                    recentWallets.pop();
                }
                _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.RECENT_WALLETS, JSON.stringify(recentWallets));
            }
        }
        catch {
            console.info('Unable to set AppKit recent');
        }
    },
    getRecentWallets() {
        try {
            const recent = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.RECENT_WALLETS);
            return recent ? JSON.parse(recent) : [];
        }
        catch {
            console.info('Unable to get AppKit recent');
        }
        return [];
    },
    setConnectedConnectorId(namespace, connectorId) {
        try {
            const key = (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .getSafeConnectorIdKey */ .T8)(namespace);
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(key, connectorId);
        }
        catch {
            console.info('Unable to set Connected Connector Id');
        }
    },
    getActiveNamespace() {
        try {
            const activeNamespace = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_NAMESPACE);
            return activeNamespace;
        }
        catch {
            console.info('Unable to get active namespace');
        }
        return undefined;
    },
    getConnectedConnectorId(namespace) {
        if (!namespace) {
            return undefined;
        }
        try {
            const key = (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .getSafeConnectorIdKey */ .T8)(namespace);
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(key);
        }
        catch (e) {
            console.info('Unable to get connected connector id in namespace ', namespace);
        }
        return undefined;
    },
    setConnectedSocialProvider(socialProvider) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_SOCIAL, socialProvider);
        }
        catch {
            console.info('Unable to set connected social provider');
        }
    },
    getConnectedSocialProvider() {
        try {
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_SOCIAL);
        }
        catch {
            console.info('Unable to get connected social provider');
        }
        return undefined;
    },
    deleteConnectedSocialProvider() {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_SOCIAL);
        }
        catch {
            console.info('Unable to delete connected social provider');
        }
    },
    getConnectedSocialUsername() {
        try {
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_SOCIAL_USERNAME);
        }
        catch {
            console.info('Unable to get connected social username');
        }
        return undefined;
    },
    getStoredActiveCaipNetworkId() {
        const storedCaipNetworkId = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ACTIVE_CAIP_NETWORK_ID);
        const networkId = storedCaipNetworkId?.split(':')?.[1];
        return networkId;
    },
    setConnectionStatus(status) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTION_STATUS, status);
        }
        catch {
            console.info('Unable to set connection status');
        }
    },
    getConnectionStatus() {
        try {
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTION_STATUS);
        }
        catch {
            return undefined;
        }
    },
    getConnectedNamespaces() {
        try {
            const namespaces = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_NAMESPACES);
            if (!namespaces?.length) {
                return [];
            }
            return namespaces.split(',');
        }
        catch {
            return [];
        }
    },
    setConnectedNamespaces(namespaces) {
        try {
            const uniqueNamespaces = Array.from(new Set(namespaces));
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTED_NAMESPACES, uniqueNamespaces.join(','));
        }
        catch {
            console.info('Unable to set namespaces in storage');
        }
    },
    addConnectedNamespace(namespace) {
        try {
            const namespaces = StorageUtil.getConnectedNamespaces();
            if (!namespaces.includes(namespace)) {
                namespaces.push(namespace);
                StorageUtil.setConnectedNamespaces(namespaces);
            }
        }
        catch {
            console.info('Unable to add connected namespace');
        }
    },
    removeConnectedNamespace(namespace) {
        try {
            const namespaces = StorageUtil.getConnectedNamespaces();
            const index = namespaces.indexOf(namespace);
            if (index > -1) {
                namespaces.splice(index, 1);
                StorageUtil.setConnectedNamespaces(namespaces);
            }
        }
        catch {
            console.info('Unable to remove connected namespace');
        }
    },
    getTelegramSocialProvider() {
        try {
            return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.TELEGRAM_SOCIAL_PROVIDER);
        }
        catch {
            console.info('Unable to get telegram social provider');
            return null;
        }
    },
    setTelegramSocialProvider(socialProvider) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.TELEGRAM_SOCIAL_PROVIDER, socialProvider);
        }
        catch {
            console.info('Unable to set telegram social provider');
        }
    },
    removeTelegramSocialProvider() {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.TELEGRAM_SOCIAL_PROVIDER);
        }
        catch {
            console.info('Unable to remove telegram social provider');
        }
    },
    getBalanceCache() {
        let cache = {};
        try {
            const result = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PORTFOLIO_CACHE);
            cache = result ? JSON.parse(result) : {};
        }
        catch {
            console.info('Unable to get balance cache');
        }
        return cache;
    },
    removeAddressFromBalanceCache(caipAddress) {
        try {
            const cache = StorageUtil.getBalanceCache();
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PORTFOLIO_CACHE, JSON.stringify({ ...cache, [caipAddress]: undefined }));
        }
        catch {
            console.info('Unable to remove address from balance cache', caipAddress);
        }
    },
    getBalanceCacheForCaipAddress(caipAddress) {
        try {
            const cache = StorageUtil.getBalanceCache();
            const balanceCache = cache[caipAddress];
            // We want to discard cache if it's older than the cache expiry
            if (balanceCache &&
                !this.isCacheExpired(balanceCache.timestamp, this.cacheExpiry.portfolio)) {
                return balanceCache.balance;
            }
            StorageUtil.removeAddressFromBalanceCache(caipAddress);
        }
        catch {
            console.info('Unable to get balance cache for address', caipAddress);
        }
        return undefined;
    },
    updateBalanceCache(params) {
        try {
            const cache = StorageUtil.getBalanceCache();
            cache[params.caipAddress] = params;
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PORTFOLIO_CACHE, JSON.stringify(cache));
        }
        catch {
            console.info('Unable to update balance cache', params);
        }
    },
    getNativeBalanceCache() {
        let cache = {};
        try {
            const result = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.NATIVE_BALANCE_CACHE);
            cache = result ? JSON.parse(result) : {};
        }
        catch {
            console.info('Unable to get balance cache');
        }
        return cache;
    },
    removeAddressFromNativeBalanceCache(caipAddress) {
        try {
            const cache = StorageUtil.getBalanceCache();
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.NATIVE_BALANCE_CACHE, JSON.stringify({ ...cache, [caipAddress]: undefined }));
        }
        catch {
            console.info('Unable to remove address from balance cache', caipAddress);
        }
    },
    getNativeBalanceCacheForCaipAddress(caipAddress) {
        try {
            const cache = StorageUtil.getNativeBalanceCache();
            const nativeBalanceCache = cache[caipAddress];
            // We want to discard cache if it's older than the cache expiry
            if (nativeBalanceCache &&
                !this.isCacheExpired(nativeBalanceCache.timestamp, this.cacheExpiry.nativeBalance)) {
                return nativeBalanceCache;
            }
            console.info('Discarding cache for address', caipAddress);
            StorageUtil.removeAddressFromBalanceCache(caipAddress);
        }
        catch {
            console.info('Unable to get balance cache for address', caipAddress);
        }
        return undefined;
    },
    updateNativeBalanceCache(params) {
        try {
            const cache = StorageUtil.getNativeBalanceCache();
            cache[params.caipAddress] = params;
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.NATIVE_BALANCE_CACHE, JSON.stringify(cache));
        }
        catch {
            console.info('Unable to update balance cache', params);
        }
    },
    getEnsCache() {
        let cache = {};
        try {
            const result = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ENS_CACHE);
            cache = result ? JSON.parse(result) : {};
        }
        catch {
            console.info('Unable to get ens name cache');
        }
        return cache;
    },
    getEnsFromCacheForAddress(address) {
        try {
            const cache = StorageUtil.getEnsCache();
            const ensCache = cache[address];
            // We want to discard cache if it's older than the cache expiry
            if (ensCache && !this.isCacheExpired(ensCache.timestamp, this.cacheExpiry.ens)) {
                return ensCache.ens;
            }
            StorageUtil.removeEnsFromCache(address);
        }
        catch {
            console.info('Unable to get ens name from cache', address);
        }
        return undefined;
    },
    updateEnsCache(params) {
        try {
            const cache = StorageUtil.getEnsCache();
            cache[params.address] = params;
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ENS_CACHE, JSON.stringify(cache));
        }
        catch {
            console.info('Unable to update ens name cache', params);
        }
    },
    removeEnsFromCache(address) {
        try {
            const cache = StorageUtil.getEnsCache();
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ENS_CACHE, JSON.stringify({ ...cache, [address]: undefined }));
        }
        catch {
            console.info('Unable to remove ens name from cache', address);
        }
    },
    getIdentityCache() {
        let cache = {};
        try {
            const result = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.IDENTITY_CACHE);
            cache = result ? JSON.parse(result) : {};
        }
        catch {
            console.info('Unable to get identity cache');
        }
        return cache;
    },
    getIdentityFromCacheForAddress(address) {
        try {
            const cache = StorageUtil.getIdentityCache();
            const identityCache = cache[address];
            // We want to discard cache if it's older than the cache expiry
            if (identityCache &&
                !this.isCacheExpired(identityCache.timestamp, this.cacheExpiry.identity)) {
                return identityCache.identity;
            }
            StorageUtil.removeIdentityFromCache(address);
        }
        catch {
            console.info('Unable to get identity from cache', address);
        }
        return undefined;
    },
    updateIdentityCache(params) {
        try {
            const cache = StorageUtil.getIdentityCache();
            cache[params.address] = {
                identity: params.identity,
                timestamp: params.timestamp
            };
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.IDENTITY_CACHE, JSON.stringify(cache));
        }
        catch {
            console.info('Unable to update identity cache', params);
        }
    },
    removeIdentityFromCache(address) {
        try {
            const cache = StorageUtil.getIdentityCache();
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.IDENTITY_CACHE, JSON.stringify({ ...cache, [address]: undefined }));
        }
        catch {
            console.info('Unable to remove identity from cache', address);
        }
    },
    clearAddressCache() {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PORTFOLIO_CACHE);
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.NATIVE_BALANCE_CACHE);
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.ENS_CACHE);
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.removeItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.IDENTITY_CACHE);
        }
        catch {
            console.info('Unable to clear address cache');
        }
    },
    setPreferredAccountTypes(accountTypes) {
        try {
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PREFERRED_ACCOUNT_TYPES, JSON.stringify(accountTypes));
        }
        catch {
            console.info('Unable to set preferred account types', accountTypes);
        }
    },
    getPreferredAccountTypes() {
        try {
            const result = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.PREFERRED_ACCOUNT_TYPES);
            if (!result) {
                return {};
            }
            return JSON.parse(result);
        }
        catch {
            console.info('Unable to get preferred account types');
        }
        return {};
    },
    setConnections(connections, chainNamespace) {
        try {
            const newConnections = {
                ...StorageUtil.getConnections(),
                [chainNamespace]: connections
            };
            _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.setItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTIONS, JSON.stringify(newConnections));
        }
        catch (error) {
            console.error('Unable to sync connections to storage', error);
        }
    },
    getConnections() {
        try {
            const connectionsStorage = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorage */ .Ud.getItem(_reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .SafeLocalStorageKeys */ .Ws.CONNECTIONS);
            if (!connectionsStorage) {
                return {};
            }
            return JSON.parse(connectionsStorage);
        }
        catch (error) {
            console.error('Unable to get connections from storage', error);
            return {};
        }
    }
};
//# sourceMappingURL=StorageUtil.js.map

/***/ }),

/***/ 155500:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ index_es_B)
});

// UNUSED EXPORTS: UniversalProvider

// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(24434);
var external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);
// EXTERNAL MODULE: ./node_modules/@walletconnect/heartbeat/dist/index.es.js
var index_es = __webpack_require__(893532);
// EXTERNAL MODULE: ./node_modules/@walletconnect/keyvaluestorage/dist/index.es.js + 4 modules
var dist_index_es = __webpack_require__(393284);
// EXTERNAL MODULE: ./node_modules/@walletconnect/logger/dist/index.es.js
var logger_dist_index_es = __webpack_require__(729838);
// EXTERNAL MODULE: ./node_modules/@walletconnect/events/dist/esm/events.js
var events = __webpack_require__(204556);
;// ./node_modules/@walletconnect/types/dist/index.es.js
var a=Object.defineProperty,u=(e,s,r)=>s in e?a(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r,c=(e,s,r)=>u(e,typeof s!="symbol"?s+"":s,r);class h extends events/* IEvents */.H{constructor(s){super(),this.opts=s,c(this,"protocol","wc"),c(this,"version",2)}}class g{constructor(s,r,t){this.core=s,this.logger=r}}var p=Object.defineProperty,b=(e,s,r)=>s in e?p(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r,v=(e,s,r)=>b(e,typeof s!="symbol"?s+"":s,r);class I extends events/* IEvents */.H{constructor(s,r){super(),this.core=s,this.logger=r,v(this,"records",new Map)}}class y{constructor(s,r){this.logger=s,this.core=r}}class m extends events/* IEvents */.H{constructor(s,r){super(),this.relayer=s,this.logger=r}}class d extends events/* IEvents */.H{constructor(s){super()}}class f{constructor(s,r,t,q){this.core=s,this.logger=r,this.name=t}}var E=Object.defineProperty,x=(e,s,r)=>s in e?E(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r,w=(e,s,r)=>x(e,typeof s!="symbol"?s+"":s,r);class C{constructor(){w(this,"map",new Map)}}class P extends events/* IEvents */.H{constructor(s,r){super(),this.relayer=s,this.logger=r}}class j{constructor(s,r){this.core=s,this.logger=r}}class S extends events/* IEvents */.H{constructor(s,r){super(),this.core=s,this.logger=r}}class ${constructor(s,r){this.logger=s,this.core=r}}class M{constructor(s,r,t){this.core=s,this.logger=r,this.store=t}}class O{constructor(s,r){this.projectId=s,this.logger=r}}class R{constructor(s,r,t){this.core=s,this.logger=r,this.telemetryEnabled=t}}var T=Object.defineProperty,k=(e,s,r)=>s in e?T(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r,i=(e,s,r)=>k(e,typeof s!="symbol"?s+"":s,r);class H extends (external_events_default()){constructor(){super()}}class J{constructor(s){this.opts=s,i(this,"protocol","wc"),i(this,"version",2)}}class K extends external_events_.EventEmitter{constructor(){super()}}class V{constructor(s){this.client=s}}
//# sourceMappingURL=index.es.js.map

// EXTERNAL MODULE: ./node_modules/@walletconnect/time/dist/cjs/index.js
var cjs = __webpack_require__(388900);
// EXTERNAL MODULE: ./node_modules/@walletconnect/safe-json/dist/esm/index.js
var esm = __webpack_require__(213554);
// EXTERNAL MODULE: ./node_modules/@walletconnect/relay-auth/dist/index.es.js
var relay_auth_dist_index_es = __webpack_require__(338236);
// EXTERNAL MODULE: ./node_modules/detect-browser/es/index.js
var es = __webpack_require__(248468);
// EXTERNAL MODULE: ./node_modules/@walletconnect/window-getters/dist/cjs/index.js
var dist_cjs = __webpack_require__(838196);
// EXTERNAL MODULE: ./node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var window_metadata_dist_cjs = __webpack_require__(842063);
// EXTERNAL MODULE: ./node_modules/bs58/src/esm/index.js + 1 modules
var src_esm = __webpack_require__(148450);
// EXTERNAL MODULE: ./node_modules/uint8arrays/esm/src/index.js + 20 modules
var src = __webpack_require__(460872);
// EXTERNAL MODULE: ./node_modules/@walletconnect/relay-api/dist/index.es.js
var relay_api_dist_index_es = __webpack_require__(443228);
;// ./node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/index.es.js
const ae=":";function Ne(t){const[e,n]=t.split(ae);return{namespace:e,reference:n}}function An(t){const{namespace:e,reference:n}=t;return[e,n].join(ae)}function Ue(t){const[e,n,r]=t.split(ae);return{namespace:e,reference:n,address:r}}function Bn(t){const{namespace:e,reference:n,address:r}=t;return[e,n,r].join(ae)}function Te(t,e){const n=[];return t.forEach(r=>{const o=e(r);n.includes(o)||n.push(o)}),n}function In(t){const{address:e}=Ue(t);return e}function Nn(t){const{namespace:e,reference:n}=Ue(t);return An({namespace:e,reference:n})}function Ho(t,e){const{namespace:n,reference:r}=Ne(e);return Bn({namespace:n,reference:r,address:t})}function qo(t){return Te(t,In)}function Un(t){return Te(t,Nn)}function Ko(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...o.accounts)}),n}function Fo(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...Un(o.accounts))}),n}function zo(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...ue(r,o))}),n}function ue(t,e){return t.includes(":")?[t]:e.chains||[]}var Zo=Object.defineProperty,Yo=Object.defineProperties,Go=Object.getOwnPropertyDescriptors,Tn=Object.getOwnPropertySymbols,Wo=Object.prototype.hasOwnProperty,Xo=Object.prototype.propertyIsEnumerable,Rn=(t,e,n)=>e in t?Zo(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,_n=(t,e)=>{for(var n in e||(e={}))Wo.call(e,n)&&Rn(t,n,e[n]);if(Tn)for(var n of Tn(e))Xo.call(e,n)&&Rn(t,n,e[n]);return t},Jo=(t,e)=>Yo(t,Go(e));const $n="ReactNative",Y={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},fe=" ",Qo=":",Ln="/",Re=2,ti=1e3,jn="js";function _e(){return typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"}function pt(){return!(0,dist_cjs.getDocument)()&&!!(0,dist_cjs.getNavigator)()&&navigator.product===$n}function ei(){return pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="android"}function ni(){return pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="ios"}function Tt(){return!_e()&&!!(0,dist_cjs.getNavigator)()&&!!(0,dist_cjs.getDocument)()}function xt(){return pt()?Y.reactNative:_e()?Y.node:Tt()?Y.browser:Y.unknown}function ri(){var t;try{return pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Application)<"u"?(t=global.Application)==null?void 0:t.applicationId:void 0}catch{return}}function Cn(t,e){const n=new URLSearchParams(t);for(const r of Object.keys(e).sort())if(e.hasOwnProperty(r)){const o=e[r];o!==void 0&&n.set(r,o)}return n.toString()}function oi(t){var e,n;const r=Pn();try{return t!=null&&t.url&&r.url&&new URL(t.url).host!==new URL(r.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`),t.url=r.url),(e=t?.icons)!=null&&e.length&&t.icons.length>0&&(t.icons=t.icons.filter(o=>o!=="")),Jo(_n(_n({},r),t),{url:t?.url||r.url,name:t?.name||r.name,description:t?.description||r.description,icons:(n=t?.icons)!=null&&n.length&&t.icons.length>0?t.icons:r.icons})}catch(o){return console.warn("Error populating app metadata",o),t||r}}function Pn(){return (0,window_metadata_dist_cjs/* getWindowMetadata */.g)()||{name:"",description:"",url:"",icons:[""]}}function ii(t,e){var n;const r=xt(),o={protocol:t,version:e,env:r};return r==="browser"&&(o.host=((n=On())==null?void 0:n.host)||"unknown"),o}function kn(){if(xt()===Y.reactNative&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"){const{OS:n,Version:r}=global.Platform;return[n,r].join("-")}const t=(0,es/* detect */.o0)();if(t===null)return"unknown";const e=t.os?t.os.replace(" ","").toLowerCase():"unknown";return t.type==="browser"?[e,t.name,t.version].join("-"):[e,t.version].join("-")}function Vn(){var t;const e=xt();return e===Y.browser?[e,((t=(0,dist_cjs.getLocation)())==null?void 0:t.host)||"unknown"].join(":"):e}function Mn(t,e,n){const r=kn(),o=Vn();return[[t,e].join("-"),[jn,n].join("-"),r,o].join("/")}function si({protocol:t,version:e,relayUrl:n,sdkVersion:r,auth:o,projectId:i,useOnCloseEvent:s,bundleId:c,packageName:a}){const u=n.split("?"),l=Mn(t,e,r),f={auth:o,ua:l,projectId:i,useOnCloseEvent:s||void 0,packageName:a||void 0,bundleId:c||void 0},h=Cn(u[1]||"",f);return u[0]+"?"+h}function ci(t){let e=(t.match(/^[^:]+(?=:\/\/)/gi)||[])[0];const n=typeof e<"u"?t.split("://")[1]:t;return e=e==="wss"?"https":"http",[e,n].join("://")}function ai(t,e,n){if(!t[e]||typeof t[e]!==n)throw new Error(`Missing or invalid "${e}" param`)}function Dn(t,e=Re){return Hn(t.split(Ln),e)}function ui(t){return Dn(t).join(fe)}function gt(t,e){return t.filter(n=>e.includes(n)).length===t.length}function Hn(t,e=Re){return t.slice(Math.max(t.length-e,0))}function fi(t){return Object.fromEntries(t.entries())}function li(t){return new Map(Object.entries(t))}function di(t,e){const n={};return Object.keys(t).forEach(r=>{n[r]=e(t[r])}),n}const hi=t=>t;function qn(t){return t.trim().replace(/^\w/,e=>e.toUpperCase())}function pi(t){return t.split(fe).map(e=>qn(e)).join(fe)}function gi(t=cjs.FIVE_MINUTES,e){const n=(0,cjs.toMiliseconds)(t||cjs.FIVE_MINUTES);let r,o,i,s;return{resolve:c=>{i&&r&&(clearTimeout(i),r(c),s=Promise.resolve(c))},reject:c=>{i&&o&&(clearTimeout(i),o(c))},done:()=>new Promise((c,a)=>{if(s)return c(s);i=setTimeout(()=>{const u=new Error(e);s=Promise.reject(u),a(u)},n),r=c,o=a})}}function yi(t,e,n){return new Promise(async(r,o)=>{const i=setTimeout(()=>o(new Error(n)),e);try{const s=await t;r(s)}catch(s){o(s)}clearTimeout(i)})}function $e(t,e){if(typeof e=="string"&&e.startsWith(`${t}:`))return e;if(t.toLowerCase()==="topic"){if(typeof e!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${e}`}else if(t.toLowerCase()==="id"){if(typeof e!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${e}`}throw new Error(`Unknown expirer target type: ${t}`)}function mi(t){return $e("topic",t)}function wi(t){return $e("id",t)}function bi(t){const[e,n]=t.split(":"),r={id:void 0,topic:void 0};if(e==="topic"&&typeof n=="string")r.topic=n;else if(e==="id"&&Number.isInteger(Number(n)))r.id=Number(n);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`);return r}function Ei(t,e){return (0,cjs.fromMiliseconds)((e||Date.now())+(0,cjs.toMiliseconds)(t))}function vi(t){return Date.now()>=(0,cjs.toMiliseconds)(t)}function xi(t,e){return`${t}${e?`:${e}`:""}`}function ot(t=[],e=[]){return[...new Set([...t,...e])]}async function Si({id:t,topic:e,wcDeepLink:n}){var r;try{if(!n)return;const o=typeof n=="string"?JSON.parse(n):n,i=o?.href;if(typeof i!="string")return;const s=Kn(i,t,e),c=xt();if(c===Y.browser){if(!((r=Yt())!=null&&r.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}Fn(s)}else c===Y.reactNative&&typeof(global==null?void 0:global.Linking)<"u"&&await global.Linking.openURL(s)}catch(o){console.error(o)}}function Kn(t,e,n){const r=`requestId=${e}&sessionTopic=${n}`;t.endsWith("/")&&(t=t.slice(0,-1));let o=`${t}`;if(t.startsWith("https://t.me")){const i=t.includes("?")?"&startapp=":"?startapp=";o=`${o}${i}${Yn(r,!0)}`}else o=`${o}/wc?${r}`;return o}function Fn(t){let e="_self";Zn()?e="_top":(zn()||t.startsWith("https://")||t.startsWith("http://"))&&(e="_blank"),window.open(t,e,"noreferrer noopener")}async function Oi(t,e){let n="";try{if(Tt()&&(n=localStorage.getItem(e),n))return n;n=await t.getItem(e)}catch(r){console.error(r)}return n}function Le(t,e){return t.filter(n=>e.includes(n))}function Ai(t,e){if(!t.includes(e))return null;const n=t.split(/([&,?,=])/),r=n.indexOf(e);return n[r+2]}function index_es_Bi(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,t=>{const e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)})}function Ii(){return typeof process<"u"&&process.env.IS_VITEST==="true"}function zn(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function Zn(){try{return window.self!==window.top}catch{return!1}}function Yn(t,e=!1){const n=Buffer.from(t).toString("base64");return e?n.replace(/[=]/g,""):n}function je(t){return Buffer.from(t,"base64").toString("utf-8")}function Ni(t){return new Promise(e=>setTimeout(e,t))}function Wt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Ui(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Xt(t,...e){if(!Ui(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function index_es_Ce(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Wt(t.outputLen),Wt(t.blockLen)}function Rt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Gn(t,e){Xt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const le=BigInt(2**32-1),Wn=BigInt(32);function Ti(t,e=!1){return e?{h:Number(t&le),l:Number(t>>Wn&le)}:{h:Number(t>>Wn&le)|0,l:Number(t&le)|0}}function Ri(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=Ti(t[o],e);[n[o],r[o]]=[i,s]}return[n,r]}const _i=(t,e,n)=>t<<n|e>>>32-n,$i=(t,e,n)=>e<<n|t>>>32-n,Li=(t,e,n)=>e<<n-32|t>>>64-n,ji=(t,e,n)=>t<<n-32|e>>>64-n,_t=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Ci(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function Pe(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function ct(t,e){return t<<32-e|t>>>e}const Xn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Pi(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}function Jn(t){for(let e=0;e<t.length;e++)t[e]=Pi(t[e])}function ki(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function $t(t){return typeof t=="string"&&(t=ki(t)),Xt(t),t}function Vi(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];Xt(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}class ke{clone(){return this._cloneInto()}}function Qn(t){const e=r=>t().update($t(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Lt(t=32){if(_t&&typeof _t.getRandomValues=="function")return _t.getRandomValues(new Uint8Array(t));if(_t&&typeof _t.randomBytes=="function")return _t.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}const tr=[],er=[],nr=[],Mi=BigInt(0),Jt=BigInt(1),Di=BigInt(2),Hi=BigInt(7),qi=BigInt(256),Ki=BigInt(113);for(let t=0,e=Jt,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],tr.push(2*(5*r+n)),er.push((t+1)*(t+2)/2%64);let o=Mi;for(let i=0;i<7;i++)e=(e<<Jt^(e>>Hi)*Ki)%qi,e&Di&&(o^=Jt<<(Jt<<BigInt(i))-Jt);nr.push(o)}const[Fi,zi]=Ri(nr,!0),rr=(t,e,n)=>n>32?Li(t,e,n):_i(t,e,n),or=(t,e,n)=>n>32?ji(t,e,n):$i(t,e,n);function Zi(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let s=0;s<10;s++)n[s]=t[s]^t[s+10]^t[s+20]^t[s+30]^t[s+40];for(let s=0;s<10;s+=2){const c=(s+8)%10,a=(s+2)%10,u=n[a],l=n[a+1],f=rr(u,l,1)^n[c],h=or(u,l,1)^n[c+1];for(let y=0;y<50;y+=10)t[s+y]^=f,t[s+y+1]^=h}let o=t[2],i=t[3];for(let s=0;s<24;s++){const c=er[s],a=rr(o,i,c),u=or(o,i,c),l=tr[s];o=t[l],i=t[l+1],t[l]=a,t[l+1]=u}for(let s=0;s<50;s+=10){for(let c=0;c<10;c++)n[c]=t[s+c];for(let c=0;c<10;c++)t[s+c]^=~n[(c+2)%10]&n[(c+4)%10]}t[0]^=Fi[r],t[1]^=zi[r]}n.fill(0)}class En extends ke{constructor(e,n,r,o=!1,i=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Wt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ci(this.state)}keccak(){Xn||Jn(this.state32),Zi(this.state32,this.rounds),Xn||Jn(this.state32),this.posOut=0,this.pos=0}update(e){Rt(this);const{blockLen:n,state:r}=this;e=$t(e);const o=e.length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);for(let c=0;c<s;c++)r[this.pos++]^=e[i++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:r,blockLen:o}=this;e[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){Rt(this,!1),Xt(e),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,i=e.length;o<i;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,i-o);e.set(n.subarray(this.posOut,this.posOut+s),o),this.posOut+=s,o+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Wt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Gn(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:n,suffix:r,outputLen:o,rounds:i,enableXOF:s}=this;return e||(e=new En(n,r,o,s,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=o,e.enableXOF=s,e.destroyed=this.destroyed,e}}const Yi=(t,e,n)=>Qn(()=>new En(e,t,n)),Gi=Yi(1,136,256/8),Wi="https://rpc.walletconnect.org/v1";function Ve(t){const e=`Ethereum Signed Message:
${t.length}`,n=new TextEncoder().encode(e+t);return"0x"+Buffer.from(Gi(n)).toString("hex")}async function ir(t,e,n,r,o,i){switch(n.t){case"eip191":return await sr(t,e,n.s);case"eip1271":return await cr(t,e,n.s,r,o,i);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`)}}async function sr(t,e,n){return(await ko({hash:Ve(e),signature:n})).toLowerCase()===t.toLowerCase()}async function cr(t,e,n,r,o,i){const s=Ne(r);if(!s.namespace||!s.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);try{const c="0x1626ba7e",a="0000000000000000000000000000000000000000000000000000000000000040",u="0000000000000000000000000000000000000000000000000000000000000041",l=n.substring(2),f=Ve(e).substring(2),h=c+f+a+u+l,y=await fetch(`${i||Wi}/?chainId=${r}&projectId=${o}`,{method:"POST",body:JSON.stringify({id:Xi(),jsonrpc:"2.0",method:"eth_call",params:[{to:t,data:h},"latest"]})}),{result:E}=await y.json();return E?E.slice(0,c.length).toLowerCase()===c.toLowerCase():!1}catch(c){return console.error("isValidEip1271Signature: ",c),!1}}function Xi(){return Date.now()+Math.floor(Math.random()*1e3)}function Ji(t){const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);const r=n[0];if(r===0)throw new Error("No signatures found");const o=1+r*64;if(n.length<o)throw new Error("Transaction data too short for claimed signature count");if(n.length<100)throw new Error("Transaction too short");const i=Buffer.from(t,"base64").slice(1,65);return Vo.encode(i)}var Qi=Object.defineProperty,ts=Object.defineProperties,index_es_es=Object.getOwnPropertyDescriptors,ar=Object.getOwnPropertySymbols,ns=Object.prototype.hasOwnProperty,rs=Object.prototype.propertyIsEnumerable,ur=(t,e,n)=>e in t?Qi(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,Me=(t,e)=>{for(var n in e||(e={}))ns.call(e,n)&&ur(t,n,e[n]);if(ar)for(var n of ar(e))rs.call(e,n)&&ur(t,n,e[n]);return t},fr=(t,e)=>ts(t,index_es_es(e));const os="did:pkh:",de=t=>t?.split(":"),lr=t=>{const e=t&&de(t);if(e)return t.includes(os)?e[3]:e[1]},dr=t=>{const e=t&&de(t);if(e)return e[2]+":"+e[3]},De=t=>{const e=t&&de(t);if(e)return e.pop()};async function is(t){const{cacao:e,projectId:n}=t,{s:r,p:o}=e,i=hr(o,o.iss),s=De(o.iss);return await ir(s,i,r,dr(o.iss),n)}const hr=(t,e)=>{const n=`${t.domain} wants you to sign in with your Ethereum account:`,r=De(e);if(!t.aud&&!t.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let o=t.statement||void 0;const i=`URI: ${t.aud||t.uri}`,s=`Version: ${t.version}`,c=`Chain ID: ${lr(e)}`,a=`Nonce: ${t.nonce}`,u=`Issued At: ${t.iat}`,l=t.exp?`Expiration Time: ${t.exp}`:void 0,f=t.nbf?`Not Before: ${t.nbf}`:void 0,h=t.requestId?`Request ID: ${t.requestId}`:void 0,y=t.resources?`Resources:${t.resources.map(p=>`
- ${p}`).join("")}`:void 0,E=pe(t.resources);if(E){const p=yt(E);o=Ke(o,p)}return[n,r,"",o,"",i,s,c,a,u,l,f,h,y].filter(p=>p!=null).join(`
`)};function ss(t,e,n){return n.includes("did:pkh:")||(n=`did:pkh:${n}`),{h:{t:"caip122"},p:{iss:n,domain:t.domain,aud:t.aud,version:t.version,nonce:t.nonce,iat:t.iat,statement:t.statement,requestId:t.requestId,resources:t.resources,nbf:t.nbf,exp:t.exp},s:e}}function cs(t){var e;const{authPayload:n,chains:r,methods:o}=t,i=n.statement||"";if(!(r!=null&&r.length))return n;const s=n.chains,c=Le(s,r);if(!(c!=null&&c.length))throw new Error("No supported chains");const a=pr(n.resources);if(!a)return n;at(a);const u=gr(a,"eip155");let l=n?.resources||[];if(u!=null&&u.length){const f=yr(u),h=Le(f,o);if(!(h!=null&&h.length))throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f)}, supported: ${JSON.stringify(o)}`);const y=He("request",h,{chains:c}),E=Er(a,"eip155",y);l=((e=n?.resources)==null?void 0:e.slice(0,-1))||[],l.push(he(E))}return fr(Me({},n),{statement:xr(i,pe(l)),chains:c,resources:n!=null&&n.resources||l.length>0?l:void 0})}function pr(t){const e=pe(t);if(e&&qe(e))return yt(e)}function as(t,e){var n;return(n=t?.att)==null?void 0:n.hasOwnProperty(e)}function gr(t,e){var n,r;return(n=t?.att)!=null&&n[e]?Object.keys((r=t?.att)==null?void 0:r[e]):[]}function us(t){return t?.map(e=>Object.keys(e))||[]}function yr(t){return t?.map(e=>{var n;return(n=e.split("/"))==null?void 0:n[1]})||[]}function mr(t){return Buffer.from(JSON.stringify(t)).toString("base64")}function wr(t){return JSON.parse(Buffer.from(t,"base64").toString("utf-8"))}function at(t){if(!t)throw new Error("No recap provided, value is undefined");if(!t.att)throw new Error("No `att` property found");const e=Object.keys(t.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(n=>{const r=t.att[n];if(Array.isArray(r))throw new Error(`Resource must be an object: ${n}`);if(typeof r!="object")throw new Error(`Resource must be an object: ${n}`);if(!Object.keys(r).length)throw new Error(`Resource object is empty: ${n}`);Object.keys(r).forEach(o=>{const i=r[o];if(!Array.isArray(i))throw new Error(`Ability limits ${o} must be an array of objects, found: ${i}`);if(!i.length)throw new Error(`Value of ${o} is empty array, must be an array with objects`);i.forEach(s=>{if(typeof s!="object")throw new Error(`Ability limits (${o}) must be an array of objects, found: ${s}`)})})})}function br(t,e,n,r={}){return n?.sort((o,i)=>o.localeCompare(i)),{att:{[t]:He(e,n,r)}}}function Er(t,e,n){var r;t.att[e]=Me({},n);const o=(r=Object.keys(t.att))==null?void 0:r.sort((s,c)=>s.localeCompare(c)),i={att:{}};return o.reduce((s,c)=>(s.att[c]=t.att[c],s),i)}function He(t,e,n={}){e=e?.sort((o,i)=>o.localeCompare(i));const r=e.map(o=>({[`${t}/${o}`]:[n]}));return Object.assign({},...r)}function he(t){return at(t),`urn:recap:${mr(t).replace(/=/g,"")}`}function yt(t){const e=wr(t.replace("urn:recap:",""));return at(e),e}function fs(t,e,n){const r=br(t,e,n);return he(r)}function qe(t){return t&&t.includes("urn:recap:")}function ls(t,e){const n=yt(t),r=yt(e),o=vr(n,r);return he(o)}function vr(t,e){at(t),at(e);const n=Object.keys(t.att).concat(Object.keys(e.att)).sort((o,i)=>o.localeCompare(i)),r={att:{}};return n.forEach(o=>{var i,s;Object.keys(((i=t.att)==null?void 0:i[o])||{}).concat(Object.keys(((s=e.att)==null?void 0:s[o])||{})).sort((c,a)=>c.localeCompare(a)).forEach(c=>{var a,u;r.att[o]=fr(Me({},r.att[o]),{[c]:((a=t.att[o])==null?void 0:a[c])||((u=e.att[o])==null?void 0:u[c])})})}),r}function Ke(t="",e){at(e);const n="I further authorize the stated URI to perform the following actions on my behalf: ";if(t.includes(n))return t;const r=[];let o=0;Object.keys(e.att).forEach(c=>{const a=Object.keys(e.att[c]).map(f=>({ability:f.split("/")[0],action:f.split("/")[1]}));a.sort((f,h)=>f.action.localeCompare(h.action));const u={};a.forEach(f=>{u[f.ability]||(u[f.ability]=[]),u[f.ability].push(f.action)});const l=Object.keys(u).map(f=>(o++,`(${o}) '${f}': '${u[f].join("', '")}' for '${c}'.`));r.push(l.join(", ").replace(".,","."))});const i=r.join(" "),s=`${n}${i}`;return`${t?t+" ":""}${s}`}function ds(t){var e;const n=yt(t);at(n);const r=(e=n.att)==null?void 0:e.eip155;return r?Object.keys(r).map(o=>o.split("/")[1]):[]}function hs(t){const e=yt(t);at(e);const n=[];return Object.values(e.att).forEach(r=>{Object.values(r).forEach(o=>{var i;(i=o?.[0])!=null&&i.chains&&n.push(o[0].chains)})}),[...new Set(n.flat())]}function xr(t,e){if(!e)return t;const n=yt(e);return at(n),Ke(t,n)}function pe(t){if(!t)return;const e=t?.[t.length-1];return qe(e)?e:void 0}function Fe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Sr(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function tt(t,...e){if(!Sr(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function Or(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function ps(t,e){tt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function Ar(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}const mt=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),gs=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),ys=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!ys)throw new Error("Non little-endian hardware is not supported");function ms(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function ze(t){if(typeof t=="string")t=ms(t);else if(Sr(t))t=Ze(t);else throw new Error("Uint8Array expected, got "+typeof t);return t}function ws(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function bs(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const Es=(t,e)=>{function n(r,...o){if(tt(r),t.nonceLength!==void 0){const l=o[0];if(!l)throw new Error("nonce / iv required");t.varSizeNonce?tt(l):tt(l,t.nonceLength)}const i=t.tagLength;i&&o[1]!==void 0&&tt(o[1]);const s=e(r,...o),c=(l,f)=>{if(f!==void 0){if(l!==2)throw new Error("cipher output not supported");tt(f)}};let a=!1;return{encrypt(l,f){if(a)throw new Error("cannot encrypt() twice with same key + nonce");return a=!0,tt(l),c(s.encrypt.length,f),s.encrypt(l,f)},decrypt(l,f){if(tt(l),i&&l.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return c(s.decrypt.length,f),s.decrypt(l,f)}}}return Object.assign(n,t),n};function Br(t,e,n=!0){if(e===void 0)return new Uint8Array(t);if(e.length!==t)throw new Error("invalid output length, expected "+t+", got: "+e.length);if(n&&!vs(e))throw new Error("invalid output, must be aligned");return e}function Ir(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,u=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+u,c,r)}function vs(t){return t.byteOffset%4===0}function Ze(t){return Uint8Array.from(t)}function jt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}const Nr=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),xs=Nr("expand 16-byte k"),Ss=Nr("expand 32-byte k"),Os=mt(xs),As=mt(Ss);function index_es_V(t,e){return t<<e|t>>>32-e}function Ye(t){return t.byteOffset%4===0}const ge=64,Bs=16,Ur=2**32-1,Tr=new Uint32Array;function Is(t,e,n,r,o,i,s,c){const a=o.length,u=new Uint8Array(ge),l=mt(u),f=Ye(o)&&Ye(i),h=f?mt(o):Tr,y=f?mt(i):Tr;for(let E=0;E<a;s++){if(t(e,n,r,l,s,c),s>=Ur)throw new Error("arx: counter overflow");const p=Math.min(ge,a-E);if(f&&p===ge){const d=E/4;if(E%4!==0)throw new Error("arx: invalid block position");for(let v=0,m;v<Bs;v++)m=d+v,y[m]=h[m]^l[v];E+=ge;continue}for(let d=0,v;d<p;d++)v=E+d,i[v]=o[v]^u[d];E+=p}}function Ns(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:i,rounds:s}=ws({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return Fe(o),Fe(s),Ar(i),Ar(n),(c,a,u,l,f=0)=>{tt(c),tt(a),tt(u);const h=u.length;if(l===void 0&&(l=new Uint8Array(h)),tt(l),Fe(f),f<0||f>=Ur)throw new Error("arx: counter overflow");if(l.length<h)throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);const y=[];let E=c.length,p,d;if(E===32)y.push(p=Ze(c)),d=As;else if(E===16&&n)p=new Uint8Array(32),p.set(c),p.set(c,16),d=Os,y.push(p);else throw new Error(`arx: invalid 32-byte key, got length=${E}`);Ye(a)||y.push(a=Ze(a));const v=mt(p);if(r){if(a.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,v,mt(a.subarray(0,16)),v),a=a.subarray(16)}const m=16-o;if(m!==a.length)throw new Error(`arx: nonce must be ${m} or 16 bytes`);if(m!==12){const N=new Uint8Array(12);N.set(a,i?0:12-a.length),a=N,y.push(a)}const O=mt(a);return Is(t,d,v,O,u,l,f,s),jt(...y),l}}const F=(t,e)=>t[e++]&255|(t[e++]&255)<<8;class Us{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=ze(e),tt(e,32);const n=F(e,0),r=F(e,2),o=F(e,4),i=F(e,6),s=F(e,8),c=F(e,10),a=F(e,12),u=F(e,14);this.r[0]=n&8191,this.r[1]=(n>>>13|r<<3)&8191,this.r[2]=(r>>>10|o<<6)&7939,this.r[3]=(o>>>7|i<<9)&8191,this.r[4]=(i>>>4|s<<12)&255,this.r[5]=s>>>1&8190,this.r[6]=(s>>>14|c<<2)&8191,this.r[7]=(c>>>11|a<<5)&8065,this.r[8]=(a>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let l=0;l<8;l++)this.pad[l]=F(e,16+2*l)}process(e,n,r=!1){const o=r?0:2048,{h:i,r:s}=this,c=s[0],a=s[1],u=s[2],l=s[3],f=s[4],h=s[5],y=s[6],E=s[7],p=s[8],d=s[9],v=F(e,n+0),m=F(e,n+2),O=F(e,n+4),N=F(e,n+6),$=F(e,n+8),B=F(e,n+10),A=F(e,n+12),T=F(e,n+14);let S=i[0]+(v&8191),L=i[1]+((v>>>13|m<<3)&8191),U=i[2]+((m>>>10|O<<6)&8191),_=i[3]+((O>>>7|N<<9)&8191),j=i[4]+((N>>>4|$<<12)&8191),g=i[5]+($>>>1&8191),w=i[6]+(($>>>14|B<<2)&8191),b=i[7]+((B>>>11|A<<5)&8191),I=i[8]+((A>>>8|T<<8)&8191),R=i[9]+(T>>>5|o),x=0,C=x+S*c+L*(5*d)+U*(5*p)+_*(5*E)+j*(5*y);x=C>>>13,C&=8191,C+=g*(5*h)+w*(5*f)+b*(5*l)+I*(5*u)+R*(5*a),x+=C>>>13,C&=8191;let P=x+S*a+L*c+U*(5*d)+_*(5*p)+j*(5*E);x=P>>>13,P&=8191,P+=g*(5*y)+w*(5*h)+b*(5*f)+I*(5*l)+R*(5*u),x+=P>>>13,P&=8191;let k=x+S*u+L*a+U*c+_*(5*d)+j*(5*p);x=k>>>13,k&=8191,k+=g*(5*E)+w*(5*y)+b*(5*h)+I*(5*f)+R*(5*l),x+=k>>>13,k&=8191;let M=x+S*l+L*u+U*a+_*c+j*(5*d);x=M>>>13,M&=8191,M+=g*(5*p)+w*(5*E)+b*(5*y)+I*(5*h)+R*(5*f),x+=M>>>13,M&=8191;let D=x+S*f+L*l+U*u+_*a+j*c;x=D>>>13,D&=8191,D+=g*(5*d)+w*(5*p)+b*(5*E)+I*(5*y)+R*(5*h),x+=D>>>13,D&=8191;let z=x+S*h+L*f+U*l+_*u+j*a;x=z>>>13,z&=8191,z+=g*c+w*(5*d)+b*(5*p)+I*(5*E)+R*(5*y),x+=z>>>13,z&=8191;let Z=x+S*y+L*h+U*f+_*l+j*u;x=Z>>>13,Z&=8191,Z+=g*a+w*c+b*(5*d)+I*(5*p)+R*(5*E),x+=Z>>>13,Z&=8191;let st=x+S*E+L*y+U*h+_*f+j*l;x=st>>>13,st&=8191,st+=g*u+w*a+b*c+I*(5*d)+R*(5*p),x+=st>>>13,st&=8191;let W=x+S*p+L*E+U*y+_*h+j*f;x=W>>>13,W&=8191,W+=g*l+w*u+b*a+I*c+R*(5*d),x+=W>>>13,W&=8191;let J=x+S*d+L*p+U*E+_*y+j*h;x=J>>>13,J&=8191,J+=g*f+w*l+b*u+I*a+R*c,x+=J>>>13,J&=8191,x=(x<<2)+x|0,x=x+C|0,C=x&8191,x=x>>>13,P+=x,i[0]=C,i[1]=P,i[2]=k,i[3]=M,i[4]=D,i[5]=z,i[6]=Z,i[7]=st,i[8]=W,i[9]=J}finalize(){const{h:e,pad:n}=this,r=new Uint16Array(10);let o=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=o,o=e[c]>>>13,e[c]&=8191;e[0]+=o*5,o=e[0]>>>13,e[0]&=8191,e[1]+=o,o=e[1]>>>13,e[1]&=8191,e[2]+=o,r[0]=e[0]+5,o=r[0]>>>13,r[0]&=8191;for(let c=1;c<10;c++)r[c]=e[c]+o,o=r[c]>>>13,r[c]&=8191;r[9]-=8192;let i=(o^1)-1;for(let c=0;c<10;c++)r[c]&=i;i=~i;for(let c=0;c<10;c++)e[c]=e[c]&i|r[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let s=e[0]+n[0];e[0]=s&65535;for(let c=1;c<8;c++)s=(e[c]+n[c]|0)+(s>>>16)|0,e[c]=s&65535;jt(r)}update(e){Or(this);const{buffer:n,blockLen:r}=this;e=ze(e);const o=e.length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s===r){for(;r<=o-i;i+=r)this.process(e,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(n,0,!1),this.pos=0)}return this}destroy(){jt(this.h,this.r,this.buffer,this.pad)}digestInto(e){Or(this),ps(e,this),this.finished=!0;const{buffer:n,h:r}=this;let{pos:o}=this;if(o){for(n[o++]=1;o<16;o++)n[o]=0;this.process(n,0,!0)}this.finalize();let i=0;for(let s=0;s<8;s++)e[i++]=r[s]>>>0,e[i++]=r[s]>>>8;return e}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}}function Ts(t){const e=(r,o)=>t(o).update(ze(r)).digest(),n=t(new Uint8Array(32));return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}const Rs=Ts(t=>new Us(t));function _s(t,e,n,r,o,i=20){let s=t[0],c=t[1],a=t[2],u=t[3],l=e[0],f=e[1],h=e[2],y=e[3],E=e[4],p=e[5],d=e[6],v=e[7],m=o,O=n[0],N=n[1],$=n[2],B=s,A=c,T=a,S=u,L=l,U=f,_=h,j=y,g=E,w=p,b=d,I=v,R=m,x=O,C=N,P=$;for(let M=0;M<i;M+=2)B=B+L|0,R=index_es_V(R^B,16),g=g+R|0,L=index_es_V(L^g,12),B=B+L|0,R=index_es_V(R^B,8),g=g+R|0,L=index_es_V(L^g,7),A=A+U|0,x=index_es_V(x^A,16),w=w+x|0,U=index_es_V(U^w,12),A=A+U|0,x=index_es_V(x^A,8),w=w+x|0,U=index_es_V(U^w,7),T=T+_|0,C=index_es_V(C^T,16),b=b+C|0,_=index_es_V(_^b,12),T=T+_|0,C=index_es_V(C^T,8),b=b+C|0,_=index_es_V(_^b,7),S=S+j|0,P=index_es_V(P^S,16),I=I+P|0,j=index_es_V(j^I,12),S=S+j|0,P=index_es_V(P^S,8),I=I+P|0,j=index_es_V(j^I,7),B=B+U|0,P=index_es_V(P^B,16),b=b+P|0,U=index_es_V(U^b,12),B=B+U|0,P=index_es_V(P^B,8),b=b+P|0,U=index_es_V(U^b,7),A=A+_|0,R=index_es_V(R^A,16),I=I+R|0,_=index_es_V(_^I,12),A=A+_|0,R=index_es_V(R^A,8),I=I+R|0,_=index_es_V(_^I,7),T=T+j|0,x=index_es_V(x^T,16),g=g+x|0,j=index_es_V(j^g,12),T=T+j|0,x=index_es_V(x^T,8),g=g+x|0,j=index_es_V(j^g,7),S=S+L|0,C=index_es_V(C^S,16),w=w+C|0,L=index_es_V(L^w,12),S=S+L|0,C=index_es_V(C^S,8),w=w+C|0,L=index_es_V(L^w,7);let k=0;r[k++]=s+B|0,r[k++]=c+A|0,r[k++]=a+T|0,r[k++]=u+S|0,r[k++]=l+L|0,r[k++]=f+U|0,r[k++]=h+_|0,r[k++]=y+j|0,r[k++]=E+g|0,r[k++]=p+w|0,r[k++]=d+b|0,r[k++]=v+I|0,r[k++]=m+R|0,r[k++]=O+x|0,r[k++]=N+C|0,r[k++]=$+P|0}const $s=Ns(_s,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Ls=new Uint8Array(16),Rr=(t,e)=>{t.update(e);const n=e.length%16;n&&t.update(Ls.subarray(n))},js=new Uint8Array(32);function _r(t,e,n,r,o){const i=t(e,n,js),s=Rs.create(i);o&&Rr(s,o),Rr(s,r);const c=new Uint8Array(16),a=gs(c);Ir(a,0,BigInt(o?o.length:0),!0),Ir(a,8,BigInt(r.length),!0),s.update(c);const u=s.digest();return jt(i,c),u}const Cs=t=>(e,n,r)=>({encrypt(i,s){const c=i.length;s=Br(c+16,s,!1),s.set(i);const a=s.subarray(0,-16);t(e,n,a,a,1);const u=_r(t,e,n,a,r);return s.set(u,c),jt(u),s},decrypt(i,s){s=Br(i.length-16,s,!1);const c=i.subarray(0,-16),a=i.subarray(-16),u=_r(t,e,n,c,r);if(!bs(a,u))throw new Error("invalid tag");return s.set(i.subarray(0,-16)),t(e,n,s,s,1),jt(u),s}}),$r=Es({blockSize:64,nonceLength:12,tagLength:16},Cs($s));class Lr extends ke{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,index_es_Ce(e);const r=$t(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?e.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(e){return Rt(this),this.iHash.update(e),this}digestInto(e){Rt(this),Xt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=s,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ye=(t,e,n)=>new Lr(t,e).update(n).digest();ye.create=(t,e)=>new Lr(t,e);function Ps(t,e,n){return index_es_Ce(t),n===void 0&&(n=new Uint8Array(t.outputLen)),ye(t,$t(n),$t(e))}const Ge=new Uint8Array([0]),jr=new Uint8Array;function ks(t,e,n,r=32){if(index_es_Ce(t),Wt(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/t.outputLen);n===void 0&&(n=jr);const i=new Uint8Array(o*t.outputLen),s=ye.create(t,e),c=s._cloneInto(),a=new Uint8Array(s.outputLen);for(let u=0;u<o;u++)Ge[0]=u+1,c.update(u===0?jr:a).update(n).update(Ge).digestInto(a),i.set(a,t.outputLen*u),s._cloneInto(c);return s.destroy(),c.destroy(),a.fill(0),Ge.fill(0),i.slice(0,r)}const Vs=(t,e,n,r,o)=>ks(t,Ps(t,e,n),r,o);function Ms(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,u=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+u,c,r)}function Ds(t,e,n){return t&e^~t&n}function Hs(t,e,n){return t&e^t&n^e&n}class qs extends ke{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pe(this.buffer)}update(e){Rt(this);const{view:n,buffer:r,blockLen:o}=this;e=$t(e);const i=e.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=Pe(e);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(e.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Rt(this),Gn(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let f=s;f<o;f++)n[f]=0;Ms(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=Pe(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)c.setUint32(4*f,l[f],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=s,o%n&&e.buffer.set(r),e}}const Ks=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bt=new Uint32Array(64);class Fs extends qs{constructor(){super(64,32,8,!1),this.A=wt[0]|0,this.B=wt[1]|0,this.C=wt[2]|0,this.D=wt[3]|0,this.E=wt[4]|0,this.F=wt[5]|0,this.G=wt[6]|0,this.H=wt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:s,G:c,H:a}=this;return[e,n,r,o,i,s,c,a]}set(e,n,r,o,i,s,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=a|0}process(e,n){for(let f=0;f<16;f++,n+=4)bt[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const h=bt[f-15],y=bt[f-2],E=ct(h,7)^ct(h,18)^h>>>3,p=ct(y,17)^ct(y,19)^y>>>10;bt[f]=p+bt[f-7]+E+bt[f-16]|0}let{A:r,B:o,C:i,D:s,E:c,F:a,G:u,H:l}=this;for(let f=0;f<64;f++){const h=ct(c,6)^ct(c,11)^ct(c,25),y=l+h+Ds(c,a,u)+Ks[f]+bt[f]|0,p=(ct(r,2)^ct(r,13)^ct(r,22))+Hs(r,o,i)|0;l=u,u=a,a=c,c=s+y|0,s=i,i=o,o=r,r=y+p|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,o,i,s,c,a,u,l)}roundClean(){bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Qt=Qn(()=>new Fs);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const me=BigInt(0),we=BigInt(1),zs=BigInt(2);function St(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function te(t){if(!St(t))throw new Error("Uint8Array expected")}function Ct(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}const Zs=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Pt(t){te(t);let e="";for(let n=0;n<t.length;n++)e+=Zs[t[n]];return e}function index_es_kt(t){const e=t.toString(16);return e.length&1?"0"+e:e}function We(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?me:BigInt("0x"+t)}const ut={_0:48,_9:57,A:65,F:70,a:97,f:102};function Cr(t){if(t>=ut._0&&t<=ut._9)return t-ut._0;if(t>=ut.A&&t<=ut.F)return t-(ut.A-10);if(t>=ut.a&&t<=ut.f)return t-(ut.a-10)}function Vt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const s=Cr(t.charCodeAt(i)),c=Cr(t.charCodeAt(i+1));if(s===void 0||c===void 0){const a=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}r[o]=s*16+c}return r}function Ot(t){return We(Pt(t))}function ee(t){return te(t),We(Pt(Uint8Array.from(t).reverse()))}function Mt(t,e){return Vt(t.toString(16).padStart(e*2,"0"))}function be(t,e){return Mt(t,e).reverse()}function Ys(t){return Vt(index_es_kt(t))}function et(t,e,n){let r;if(typeof e=="string")try{r=Vt(e)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(St(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function ne(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];te(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}function Gs(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function Ws(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Xe=t=>typeof t=="bigint"&&me<=t;function Ee(t,e,n){return Xe(t)&&Xe(e)&&Xe(n)&&e<=t&&t<n}function ft(t,e,n,r){if(!Ee(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function Pr(t){let e;for(e=0;t>me;t>>=we,e+=1);return e}function Xs(t,e){return t>>BigInt(e)&we}function Js(t,e,n){return t|(n?we:me)<<BigInt(e)}const Je=t=>(zs<<BigInt(t-1))-we,Qe=t=>new Uint8Array(t),kr=t=>Uint8Array.from(t);function Vr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Qe(t),o=Qe(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...f)=>n(o,r,...f),a=(f=Qe())=>{o=c(kr([0]),f),r=c(),f.length!==0&&(o=c(kr([1]),f),r=c())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const h=[];for(;f<e;){r=c();const y=r.slice();h.push(y),f+=r.length}return ne(...h)};return(f,h)=>{s(),a(f);let y;for(;!(y=h(u()));)a();return s(),y}}const Qs={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||St(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Dt(t,e,n={}){const r=(o,i,s)=>{const c=Qs[i];if(typeof c!="function")throw new Error("invalid validator function");const a=t[o];if(!(s&&a===void 0)&&!c(a,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+a)};for(const[o,i]of Object.entries(e))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return t}const tc=()=>{throw new Error("not implemented")};function tn(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(o!==void 0)return o;const i=t(n,...r);return e.set(n,i),i}}var ec=Object.freeze({__proto__:null,isBytes:St,abytes:te,abool:Ct,bytesToHex:Pt,numberToHexUnpadded:index_es_kt,hexToNumber:We,hexToBytes:Vt,bytesToNumberBE:Ot,bytesToNumberLE:ee,numberToBytesBE:Mt,numberToBytesLE:be,numberToVarBytesBE:Ys,ensureBytes:et,concatBytes:ne,equalBytes:Gs,utf8ToBytes:Ws,inRange:Ee,aInRange:ft,bitLen:Pr,bitGet:Xs,bitSet:Js,bitMask:Je,createHmacDrbg:Vr,validateObject:Dt,notImplemented:tc,memoized:tn});const q=BigInt(0),index_es_H=BigInt(1),At=BigInt(2),nc=BigInt(3),en=BigInt(4),Mr=BigInt(5),Dr=BigInt(8);function X(t,e){const n=t%e;return n>=q?n:e+n}function Hr(t,e,n){if(e<q)throw new Error("invalid exponent, negatives unsupported");if(n<=q)throw new Error("invalid modulus");if(n===index_es_H)return q;let r=index_es_H;for(;e>q;)e&index_es_H&&(r=r*t%n),t=t*t%n,e>>=index_es_H;return r}function it(t,e,n){let r=t;for(;e-- >q;)r*=r,r%=n;return r}function nn(t,e){if(t===q)throw new Error("invert: expected non-zero number");if(e<=q)throw new Error("invert: expected positive modulus, got "+e);let n=X(t,e),r=e,o=q,i=index_es_H;for(;n!==q;){const c=r/n,a=r%n,u=o-i*c;r=n,n=a,o=i,i=u}if(r!==index_es_H)throw new Error("invert: does not exist");return X(o,e)}function rc(t){const e=(t-index_es_H)/At;let n,r,o;for(n=t-index_es_H,r=0;n%At===q;n/=At,r++);for(o=At;o<t&&Hr(o,e,t)!==t-index_es_H;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const s=(t+index_es_H)/en;return function(a,u){const l=a.pow(u,s);if(!a.eql(a.sqr(l),u))throw new Error("Cannot find square root");return l}}const i=(n+index_es_H)/At;return function(c,a){if(c.pow(a,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,l=c.pow(c.mul(c.ONE,o),n),f=c.pow(a,i),h=c.pow(a,n);for(;!c.eql(h,c.ONE);){if(c.eql(h,c.ZERO))return c.ZERO;let y=1;for(let p=c.sqr(h);y<u&&!c.eql(p,c.ONE);y++)p=c.sqr(p);const E=c.pow(l,index_es_H<<BigInt(u-y-1));l=c.sqr(E),f=c.mul(f,E),h=c.mul(h,l),u=y}return f}}function oc(t){if(t%en===nc){const e=(t+index_es_H)/en;return function(r,o){const i=r.pow(o,e);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%Dr===Mr){const e=(t-Mr)/Dr;return function(r,o){const i=r.mul(o,At),s=r.pow(i,e),c=r.mul(o,s),a=r.mul(r.mul(c,At),s),u=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return rc(t)}const ic=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function sc(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=ic.reduce((r,o)=>(r[o]="function",r),e);return Dt(t,n)}function cc(t,e,n){if(n<q)throw new Error("invalid exponent, negatives unsupported");if(n===q)return t.ONE;if(n===index_es_H)return e;let r=t.ONE,o=e;for(;n>q;)n&index_es_H&&(r=t.mul(r,o)),o=t.sqr(o),n>>=index_es_H;return r}function ac(t,e){const n=new Array(e.length),r=e.reduce((i,s,c)=>t.is0(s)?i:(n[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return e.reduceRight((i,s,c)=>t.is0(s)?i:(n[c]=t.mul(i,n[c]),t.mul(i,s)),o),n}function qr(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Kr(t,e,n=!1,r={}){if(t<=q)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=qr(t,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const c=Object.freeze({ORDER:t,isLE:n,BITS:o,BYTES:i,MASK:Je(o),ZERO:q,ONE:index_es_H,create:a=>X(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return q<=a&&a<t},is0:a=>a===q,isOdd:a=>(a&index_es_H)===index_es_H,neg:a=>X(-a,t),eql:(a,u)=>a===u,sqr:a=>X(a*a,t),add:(a,u)=>X(a+u,t),sub:(a,u)=>X(a-u,t),mul:(a,u)=>X(a*u,t),pow:(a,u)=>cc(c,a,u),div:(a,u)=>X(a*nn(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>nn(a,t),sqrt:r.sqrt||(a=>(s||(s=oc(t)),s(c,a))),invertBatch:a=>ac(c,a),cmov:(a,u,l)=>l?u:a,toBytes:a=>n?be(a,i):Mt(a,i),fromBytes:a=>{if(a.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+a.length);return n?ee(a):Ot(a)}});return Object.freeze(c)}function Fr(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function zr(t){const e=Fr(t);return e+Math.ceil(e/2)}function uc(t,e,n=!1){const r=t.length,o=Fr(e),i=zr(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=n?ee(t):Ot(t),c=X(s,e-index_es_H)+index_es_H;return n?be(c,o):Mt(c,o)}const Zr=BigInt(0),ve=BigInt(1);function rn(t,e){const n=e.negate();return t?n:e}function Yr(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function on(t,e){Yr(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1);return{windows:n,windowSize:r}}function fc(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function lc(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const sn=new WeakMap,Gr=new WeakMap;function cn(t){return Gr.get(t)||1}function dc(t,e){return{constTimeNegate:rn,hasPrecomputes(n){return cn(n)!==1},unsafeLadder(n,r,o=t.ZERO){let i=n;for(;r>Zr;)r&ve&&(o=o.add(i)),i=i.double(),r>>=ve;return o},precomputeWindow(n,r){const{windows:o,windowSize:i}=on(r,e),s=[];let c=n,a=c;for(let u=0;u<o;u++){a=c,s.push(a);for(let l=1;l<i;l++)a=a.add(c),s.push(a);c=a.double()}return s},wNAF(n,r,o){const{windows:i,windowSize:s}=on(n,e);let c=t.ZERO,a=t.BASE;const u=BigInt(2**n-1),l=2**n,f=BigInt(n);for(let h=0;h<i;h++){const y=h*s;let E=Number(o&u);o>>=f,E>s&&(E-=l,o+=ve);const p=y,d=y+Math.abs(E)-1,v=h%2!==0,m=E<0;E===0?a=a.add(rn(v,r[p])):c=c.add(rn(m,r[d]))}return{p:c,f:a}},wNAFUnsafe(n,r,o,i=t.ZERO){const{windows:s,windowSize:c}=on(n,e),a=BigInt(2**n-1),u=2**n,l=BigInt(n);for(let f=0;f<s;f++){const h=f*c;if(o===Zr)break;let y=Number(o&a);if(o>>=l,y>c&&(y-=u,o+=ve),y===0)continue;let E=r[h+Math.abs(y)-1];y<0&&(E=E.negate()),i=i.add(E)}return i},getPrecomputes(n,r,o){let i=sn.get(r);return i||(i=this.precomputeWindow(r,n),n!==1&&sn.set(r,o(i))),i},wNAFCached(n,r,o){const i=cn(n);return this.wNAF(i,this.getPrecomputes(i,n,o),r)},wNAFCachedUnsafe(n,r,o,i){const s=cn(n);return s===1?this.unsafeLadder(n,r,i):this.wNAFUnsafe(s,this.getPrecomputes(s,n,o),r,i)},setWindowSize(n,r){Yr(r,e),Gr.set(n,r),sn.delete(n)}}}function hc(t,e,n,r){if(fc(n,t),lc(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=Pr(BigInt(n.length)),s=i>12?i-3:i>4?i-2:i?2:1,c=(1<<s)-1,a=new Array(c+1).fill(o),u=Math.floor((e.BITS-1)/s)*s;let l=o;for(let f=u;f>=0;f-=s){a.fill(o);for(let y=0;y<r.length;y++){const E=r[y],p=Number(E>>BigInt(f)&BigInt(c));a[p]=a[p].add(n[y])}let h=o;for(let y=a.length-1,E=o;y>0;y--)E=E.add(a[y]),h=h.add(E);if(l=l.add(h),f!==0)for(let y=0;y<s;y++)l=l.double()}return l}function Wr(t){return sc(t.Fp),Dt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...qr(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const Ht=BigInt(0),an=BigInt(1);function pc(t){return Dt(t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...t})}function gc(t){const e=pc(t),{P:n}=e,r=m=>X(m,n),o=e.montgomeryBits,i=Math.ceil(o/8),s=e.nByteLength,c=e.adjustScalarBytes||(m=>m),a=e.powPminus2||(m=>Hr(m,n-BigInt(2),n));function u(m,O,N){const $=r(m*(O-N));return O=r(O-$),N=r(N+$),[O,N]}const l=(e.a-BigInt(2))/BigInt(4);function f(m,O){ft("u",m,Ht,n),ft("scalar",O,Ht,n);const N=O,$=m;let B=an,A=Ht,T=m,S=an,L=Ht,U;for(let j=BigInt(o-1);j>=Ht;j--){const g=N>>j&an;L^=g,U=u(L,B,T),B=U[0],T=U[1],U=u(L,A,S),A=U[0],S=U[1],L=g;const w=B+A,b=r(w*w),I=B-A,R=r(I*I),x=b-R,C=T+S,P=T-S,k=r(P*w),M=r(C*I),D=k+M,z=k-M;T=r(D*D),S=r($*r(z*z)),B=r(b*R),A=r(x*(b+r(l*x)))}U=u(L,B,T),B=U[0],T=U[1],U=u(L,A,S),A=U[0],S=U[1];const _=a(A);return r(B*_)}function h(m){return be(r(m),i)}function y(m){const O=et("u coordinate",m,i);return s===32&&(O[31]&=127),ee(O)}function E(m){const O=et("scalar",m),N=O.length;if(N!==i&&N!==s){let $=""+i+" or "+s;throw new Error("invalid scalar, expected "+$+" bytes, got "+N)}return ee(c(O))}function p(m,O){const N=y(O),$=E(m),B=f(N,$);if(B===Ht)throw new Error("invalid private or public key received");return h(B)}const d=h(e.Gu);function v(m){return p(m,d)}return{scalarMult:p,scalarMultBase:v,getSharedSecret:(m,O)=>p(m,O),getPublicKey:m=>v(m),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:d}}const un=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const yc=BigInt(1),Xr=BigInt(2),mc=BigInt(3),wc=BigInt(5);BigInt(8);function bc(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),i=un,c=t*t%i*t%i,a=it(c,Xr,i)*c%i,u=it(a,yc,i)*t%i,l=it(u,wc,i)*u%i,f=it(l,e,i)*l%i,h=it(f,n,i)*f%i,y=it(h,r,i)*h%i,E=it(y,o,i)*y%i,p=it(E,o,i)*y%i,d=it(p,e,i)*l%i;return{pow_p_5_8:it(d,Xr,i)*t%i,b2:c}}function Ec(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const fn=gc({P:un,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=un,{pow_p_5_8:n,b2:r}=bc(t);return X(it(n,mc,e)*r,e)},adjustScalarBytes:Ec,randomBytes:Lt});function Jr(t){t.lowS!==void 0&&Ct("lowS",t.lowS),t.prehash!==void 0&&Ct("prehash",t.prehash)}function vc(t){const e=Wr(t);Dt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:xc,hexToBytes:Sc}=ec;class Oc extends Error{constructor(e=""){super(e)}}const lt={Err:Oc,_tlv:{encode:(t,e)=>{const{Err:n}=lt;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=index_es_kt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?index_es_kt(o.length/2|128):"";return index_es_kt(t)+i+o+e},decode(t,e){const{Err:n}=lt;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++],i=!!(o&128);let s=0;if(!i)s=o;else{const a=o&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+a);if(u.length!==a)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const l of u)s=s<<8|l;if(r+=a,s<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+s);if(c.length!==s)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+s)}}},_int:{encode(t){const{Err:e}=lt;if(t<dt)throw new e("integer: negative integers are not allowed");let n=index_es_kt(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=lt;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return xc(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=lt,o=typeof t=="string"?Sc(t):t;te(o);const{v:i,l:s}=r.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,i),{v:u,l}=r.decode(2,a);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=lt,r=e.encode(2,n.encode(t.r)),o=e.encode(2,n.encode(t.s)),i=r+o;return e.encode(48,i)}},dt=BigInt(0),index_es_K=BigInt(1);BigInt(2);const Qr=BigInt(3);BigInt(4);function Ac(t){const e=vc(t),{Fp:n}=e,r=Kr(e.n,e.nBitLength),o=e.toBytes||((p,d,v)=>{const m=d.toAffine();return ne(Uint8Array.from([4]),n.toBytes(m.x),n.toBytes(m.y))}),i=e.fromBytes||(p=>{const d=p.subarray(1),v=n.fromBytes(d.subarray(0,n.BYTES)),m=n.fromBytes(d.subarray(n.BYTES,2*n.BYTES));return{x:v,y:m}});function s(p){const{a:d,b:v}=e,m=n.sqr(p),O=n.mul(m,p);return n.add(n.add(O,n.mul(p,d)),v)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return Ee(p,index_es_K,e.n)}function a(p){const{allowedPrivateKeyLengths:d,nByteLength:v,wrapPrivateKey:m,n:O}=e;if(d&&typeof p!="bigint"){if(St(p)&&(p=Pt(p)),typeof p!="string"||!d.includes(p.length))throw new Error("invalid private key");p=p.padStart(v*2,"0")}let N;try{N=typeof p=="bigint"?p:Ot(et("private key",p,v))}catch{throw new Error("invalid private key, expected hex or "+v+" bytes, got "+typeof p)}return m&&(N=X(N,O)),ft("private key",N,index_es_K,O),N}function u(p){if(!(p instanceof h))throw new Error("ProjectivePoint expected")}const l=tn((p,d)=>{const{px:v,py:m,pz:O}=p;if(n.eql(O,n.ONE))return{x:v,y:m};const N=p.is0();d==null&&(d=N?n.ONE:n.inv(O));const $=n.mul(v,d),B=n.mul(m,d),A=n.mul(O,d);if(N)return{x:n.ZERO,y:n.ZERO};if(!n.eql(A,n.ONE))throw new Error("invZ was invalid");return{x:$,y:B}}),f=tn(p=>{if(p.is0()){if(e.allowInfinityPoint&&!n.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:d,y:v}=p.toAffine();if(!n.isValid(d)||!n.isValid(v))throw new Error("bad point: x or y not FE");const m=n.sqr(v),O=s(d);if(!n.eql(m,O))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(d,v,m){if(this.px=d,this.py=v,this.pz=m,d==null||!n.isValid(d))throw new Error("x required");if(v==null||!n.isValid(v))throw new Error("y required");if(m==null||!n.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:v,y:m}=d||{};if(!d||!n.isValid(v)||!n.isValid(m))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const O=N=>n.eql(N,n.ZERO);return O(v)&&O(m)?h.ZERO:new h(v,m,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const v=n.invertBatch(d.map(m=>m.pz));return d.map((m,O)=>m.toAffine(v[O])).map(h.fromAffine)}static fromHex(d){const v=h.fromAffine(i(et("pointHex",d)));return v.assertValidity(),v}static fromPrivateKey(d){return h.BASE.multiply(a(d))}static msm(d,v){return hc(h,r,d,v)}_setWindowSize(d){E.setWindowSize(this,d)}assertValidity(){f(this)}hasEvenY(){const{y:d}=this.toAffine();if(n.isOdd)return!n.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){u(d);const{px:v,py:m,pz:O}=this,{px:N,py:$,pz:B}=d,A=n.eql(n.mul(v,B),n.mul(N,O)),T=n.eql(n.mul(m,B),n.mul($,O));return A&&T}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:d,b:v}=e,m=n.mul(v,Qr),{px:O,py:N,pz:$}=this;let B=n.ZERO,A=n.ZERO,T=n.ZERO,S=n.mul(O,O),L=n.mul(N,N),U=n.mul($,$),_=n.mul(O,N);return _=n.add(_,_),T=n.mul(O,$),T=n.add(T,T),B=n.mul(d,T),A=n.mul(m,U),A=n.add(B,A),B=n.sub(L,A),A=n.add(L,A),A=n.mul(B,A),B=n.mul(_,B),T=n.mul(m,T),U=n.mul(d,U),_=n.sub(S,U),_=n.mul(d,_),_=n.add(_,T),T=n.add(S,S),S=n.add(T,S),S=n.add(S,U),S=n.mul(S,_),A=n.add(A,S),U=n.mul(N,$),U=n.add(U,U),S=n.mul(U,_),B=n.sub(B,S),T=n.mul(U,L),T=n.add(T,T),T=n.add(T,T),new h(B,A,T)}add(d){u(d);const{px:v,py:m,pz:O}=this,{px:N,py:$,pz:B}=d;let A=n.ZERO,T=n.ZERO,S=n.ZERO;const L=e.a,U=n.mul(e.b,Qr);let _=n.mul(v,N),j=n.mul(m,$),g=n.mul(O,B),w=n.add(v,m),b=n.add(N,$);w=n.mul(w,b),b=n.add(_,j),w=n.sub(w,b),b=n.add(v,O);let I=n.add(N,B);return b=n.mul(b,I),I=n.add(_,g),b=n.sub(b,I),I=n.add(m,O),A=n.add($,B),I=n.mul(I,A),A=n.add(j,g),I=n.sub(I,A),S=n.mul(L,b),A=n.mul(U,g),S=n.add(A,S),A=n.sub(j,S),S=n.add(j,S),T=n.mul(A,S),j=n.add(_,_),j=n.add(j,_),g=n.mul(L,g),b=n.mul(U,b),j=n.add(j,g),g=n.sub(_,g),g=n.mul(L,g),b=n.add(b,g),_=n.mul(j,b),T=n.add(T,_),_=n.mul(I,b),A=n.mul(w,A),A=n.sub(A,_),_=n.mul(w,j),S=n.mul(I,S),S=n.add(S,_),new h(A,T,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return E.wNAFCached(this,d,h.normalizeZ)}multiplyUnsafe(d){const{endo:v,n:m}=e;ft("scalar",d,dt,m);const O=h.ZERO;if(d===dt)return O;if(this.is0()||d===index_es_K)return this;if(!v||E.hasPrecomputes(this))return E.wNAFCachedUnsafe(this,d,h.normalizeZ);let{k1neg:N,k1:$,k2neg:B,k2:A}=v.splitScalar(d),T=O,S=O,L=this;for(;$>dt||A>dt;)$&index_es_K&&(T=T.add(L)),A&index_es_K&&(S=S.add(L)),L=L.double(),$>>=index_es_K,A>>=index_es_K;return N&&(T=T.negate()),B&&(S=S.negate()),S=new h(n.mul(S.px,v.beta),S.py,S.pz),T.add(S)}multiply(d){const{endo:v,n:m}=e;ft("scalar",d,index_es_K,m);let O,N;if(v){const{k1neg:$,k1:B,k2neg:A,k2:T}=v.splitScalar(d);let{p:S,f:L}=this.wNAF(B),{p:U,f:_}=this.wNAF(T);S=E.constTimeNegate($,S),U=E.constTimeNegate(A,U),U=new h(n.mul(U.px,v.beta),U.py,U.pz),O=S.add(U),N=L.add(_)}else{const{p:$,f:B}=this.wNAF(d);O=$,N=B}return h.normalizeZ([O,N])[0]}multiplyAndAddUnsafe(d,v,m){const O=h.BASE,N=(B,A)=>A===dt||A===index_es_K||!B.equals(O)?B.multiplyUnsafe(A):B.multiply(A),$=N(this,v).add(N(d,m));return $.is0()?void 0:$}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:v}=e;if(d===index_es_K)return!0;if(v)return v(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:v}=e;return d===index_es_K?this:v?v(h,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return Ct("isCompressed",d),this.assertValidity(),o(h,this,d)}toHex(d=!0){return Ct("isCompressed",d),Pt(this.toRawBytes(d))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const y=e.nBitLength,E=dc(h,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder:c}}function Bc(t){const e=Wr(t);return Dt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ic(t){const e=Bc(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(g){return X(g,r)}function c(g){return nn(g,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:f}=Ac({...e,toBytes(g,w,b){const I=w.toAffine(),R=n.toBytes(I.x),x=ne;return Ct("isCompressed",b),b?x(Uint8Array.from([w.hasEvenY()?2:3]),R):x(Uint8Array.from([4]),R,n.toBytes(I.y))},fromBytes(g){const w=g.length,b=g[0],I=g.subarray(1);if(w===o&&(b===2||b===3)){const R=Ot(I);if(!Ee(R,index_es_K,n.ORDER))throw new Error("Point is not on curve");const x=l(R);let C;try{C=n.sqrt(x)}catch(M){const D=M instanceof Error?": "+M.message:"";throw new Error("Point is not on curve"+D)}const P=(C&index_es_K)===index_es_K;return(b&1)===1!==P&&(C=n.neg(C)),{x:R,y:C}}else if(w===i&&b===4){const R=n.fromBytes(I.subarray(0,n.BYTES)),x=n.fromBytes(I.subarray(n.BYTES,2*n.BYTES));return{x:R,y:x}}else{const R=o,x=i;throw new Error("invalid Point, expected length of "+R+", or uncompressed "+x+", got "+w)}}}),h=g=>Pt(Mt(g,e.nByteLength));function y(g){const w=r>>index_es_K;return g>w}function E(g){return y(g)?s(-g):g}const p=(g,w,b)=>Ot(g.slice(w,b));class d{constructor(w,b,I){this.r=w,this.s=b,this.recovery=I,this.assertValidity()}static fromCompact(w){const b=e.nByteLength;return w=et("compactSignature",w,b*2),new d(p(w,0,b),p(w,b,2*b))}static fromDER(w){const{r:b,s:I}=lt.toSig(et("DER",w));return new d(b,I)}assertValidity(){ft("r",this.r,index_es_K,r),ft("s",this.s,index_es_K,r)}addRecoveryBit(w){return new d(this.r,this.s,w)}recoverPublicKey(w){const{r:b,s:I,recovery:R}=this,x=B(et("msgHash",w));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const C=R===2||R===3?b+e.n:b;if(C>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=(R&1)===0?"02":"03",k=a.fromHex(P+h(C)),M=c(C),D=s(-x*M),z=s(I*M),Z=a.BASE.multiplyAndAddUnsafe(k,D,z);if(!Z)throw new Error("point at infinify");return Z.assertValidity(),Z}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return Vt(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Vt(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const v={isValidPrivateKey(g){try{return u(g),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const g=zr(e.n);return uc(e.randomBytes(g),e.n)},precompute(g=8,w=a.BASE){return w._setWindowSize(g),w.multiply(BigInt(3)),w}};function m(g,w=!0){return a.fromPrivateKey(g).toRawBytes(w)}function O(g){const w=St(g),b=typeof g=="string",I=(w||b)&&g.length;return w?I===o||I===i:b?I===2*o||I===2*i:g instanceof a}function N(g,w,b=!0){if(O(g))throw new Error("first arg must be private key");if(!O(w))throw new Error("second arg must be public key");return a.fromHex(w).multiply(u(g)).toRawBytes(b)}const $=e.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const w=Ot(g),b=g.length*8-e.nBitLength;return b>0?w>>BigInt(b):w},B=e.bits2int_modN||function(g){return s($(g))},A=Je(e.nBitLength);function T(g){return ft("num < 2^"+e.nBitLength,g,dt,A),Mt(g,e.nByteLength)}function S(g,w,b=L){if(["recovered","canonical"].some(W=>W in b))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:R}=e;let{lowS:x,prehash:C,extraEntropy:P}=b;x==null&&(x=!0),g=et("msgHash",g),Jr(b),C&&(g=et("prehashed msgHash",I(g)));const k=B(g),M=u(w),D=[T(M),T(k)];if(P!=null&&P!==!1){const W=P===!0?R(n.BYTES):P;D.push(et("extraEntropy",W))}const z=ne(...D),Z=k;function st(W){const J=$(W);if(!f(J))return;const Be=c(J),zt=a.BASE.multiply(J).toAffine(),vt=s(zt.x);if(vt===dt)return;const Zt=s(Be*s(Z+vt*M));if(Zt===dt)return;let Ut=(zt.x===vt?0:2)|Number(zt.y&index_es_K),vn=Zt;return x&&y(Zt)&&(vn=E(Zt),Ut^=1),new d(vt,vn,Ut)}return{seed:z,k2sig:st}}const L={lowS:e.lowS,prehash:!1},U={lowS:e.lowS,prehash:!1};function _(g,w,b=L){const{seed:I,k2sig:R}=S(g,w,b),x=e;return Vr(x.hash.outputLen,x.nByteLength,x.hmac)(I,R)}a.BASE._setWindowSize(8);function j(g,w,b,I=U){const R=g;w=et("msgHash",w),b=et("publicKey",b);const{lowS:x,prehash:C,format:P}=I;if(Jr(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(P!==void 0&&P!=="compact"&&P!=="der")throw new Error("format must be compact or der");const k=typeof R=="string"||St(R),M=!k&&!P&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!k&&!M)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let D,z;try{if(M&&(D=new d(R.r,R.s)),k){try{P!=="compact"&&(D=d.fromDER(R))}catch(Ut){if(!(Ut instanceof lt.Err))throw Ut}!D&&P!=="der"&&(D=d.fromCompact(R))}z=a.fromHex(b)}catch{return!1}if(!D||x&&D.hasHighS())return!1;C&&(w=e.hash(w));const{r:Z,s:st}=D,W=B(w),J=c(st),Be=s(W*J),zt=s(Z*J),vt=a.BASE.multiplyAndAddUnsafe(z,Be,zt)?.toAffine();return vt?s(vt.x)===Z:!1}return{CURVE:e,getPublicKey:m,getSharedSecret:N,sign:_,verify:j,ProjectivePoint:a,Signature:d,utils:v}}function Nc(t){return{hash:t,hmac:(e,...n)=>ye(t,e,Vi(...n)),randomBytes:Lt}}function Uc(t,e){const n=r=>Ic({...t,...Nc(r)});return{...n(e),create:n}}const to=Kr(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Tc=to.create(BigInt("-3")),Rc=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),_c=Uc({a:Tc,b:Rc,Fp:to,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Qt),ln="base10",G="base16",qt="base64pad",xe="base64url",Kt="utf8",dn=0,Ft=1,re=2,$c=0,eo=1,oe=12,hn=32;function Lc(){const t=fn.utils.randomPrivateKey(),e=fn.getPublicKey(t);return{privateKey:(0,src/* toString */.dI)(t,G),publicKey:(0,src/* toString */.dI)(e,G)}}function jc(){const t=Lt(hn);return (0,src/* toString */.dI)(t,G)}function Cc(t,e){const n=fn.getSharedSecret((0,src/* fromString */.sH)(t,G),(0,src/* fromString */.sH)(e,G)),r=Vs(Qt,n,void 0,void 0,hn);return (0,src/* toString */.dI)(r,G)}function Pc(t){const e=Qt((0,src/* fromString */.sH)(t,G));return (0,src/* toString */.dI)(e,G)}function kc(t){const e=Qt((0,src/* fromString */.sH)(t,Kt));return (0,src/* toString */.dI)(e,G)}function pn(t){return (0,src/* fromString */.sH)(`${t}`,ln)}function Bt(t){return Number((0,src/* toString */.dI)(t,ln))}function no(t){return t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function ro(t){const e=t.replace(/-/g,"+").replace(/_/g,"/"),n=(4-e.length%4)%4;return e+"=".repeat(n)}function Vc(t){const e=pn(typeof t.type<"u"?t.type:dn);if(Bt(e)===Ft&&typeof t.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const n=typeof t.senderPublicKey<"u"?(0,src/* fromString */.sH)(t.senderPublicKey,G):void 0,r=typeof t.iv<"u"?(0,src/* fromString */.sH)(t.iv,G):Lt(oe),o=(0,src/* fromString */.sH)(t.symKey,G),i=$r(o,r).encrypt((0,src/* fromString */.sH)(t.message,Kt)),s=gn({type:e,sealed:i,iv:r,senderPublicKey:n});return t.encoding===xe?no(s):s}function Mc(t){const e=(0,src/* fromString */.sH)(t.symKey,G),{sealed:n,iv:r}=Se({encoded:t.encoded,encoding:t.encoding}),o=$r(e,r).decrypt(n);if(o===null)throw new Error("Failed to decrypt");return (0,src/* toString */.dI)(o,Kt)}function Dc(t,e){const n=pn(re),r=Lt(oe),o=(0,src/* fromString */.sH)(t,Kt),i=gn({type:n,sealed:o,iv:r});return e===xe?no(i):i}function Hc(t,e){const{sealed:n}=Se({encoded:t,encoding:e});return (0,src/* toString */.dI)(n,Kt)}function gn(t){if(Bt(t.type)===re)return (0,src/* toString */.dI)((0,src/* concat */.xW)([t.type,t.sealed]),qt);if(Bt(t.type)===Ft){if(typeof t.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return (0,src/* toString */.dI)((0,src/* concat */.xW)([t.type,t.senderPublicKey,t.iv,t.sealed]),qt)}return (0,src/* toString */.dI)((0,src/* concat */.xW)([t.type,t.iv,t.sealed]),qt)}function Se(t){const e=(t.encoding||qt)===xe?ro(t.encoded):t.encoded,n=(0,src/* fromString */.sH)(e,qt),r=n.slice($c,eo),o=eo;if(Bt(r)===Ft){const a=o+hn,u=a+oe,l=n.slice(o,a),f=n.slice(a,u),h=n.slice(u);return{type:r,sealed:h,iv:f,senderPublicKey:l}}if(Bt(r)===re){const a=n.slice(o),u=Lt(oe);return{type:r,sealed:a,iv:u}}const i=o+oe,s=n.slice(o,i),c=n.slice(i);return{type:r,sealed:c,iv:s}}function qc(t,e){const n=Se({encoded:t,encoding:e?.encoding});return oo({type:Bt(n.type),senderPublicKey:typeof n.senderPublicKey<"u"?(0,src/* toString */.dI)(n.senderPublicKey,G):void 0,receiverPublicKey:e?.receiverPublicKey})}function oo(t){const e=t?.type||dn;if(e===Ft){if(typeof t?.senderPublicKey>"u")throw new Error("missing sender public key");if(typeof t?.receiverPublicKey>"u")throw new Error("missing receiver public key")}return{type:e,senderPublicKey:t?.senderPublicKey,receiverPublicKey:t?.receiverPublicKey}}function Kc(t){return t.type===Ft&&typeof t.senderPublicKey=="string"&&typeof t.receiverPublicKey=="string"}function Fc(t){return t.type===re}function io(t){const e=Buffer.from(t.x,"base64"),n=Buffer.from(t.y,"base64");return (0,src/* concat */.xW)([new Uint8Array([4]),e,n])}function zc(t,e){const[n,r,o]=t.split("."),i=Buffer.from(ro(o),"base64");if(i.length!==64)throw new Error("Invalid signature length");const s=i.slice(0,32),c=i.slice(32,64),a=`${n}.${r}`,u=Qt(a),l=io(e);if(!_c.verify((0,src/* concat */.xW)([s,c]),u,l))throw new Error("Invalid signature");return (0,relay_auth_dist_index_es/* decodeJWT */.Cq)(t).payload}const so="irn";function Zc(t){return t?.relay||{protocol:so}}function Yc(t){const e=relay_api_dist_index_es/* RELAY_JSONRPC */.CG[t];if(typeof e>"u")throw new Error(`Relay Protocol not supported: ${t}`);return e}function co(t,e="-"){const n={},r="relay"+e;return Object.keys(t).forEach(o=>{if(o.startsWith(r)){const i=o.replace(r,""),s=t[o];n[i]=s}}),n}function Gc(t){if(!t.includes("wc:")){const u=je(t);u!=null&&u.includes("wc:")&&(t=u)}t=t.includes("wc://")?t.replace("wc://",""):t,t=t.includes("wc:")?t.replace("wc:",""):t;const e=t.indexOf(":"),n=t.indexOf("?")!==-1?t.indexOf("?"):void 0,r=t.substring(0,e),o=t.substring(e+1,n).split("@"),i=typeof n<"u"?t.substring(n):"",s=new URLSearchParams(i),c={};s.forEach((u,l)=>{c[l]=u});const a=typeof c.methods=="string"?c.methods.split(","):void 0;return{protocol:r,topic:ao(o[0]),version:parseInt(o[1],10),symKey:c.symKey,relay:co(c),methods:a,expiryTimestamp:c.expiryTimestamp?parseInt(c.expiryTimestamp,10):void 0}}function ao(t){return t.startsWith("//")?t.substring(2):t}function uo(t,e="-"){const n="relay",r={};return Object.keys(t).forEach(o=>{const i=o,s=n+e+i;t[i]&&(r[s]=t[i])}),r}function Wc(t){const e=new URLSearchParams,n=uo(t.relay);Object.keys(n).sort().forEach(o=>{e.set(o,n[o])}),e.set("symKey",t.symKey),t.expiryTimestamp&&e.set("expiryTimestamp",t.expiryTimestamp.toString()),t.methods&&e.set("methods",t.methods.join(","));const r=e.toString();return`${t.protocol}:${t.topic}@${t.version}?${r}`}function Xc(t,e,n){return`${t}?wc_ev=${n}&topic=${e}`}var Jc=Object.defineProperty,Qc=Object.defineProperties,ta=Object.getOwnPropertyDescriptors,fo=Object.getOwnPropertySymbols,ea=Object.prototype.hasOwnProperty,na=Object.prototype.propertyIsEnumerable,lo=(t,e,n)=>e in t?Jc(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,ra=(t,e)=>{for(var n in e||(e={}))ea.call(e,n)&&lo(t,n,e[n]);if(fo)for(var n of fo(e))na.call(e,n)&&lo(t,n,e[n]);return t},oa=(t,e)=>Qc(t,ta(e));function It(t){const e=[];return t.forEach(n=>{const[r,o]=n.split(":");e.push(`${r}:${o}`)}),e}function ho(t){const e=[];return Object.values(t).forEach(n=>{e.push(...It(n.accounts))}),e}function po(t,e){const n=[];return Object.values(t).forEach(r=>{It(r.accounts).includes(e)&&n.push(...r.methods)}),n}function go(t,e){const n=[];return Object.values(t).forEach(r=>{It(r.accounts).includes(e)&&n.push(...r.events)}),n}function ia(t,e){const n=Bo(t,e);if(n)throw new Error(n.message);const r={};for(const[o,i]of Object.entries(t))r[o]={methods:i.methods,events:i.events,chains:i.accounts.map(s=>`${s.split(":")[0]}:${s.split(":")[1]}`)};return r}function sa(t){const{proposal:{requiredNamespaces:e,optionalNamespaces:n={}},supportedNamespaces:r}=t,o=index_es_ie(e),i=index_es_ie(n),s={};Object.keys(r).forEach(u=>{const l=r[u].chains,f=r[u].methods,h=r[u].events,y=r[u].accounts;l.forEach(E=>{if(!y.some(p=>p.includes(E)))throw new Error(`No accounts provided for chain ${E} in namespace ${u}`)}),s[u]={chains:l,methods:f,events:h,accounts:y}});const c=No(e,s,"approve()");if(c)throw new Error(c.message);const a={};return!Object.keys(e).length&&!Object.keys(n).length?s:(Object.keys(o).forEach(u=>{const l=r[u].chains.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.chains)==null?void 0:d.includes(E)}),f=r[u].methods.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.methods)==null?void 0:d.includes(E)}),h=r[u].events.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.events)==null?void 0:d.includes(E)}),y=l.map(E=>r[u].accounts.filter(p=>p.includes(`${E}:`))).flat();a[u]={chains:l,methods:f,events:h,accounts:y}}),Object.keys(i).forEach(u=>{var l,f,h,y,E,p;if(!r[u])return;const d=(f=(l=i[u])==null?void 0:l.chains)==null?void 0:f.filter(N=>r[u].chains.includes(N)),v=r[u].methods.filter(N=>{var $,B;return(B=($=i[u])==null?void 0:$.methods)==null?void 0:B.includes(N)}),m=r[u].events.filter(N=>{var $,B;return(B=($=i[u])==null?void 0:$.events)==null?void 0:B.includes(N)}),O=d?.map(N=>r[u].accounts.filter($=>$.includes(`${N}:`))).flat();a[u]={chains:ot((h=a[u])==null?void 0:h.chains,d),methods:ot((y=a[u])==null?void 0:y.methods,v),events:ot((E=a[u])==null?void 0:E.events,m),accounts:ot((p=a[u])==null?void 0:p.accounts,O)}}),a)}function yn(t){return t.includes(":")}function yo(t){return yn(t)?t.split(":")[0]:t}function index_es_ie(t){var e,n,r;const o={};if(!Oe(t))return o;for(const[i,s]of Object.entries(t)){const c=yn(i)?[i]:s.chains,a=s.methods||[],u=s.events||[],l=yo(i);o[l]=oa(ra({},o[l]),{chains:ot(c,(e=o[l])==null?void 0:e.chains),methods:ot(a,(n=o[l])==null?void 0:n.methods),events:ot(u,(r=o[l])==null?void 0:r.events)})}return o}function mo(t){const e={};return t?.forEach(n=>{var r;const[o,i]=n.split(":");e[o]||(e[o]={accounts:[],chains:[],events:[],methods:[]}),e[o].accounts.push(n),(r=e[o].chains)==null||r.push(`${o}:${i}`)}),e}function ca(t,e){e=e.map(r=>r.replace("did:pkh:",""));const n=mo(e);for(const[r,o]of Object.entries(n))o.methods?o.methods=ot(o.methods,t):o.methods=t,o.events=["chainChanged","accountsChanged"];return n}function aa(t,e){var n,r,o,i,s,c;const a=index_es_ie(t),u=index_es_ie(e),l={},f=Object.keys(a).concat(Object.keys(u));for(const h of f)l[h]={chains:ot((n=a[h])==null?void 0:n.chains,(r=u[h])==null?void 0:r.chains),methods:ot((o=a[h])==null?void 0:o.methods,(i=u[h])==null?void 0:i.methods),events:ot((s=a[h])==null?void 0:s.events,(c=u[h])==null?void 0:c.events)};return l}const wo={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},bo={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function ht(t,e){const{message:n,code:r}=bo[t];return{message:e?`${n} ${e}`:n,code:r}}function Nt(t,e){const{message:n,code:r}=wo[t];return{message:e?`${n} ${e}`:n,code:r}}function se(t,e){return Array.isArray(t)?typeof e<"u"&&t.length?t.every(e):!0:!1}function Oe(t){return Object.getPrototypeOf(t)===Object.prototype&&Object.keys(t).length}function Et(t){return typeof t>"u"}function nt(t,e){return e&&Et(t)?!0:typeof t=="string"&&!!t.trim().length}function Ae(t,e){return e&&Et(t)?!0:typeof t=="number"&&!isNaN(t)}function ua(t,e){const{requiredNamespaces:n}=e,r=Object.keys(t.namespaces),o=Object.keys(n);let i=!0;return gt(o,r)?(r.forEach(s=>{const{accounts:c,methods:a,events:u}=t.namespaces[s],l=It(c),f=n[s];(!gt(ue(s,f),l)||!gt(f.methods,a)||!gt(f.events,u))&&(i=!1)}),i):!1}function ce(t){return nt(t,!1)&&t.includes(":")?t.split(":").length===2:!1}function Eo(t){if(nt(t,!1)&&t.includes(":")){const e=t.split(":");if(e.length===3){const n=e[0]+":"+e[1];return!!e[2]&&ce(n)}}return!1}function fa(t){function e(n){try{return typeof new URL(n)<"u"}catch{return!1}}try{if(nt(t,!1)){if(e(t))return!0;const n=je(t);return e(n)}}catch{}return!1}function la(t){var e;return(e=t?.proposer)==null?void 0:e.publicKey}function da(t){return t?.topic}function ha(t,e){let n=null;return nt(t?.publicKey,!1)||(n=ht("MISSING_OR_INVALID",`${e} controller public key should be a string`)),n}function mn(t){let e=!0;return se(t)?t.length&&(e=t.every(n=>nt(n,!1))):e=!1,e}function vo(t,e,n){let r=null;return se(e)&&e.length?e.forEach(o=>{r||ce(o)||(r=Nt("UNSUPPORTED_CHAINS",`${n}, chain ${o} should be a string and conform to "namespace:chainId" format`))}):ce(t)||(r=Nt("UNSUPPORTED_CHAINS",`${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),r}function xo(t,e,n){let r=null;return Object.entries(t).forEach(([o,i])=>{if(r)return;const s=vo(o,ue(o,i),`${e} ${n}`);s&&(r=s)}),r}function So(t,e){let n=null;return se(t)?t.forEach(r=>{n||Eo(r)||(n=Nt("UNSUPPORTED_ACCOUNTS",`${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`))}):n=Nt("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),n}function Oo(t,e){let n=null;return Object.values(t).forEach(r=>{if(n)return;const o=So(r?.accounts,`${e} namespace`);o&&(n=o)}),n}function Ao(t,e){let n=null;return mn(t?.methods)?mn(t?.events)||(n=Nt("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):n=Nt("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),n}function wn(t,e){let n=null;return Object.values(t).forEach(r=>{if(n)return;const o=Ao(r,`${e}, namespace`);o&&(n=o)}),n}function pa(t,e,n){let r=null;if(t&&Oe(t)){const o=wn(t,e);o&&(r=o);const i=xo(t,e,n);i&&(r=i)}else r=ht("MISSING_OR_INVALID",`${e}, ${n} should be an object with data`);return r}function Bo(t,e){let n=null;if(t&&Oe(t)){const r=wn(t,e);r&&(n=r);const o=Oo(t,e);o&&(n=o)}else n=ht("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return n}function Io(t){return nt(t.protocol,!0)}function ga(t,e){let n=!1;return e&&!t?n=!0:t&&se(t)&&t.length&&t.forEach(r=>{n=Io(r)}),n}function ya(t){return typeof t=="number"}function ma(t){return typeof t<"u"&&typeof t!==null}function wa(t){return!(!t||typeof t!="object"||!t.code||!Ae(t.code,!1)||!t.message||!nt(t.message,!1))}function ba(t){return!(Et(t)||!nt(t.method,!1))}function Ea(t){return!(Et(t)||Et(t.result)&&Et(t.error)||!Ae(t.id,!1)||!nt(t.jsonrpc,!1))}function va(t){return!(Et(t)||!nt(t.name,!1))}function xa(t,e){return!(!ce(e)||!ho(t).includes(e))}function Sa(t,e,n){return nt(n,!1)?po(t,e).includes(n):!1}function Oa(t,e,n){return nt(n,!1)?go(t,e).includes(n):!1}function No(t,e,n){let r=null;const o=Aa(t),i=Ba(e),s=Object.keys(o),c=Object.keys(i),a=Uo(Object.keys(t)),u=Uo(Object.keys(e)),l=a.filter(f=>!u.includes(f));return l.length&&(r=ht("NON_CONFORMING_NAMESPACES",`${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)),gt(s,c)||(r=ht("NON_CONFORMING_NAMESPACES",`${n} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${c.toString()}`)),Object.keys(e).forEach(f=>{if(!f.includes(":")||r)return;const h=It(e[f].accounts);h.includes(f)||(r=ht("NON_CONFORMING_NAMESPACES",`${n} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${h.toString()}`))}),s.forEach(f=>{r||(gt(o[f].methods,i[f].methods)?gt(o[f].events,i[f].events)||(r=ht("NON_CONFORMING_NAMESPACES",`${n} namespaces events don't satisfy namespace events for ${f}`)):r=ht("NON_CONFORMING_NAMESPACES",`${n} namespaces methods don't satisfy namespace methods for ${f}`))}),r}function Aa(t){const e={};return Object.keys(t).forEach(n=>{var r;n.includes(":")?e[n]=t[n]:(r=t[n].chains)==null||r.forEach(o=>{e[o]={methods:t[n].methods,events:t[n].events}})}),e}function Uo(t){return[...new Set(t.map(e=>e.includes(":")?e.split(":")[0]:e))]}function Ba(t){const e={};return Object.keys(t).forEach(n=>{if(n.includes(":"))e[n]=t[n];else{const r=It(t[n].accounts);r?.forEach(o=>{e[o]={accounts:t[n].accounts.filter(i=>i.includes(`${o}:`)),methods:t[n].methods,events:t[n].events}})}}),e}function Ia(t,e){return Ae(t,!1)&&t<=e.max&&t>=e.min}function Na(){const t=xt();return new Promise(e=>{switch(t){case Y.browser:e(To());break;case Y.reactNative:e(Ro());break;case Y.node:e(_o());break;default:e(!0)}})}function To(){return Tt()&&navigator?.onLine}async function Ro(){if(pt()&&typeof global<"u"&&global!=null&&global.NetInfo){const t=await(global==null?void 0:global.NetInfo.fetch());return t?.isConnected}return!0}function _o(){return!0}function Ua(t){switch(xt()){case Y.browser:$o(t);break;case Y.reactNative:Lo(t);break;case Y.node:break}}function $o(t){!pt()&&Tt()&&(window.addEventListener("online",()=>t(!0)),window.addEventListener("offline",()=>t(!1)))}function Lo(t){pt()&&typeof global<"u"&&global!=null&&global.NetInfo&&global?.NetInfo.addEventListener(e=>t(e?.isConnected))}function Ta(){var t;return Tt()&&(0,dist_cjs.getDocument)()?((t=(0,dist_cjs.getDocument)())==null?void 0:t.visibilityState)==="visible":!0}const bn={};class Ra{static get(e){return bn[e]}static set(e,n){bn[e]=n}static delete(e){delete bn[e]}}
//# sourceMappingURL=index.es.js.map

// EXTERNAL MODULE: ./node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var jsonrpc_provider_dist_index_es = __webpack_require__(827907);
// EXTERNAL MODULE: ./node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var dist_esm = __webpack_require__(739031);
// EXTERNAL MODULE: ./node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var jsonrpc_ws_connection_dist_index_es = __webpack_require__(384365);
;// ./node_modules/@walletconnect/core/dist/index.es.js
const index_es_ze="wc",index_es_Le=2,index_es_he="core",B=`${index_es_ze}@2:${index_es_he}:`,index_es_Et={name:index_es_he,logger:"error"},index_es_It={database:":memory:"},index_es_Tt="crypto",index_es_ke="client_ed25519_seed",index_es_Ct=cjs.ONE_DAY,index_es_Pt="keychain",index_es_St="0.3",index_es_Ot="messages",index_es_Rt="0.3",index_es_je=cjs.SIX_HOURS,index_es_At="publisher",index_es_xt="irn",index_es_Nt="error",index_es_Ue="wss://relay.walletconnect.org",index_es_$t="relayer",index_es_C={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},zt="_subscription",L={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},index_es_Lt=.1,index_es_Gs={database:":memory:"},index_es_e="2.21.0",index_es_Ws=1e4,index_es_Q={link_mode:"link_mode",relay:"relay"},index_es_le={inbound:"inbound",outbound:"outbound"},dist_index_es_kt="0.3",index_es_jt="WALLETCONNECT_CLIENT_ID",index_es_Fe="WALLETCONNECT_LINK_MODE_APPS",index_es_$={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},index_es_Hs=(/* unused pure expression or super */ null && (Ce)),Ut="subscription",index_es_Ft="0.3",index_es_Ys=cjs.FIVE_SECONDS*1e3,index_es_Mt="pairing",index_es_Kt="0.3",index_es_Js=(/* unused pure expression or super */ null && (Ce)),index_es_se={wc_pairingDelete:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:cjs.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:cjs.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:0},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:0}}},index_es_re={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},index_es_F={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},index_es_Bt="history",index_es_Vt="0.3",index_es_qt="expirer",index_es_M={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},index_es_Gt="0.3",index_es_Xs=(/* unused pure expression or super */ null && (ie)),index_es_Wt="verify-api",index_es_Zs="https://verify.walletconnect.com",index_es_Ht="https://verify.walletconnect.org",index_es_ue=index_es_Ht,index_es_Yt=`${index_es_ue}/v3`,index_es_Jt=[index_es_Zs,index_es_Ht],index_es_Xt="echo",Zt="https://echo.walletconnect.com",index_es_Qs="event-client",index_es_G={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},index_es_Y={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},index_es_er={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},index_es_tr={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},index_es_ir={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},index_es_sr={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},index_es_Qt=.1,index_es_ei="event-client",index_es_ti=86400,index_es_ii="https://pulse.walletconnect.org/batch";function index_es_rr(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),o=n.charCodeAt(0);if(t[o]!==255)throw new TypeError(n+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),h=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function d(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var b=0,x=0,I=0,D=u.length;I!==D&&u[I]===0;)I++,b++;for(var j=(D-I)*l+1>>>0,T=new Uint8Array(j);I!==D;){for(var q=u[I],J=0,K=j-1;(q!==0||J<x)&&K!==-1;K--,J++)q+=256*T[K]>>>0,T[K]=q%a>>>0,q=q/a>>>0;if(q!==0)throw new Error("Non-zero carry");x=J,I++}for(var H=j-x;H!==j&&T[H]===0;)H++;for(var me=c.repeat(b);H<j;++H)me+=r.charAt(T[H]);return me}function g(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var b=0;if(u[b]!==" "){for(var x=0,I=0;u[b]===c;)x++,b++;for(var D=(u.length-b)*h+1>>>0,j=new Uint8Array(D);u[b];){var T=t[u.charCodeAt(b)];if(T===255)return;for(var q=0,J=D-1;(T!==0||q<I)&&J!==-1;J--,q++)T+=a*j[J]>>>0,j[J]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");I=q,b++}if(u[b]!==" "){for(var K=D-I;K!==D&&j[K]===0;)K++;for(var H=new Uint8Array(x+(D-K)),me=x;K!==D;)H[me++]=j[K++];return H}}}function _(u){var b=g(u);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:g,decode:_}}var index_es_nr=index_es_rr,index_es_or=index_es_nr;const index_es_si=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},index_es_ar=r=>new TextEncoder().encode(r),index_es_cr=r=>new TextDecoder().decode(r);class index_es_hr{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class index_es_lr{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return index_es_ri(this,e)}}class index_es_ur{constructor(e){this.decoders=e}or(e){return index_es_ri(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const index_es_ri=(r,e)=>new index_es_ur({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class index_es_dr{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new index_es_hr(e,t,i),this.decoder=new index_es_lr(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const index_es_Ee=({name:r,prefix:e,encode:t,decode:i})=>new index_es_dr(r,e,t,i),index_es_de=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=index_es_or(t,e);return index_es_Ee({prefix:r,name:e,encode:i,decode:n=>index_es_si(s(n))})},index_es_gr=(r,e,t,i)=>{const s={};for(let l=0;l<e.length;++l)s[e[l]]=l;let n=r.length;for(;r[n-1]==="=";)--n;const o=new Uint8Array(n*t/8|0);let a=0,c=0,h=0;for(let l=0;l<n;++l){const d=s[r[l]];if(d===void 0)throw new SyntaxError(`Non-${i} character`);c=c<<t|d,a+=t,a>=8&&(a-=8,o[h++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o},index_es_pr=(r,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let n="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,n+=e[s&a>>o];if(o&&(n+=e[s&a<<t-o]),i)for(;n.length*t&7;)n+="=";return n},index_es_P=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>index_es_Ee({prefix:e,name:r,encode(s){return index_es_pr(s,i,t)},decode(s){return index_es_gr(s,i,t,r)}}),index_es_yr=index_es_Ee({prefix:"\0",name:"identity",encode:r=>index_es_cr(r),decode:r=>index_es_ar(r)});var index_es_br=Object.freeze({__proto__:null,identity:index_es_yr});const index_es_mr=index_es_P({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var index_es_fr=Object.freeze({__proto__:null,base2:index_es_mr});const index_es_Dr=index_es_P({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var index_es_vr=Object.freeze({__proto__:null,base8:index_es_Dr});const index_es_wr=index_es_de({prefix:"9",name:"base10",alphabet:"0123456789"});var index_es_r=Object.freeze({__proto__:null,base10:index_es_wr});const index_es_Er=index_es_P({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),index_es_Ir=index_es_P({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var index_es_Tr=Object.freeze({__proto__:null,base16:index_es_Er,base16upper:index_es_Ir});const index_es_Cr=index_es_P({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),index_es_Pr=index_es_P({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),index_es_Sr=index_es_P({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),index_es_Or=index_es_P({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),index_es_Rr=index_es_P({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),index_es_Ar=index_es_P({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),index_es_xr=index_es_P({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),index_es_Nr=index_es_P({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),index_es_$r=index_es_P({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var index_es_zr=Object.freeze({__proto__:null,base32:index_es_Cr,base32upper:index_es_Pr,base32pad:index_es_Sr,base32padupper:index_es_Or,base32hex:index_es_Rr,base32hexupper:index_es_Ar,base32hexpad:index_es_xr,base32hexpadupper:index_es_Nr,base32z:index_es_$r});const index_es_Lr=index_es_de({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),index_es_kr=index_es_de({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var index_es_jr=Object.freeze({__proto__:null,base36:index_es_Lr,base36upper:index_es_kr});const index_es_Ur=index_es_de({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),index_es_Fr=index_es_de({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var index_es_Mr=Object.freeze({__proto__:null,base58btc:index_es_Ur,base58flickr:index_es_Fr});const index_es_Kr=index_es_P({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),index_es_Br=index_es_P({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),index_es_Vr=index_es_P({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),index_es_qr=index_es_P({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var index_es_Gr=Object.freeze({__proto__:null,base64:index_es_Kr,base64pad:index_es_Br,base64url:index_es_Vr,base64urlpad:index_es_qr});const index_es_ni=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),index_es_Wr=index_es_ni.reduce((r,e,t)=>(r[t]=e,r),[]),index_es_Hr=index_es_ni.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function index_es_Yr(r){return r.reduce((e,t)=>(e+=index_es_Wr[t],e),"")}function index_es_Jr(r){const e=[];for(const t of r){const i=index_es_Hr[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const index_es_Xr=index_es_Ee({prefix:"\u{1F680}",name:"base256emoji",encode:index_es_Yr,decode:index_es_Jr});var index_es_Zr=Object.freeze({__proto__:null,base256emoji:index_es_Xr}),index_es_Qr=index_es_ai,index_es_oi=128,index_es_en=127,index_es_tn=~index_es_en,index_es_sn=Math.pow(2,31);function index_es_ai(r,e,t){e=e||[],t=t||0;for(var i=t;r>=index_es_sn;)e[t++]=r&255|index_es_oi,r/=128;for(;r&index_es_tn;)e[t++]=r&255|index_es_oi,r>>>=7;return e[t]=r|0,index_es_ai.bytes=t-i+1,e}var index_es_rn=index_es_Me,index_es_nn=128,index_es_ci=127;function index_es_Me(r,i){var t=0,i=i||0,s=0,n=i,o,a=r.length;do{if(n>=a)throw index_es_Me.bytes=0,new RangeError("Could not decode varint");o=r[n++],t+=s<28?(o&index_es_ci)<<s:(o&index_es_ci)*Math.pow(2,s),s+=7}while(o>=index_es_nn);return index_es_Me.bytes=n-i,t}var index_es_on=Math.pow(2,7),index_es_an=Math.pow(2,14),index_es_cn=Math.pow(2,21),index_es_hn=Math.pow(2,28),index_es_ln=Math.pow(2,35),index_es_un=Math.pow(2,42),index_es_dn=Math.pow(2,49),index_es_gn=Math.pow(2,56),index_es_pn=Math.pow(2,63),index_es_yn=function(r){return r<index_es_on?1:r<index_es_an?2:r<index_es_cn?3:r<index_es_hn?4:r<index_es_ln?5:r<index_es_un?6:r<index_es_dn?7:r<index_es_gn?8:r<index_es_pn?9:10},index_es_bn={encode:index_es_Qr,decode:index_es_rn,encodingLength:index_es_yn},index_es_hi=index_es_bn;const index_es_li=(r,e,t=0)=>(index_es_hi.encode(r,e,t),e),index_es_ui=r=>index_es_hi.encodingLength(r),index_es_Ke=(r,e)=>{const t=e.byteLength,i=index_es_ui(r),s=i+index_es_ui(t),n=new Uint8Array(s+t);return index_es_li(r,n,0),index_es_li(t,n,i),n.set(e,s),new index_es_mn(r,t,e,n)};class index_es_mn{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const index_es_di=({name:r,code:e,encode:t})=>new index_es_fn(r,e,t);class index_es_fn{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?index_es_Ke(this.code,t):t.then(i=>index_es_Ke(this.code,i))}else throw Error("Unknown type, must be binary type")}}const index_es_gi=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),index_es_Dn=index_es_di({name:"sha2-256",code:18,encode:index_es_gi("SHA-256")}),vn=index_es_di({name:"sha2-512",code:19,encode:index_es_gi("SHA-512")});var index_es_wn=Object.freeze({__proto__:null,sha256:index_es_Dn,sha512:vn});const index_es_pi=0,index_es_n="identity",index_es_yi=index_es_si,index_es_En=r=>index_es_Ke(index_es_pi,index_es_yi(r)),index_es_In={code:index_es_pi,name:index_es_n,encode:index_es_yi,digest:index_es_En};var index_es_Tn=Object.freeze({__proto__:null,identity:index_es_In});new TextEncoder,new TextDecoder;const index_es_bi={...index_es_br,...index_es_fr,...index_es_vr,...index_es_r,...index_es_Tr,...index_es_zr,...index_es_jr,...index_es_Mr,...index_es_Gr,...index_es_Zr};({...index_es_wn,...index_es_Tn});function index_es_Cn(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(r):new Uint8Array(r)}function index_es_mi(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const index_es_fi=index_es_mi("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Be=index_es_mi("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=index_es_Cn(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),index_es_Pn={utf8:index_es_fi,"utf-8":index_es_fi,hex:index_es_bi.base16,latin1:Be,ascii:Be,binary:Be,...index_es_bi};function Sn(r,e="utf8"){const t=index_es_Pn[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(r,"utf8"):t.decoder.decode(`${t.prefix}${r}`)}var index_es_On=Object.defineProperty,index_es_Rn=(r,e,t)=>e in r?index_es_On(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,W=(r,e,t)=>index_es_Rn(r,typeof e!="symbol"?e+"":e,t);class index_es_Di{constructor(e,t){this.core=e,this.logger=t,W(this,"keychain",new Map),W(this,"name",index_es_Pt),W(this,"version",index_es_St),W(this,"initialized",!1),W(this,"storagePrefix",B),W(this,"init",async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}}),W(this,"has",i=>(this.isInitialized(),this.keychain.has(i))),W(this,"set",async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()}),W(this,"get",i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:n}=ht("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(n)}return s}),W(this,"del",async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()}),this.core=e,this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name)}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,fi(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?li(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_An=Object.defineProperty,xn=(r,e,t)=>e in r?index_es_An(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_S=(r,e,t)=>xn(r,typeof e!="symbol"?e+"":e,t);class index_es_vi{constructor(e,t,i){this.core=e,this.logger=t,index_es_S(this,"name",index_es_Tt),index_es_S(this,"keychain"),index_es_S(this,"randomSessionIdentifier",jc()),index_es_S(this,"initialized",!1),index_es_S(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),index_es_S(this,"hasKeys",s=>(this.isInitialized(),this.keychain.has(s))),index_es_S(this,"getClientId",async()=>{this.isInitialized();const s=await this.getClientSeed(),n=relay_auth_dist_index_es/* generateKeyPair */.TZ(s);return relay_auth_dist_index_es/* encodeIss */.UF(n.publicKey)}),index_es_S(this,"generateKeyPair",()=>{this.isInitialized();const s=Lc();return this.setPrivateKey(s.publicKey,s.privateKey)}),index_es_S(this,"signJWT",async s=>{this.isInitialized();const n=await this.getClientSeed(),o=relay_auth_dist_index_es/* generateKeyPair */.TZ(n),a=this.randomSessionIdentifier,c=index_es_Ct;return await relay_auth_dist_index_es/* signJWT */.FA(a,s,c,o)}),index_es_S(this,"generateSharedKey",(s,n,o)=>{this.isInitialized();const a=this.getPrivateKey(s),c=Cc(a,n);return this.setSymKey(c,o)}),index_es_S(this,"setSymKey",async(s,n)=>{this.isInitialized();const o=n||Pc(s);return await this.keychain.set(o,s),o}),index_es_S(this,"deleteKeyPair",async s=>{this.isInitialized(),await this.keychain.del(s)}),index_es_S(this,"deleteSymKey",async s=>{this.isInitialized(),await this.keychain.del(s)}),index_es_S(this,"encode",async(s,n,o)=>{this.isInitialized();const a=oo(o),c=(0,esm/* safeJsonStringify */.h)(n);if(Fc(a))return Dc(c,o?.encoding);if(Kc(a)){const g=a.senderPublicKey,_=a.receiverPublicKey;s=await this.generateSharedKey(g,_)}const h=this.getSymKey(s),{type:l,senderPublicKey:d}=a;return Vc({type:l,symKey:h,message:c,senderPublicKey:d,encoding:o?.encoding})}),index_es_S(this,"decode",async(s,n,o)=>{this.isInitialized();const a=qc(n,o);if(Fc(a)){const c=Hc(n,o?.encoding);return (0,esm/* safeJsonParse */.j)(c)}if(Kc(a)){const c=a.receiverPublicKey,h=a.senderPublicKey;s=await this.generateSharedKey(c,h)}try{const c=this.getSymKey(s),h=Mc({symKey:c,encoded:n,encoding:o?.encoding});return (0,esm/* safeJsonParse */.j)(h)}catch(c){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(c)}}),index_es_S(this,"getPayloadType",(s,n=qt)=>{const o=Se({encoded:s,encoding:n});return Bt(o.type)}),index_es_S(this,"getPayloadSenderPublicKey",(s,n=qt)=>{const o=Se({encoded:s,encoding:n});return o.senderPublicKey?(0,src/* toString */.dI)(o.senderPublicKey,G):void 0}),this.core=e,this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.keychain=i||new index_es_Di(this.core,this.logger)}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(index_es_ke)}catch{e=jc(),await this.keychain.set(index_es_ke,e)}return Sn(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_Nn=Object.defineProperty,index_es_$n=Object.defineProperties,index_es_zn=Object.getOwnPropertyDescriptors,index_es_wi=Object.getOwnPropertySymbols,index_es_Ln=Object.prototype.hasOwnProperty,index_es_kn=Object.prototype.propertyIsEnumerable,index_es_Ve=(r,e,t)=>e in r?index_es_Nn(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_jn=(r,e)=>{for(var t in e||(e={}))index_es_Ln.call(e,t)&&index_es_Ve(r,t,e[t]);if(index_es_wi)for(var t of index_es_wi(e))index_es_kn.call(e,t)&&index_es_Ve(r,t,e[t]);return r},index_es_Un=(r,e)=>index_es_$n(r,index_es_zn(e)),index_es_k=(r,e,t)=>index_es_Ve(r,typeof e!="symbol"?e+"":e,t);class index_es_i extends y{constructor(e,t){super(e,t),this.logger=e,this.core=t,index_es_k(this,"messages",new Map),index_es_k(this,"messagesWithoutClientAck",new Map),index_es_k(this,"name",index_es_Ot),index_es_k(this,"version",index_es_Rt),index_es_k(this,"initialized",!1),index_es_k(this,"storagePrefix",B),index_es_k(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i);const s=await this.getRelayerMessagesWithoutClientAck();typeof s<"u"&&(this.messagesWithoutClientAck=s),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}}),index_es_k(this,"set",async(i,s,n)=>{this.isInitialized();const o=kc(s);let a=this.messages.get(i);if(typeof a>"u"&&(a={}),typeof a[o]<"u")return o;if(a[o]=s,this.messages.set(i,a),n===index_es_le.inbound){const c=this.messagesWithoutClientAck.get(i)||{};this.messagesWithoutClientAck.set(i,index_es_Un(index_es_jn({},c),{[o]:s}))}return await this.persist(),o}),index_es_k(this,"get",i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s}),index_es_k(this,"getWithoutAck",i=>{this.isInitialized();const s={};for(const n of i){const o=this.messagesWithoutClientAck.get(n)||{};s[n]=Object.values(o)}return s}),index_es_k(this,"has",(i,s)=>{this.isInitialized();const n=this.get(i),o=kc(s);return typeof n[o]<"u"}),index_es_k(this,"ack",async(i,s)=>{this.isInitialized();const n=this.messagesWithoutClientAck.get(i);if(typeof n>"u")return;const o=kc(s);delete n[o],Object.keys(n).length===0?this.messagesWithoutClientAck.delete(i):this.messagesWithoutClientAck.set(i,n),await this.persist()}),index_es_k(this,"del",async i=>{this.isInitialized(),this.messages.delete(i),this.messagesWithoutClientAck.delete(i),await this.persist()}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(e,this.name),this.core=t}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,fi(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,fi(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?li(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?li(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_Fn=Object.defineProperty,index_es_Mn=Object.defineProperties,index_es_Kn=Object.getOwnPropertyDescriptors,index_es_Ei=Object.getOwnPropertySymbols,index_es_Bn=Object.prototype.hasOwnProperty,index_es_Vn=Object.prototype.propertyIsEnumerable,index_es_qe=(r,e,t)=>e in r?index_es_Fn(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ie=(r,e)=>{for(var t in e||(e={}))index_es_Bn.call(e,t)&&index_es_qe(r,t,e[t]);if(index_es_Ei)for(var t of index_es_Ei(e))index_es_Vn.call(e,t)&&index_es_qe(r,t,e[t]);return r},index_es_Ge=(r,e)=>index_es_Mn(r,index_es_Kn(e)),dist_index_es_V=(r,e,t)=>index_es_qe(r,typeof e!="symbol"?e+"":e,t);class index_es_qn extends m{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,dist_index_es_V(this,"events",new external_events_.EventEmitter),dist_index_es_V(this,"name",index_es_At),dist_index_es_V(this,"queue",new Map),dist_index_es_V(this,"publishTimeout",(0,cjs.toMiliseconds)(cjs.ONE_MINUTE)),dist_index_es_V(this,"initialPublishTimeout",(0,cjs.toMiliseconds)(cjs.ONE_SECOND*15)),dist_index_es_V(this,"needsTransportRestart",!1),dist_index_es_V(this,"publish",async(i,s,n)=>{var o;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}});const a=n?.ttl||index_es_je,c=Zc(n),h=n?.prompt||!1,l=n?.tag||0,d=n?.id||(0,dist_esm.getBigIntRpcId)().toString(),g={topic:i,message:s,opts:{ttl:a,relay:c,prompt:h,tag:l,id:d,attestation:n?.attestation,tvf:n?.tvf}},_=`Failed to publish payload, please try again. id:${d} tag:${l}`;try{const u=new Promise(async b=>{const x=({id:D})=>{g.opts.id===D&&(this.removeRequestFromQueue(D),this.relayer.events.removeListener(index_es_C.publish,x),b(g))};this.relayer.events.on(index_es_C.publish,x);const I=yi(new Promise((D,j)=>{this.rpcPublish({topic:i,message:s,ttl:a,prompt:h,tag:l,id:d,attestation:n?.attestation,tvf:n?.tvf}).then(D).catch(T=>{this.logger.warn(T,T?.message),j(T)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${d} tag:${l}`);try{await I,this.events.removeListener(index_es_C.publish,x)}catch(D){this.queue.set(d,index_es_Ge(Ie({},g),{attempt:1})),this.logger.warn(D,D?.message)}});this.logger.trace({type:"method",method:"publish",params:{id:d,topic:i,message:s,opts:n}}),await yi(u,this.publishTimeout,_)}catch(u){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(u),(o=n?.internal)!=null&&o.throwOnFailedPublish)throw u}finally{this.queue.delete(d)}}),dist_index_es_V(this,"on",(i,s)=>{this.events.on(i,s)}),dist_index_es_V(this,"once",(i,s)=>{this.events.once(i,s)}),dist_index_es_V(this,"off",(i,s)=>{this.events.off(i,s)}),dist_index_es_V(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.relayer=e,this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.registerEventListeners()}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}async rpcPublish(e){var t,i,s,n;const{topic:o,message:a,ttl:c=index_es_je,prompt:h,tag:l,id:d,attestation:g,tvf:_}=e,u={method:Yc(Zc().protocol).publish,params:Ie({topic:o,message:a,ttl:c,prompt:h,tag:l,attestation:g},_),id:d};Et((t=u.params)==null?void 0:t.prompt)&&((i=u.params)==null||delete i.prompt),Et((s=u.params)==null?void 0:s.tag)&&((n=u.params)==null||delete n.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:u});const b=await this.relayer.request(u);return this.relayer.events.emit(index_es_C.publish,e),this.logger.debug("Successfully Published Payload"),b}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const i=e.attempt+1;this.queue.set(t,index_es_Ge(Ie({},e),{attempt:i}));const{topic:s,message:n,opts:o,attestation:a}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`),await this.rpcPublish(index_es_Ge(Ie({},e),{topic:s,message:n,ttl:o.ttl,prompt:o.prompt,tag:o.tag,id:o.id,attestation:a,tvf:o.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(index_es_C.connection_stalled);return}this.checkQueue()}),this.relayer.on(index_es_C.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}var index_es_Gn=Object.defineProperty,index_es_Wn=(r,e,t)=>e in r?index_es_Gn(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_ne=(r,e,t)=>index_es_Wn(r,typeof e!="symbol"?e+"":e,t);class index_es_Hn{constructor(){index_es_ne(this,"map",new Map),index_es_ne(this,"set",(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])}),index_es_ne(this,"get",e=>this.map.get(e)||[]),index_es_ne(this,"exists",(e,t)=>this.get(e).includes(t)),index_es_ne(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(n=>n!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)}),index_es_ne(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}}var index_es_Yn=Object.defineProperty,index_es_Jn=Object.defineProperties,index_es_Xn=Object.getOwnPropertyDescriptors,index_es_Ii=Object.getOwnPropertySymbols,index_es_Zn=Object.prototype.hasOwnProperty,index_es_Qn=Object.prototype.propertyIsEnumerable,index_es_We=(r,e,t)=>e in r?index_es_Yn(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_ge=(r,e)=>{for(var t in e||(e={}))index_es_Zn.call(e,t)&&index_es_We(r,t,e[t]);if(index_es_Ii)for(var t of index_es_Ii(e))index_es_Qn.call(e,t)&&index_es_We(r,t,e[t]);return r},index_es_He=(r,e)=>index_es_Jn(r,index_es_Xn(e)),index_es_f=(r,e,t)=>index_es_We(r,typeof e!="symbol"?e+"":e,t);class index_es_Ti extends P{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,index_es_f(this,"subscriptions",new Map),index_es_f(this,"topicMap",new index_es_Hn),index_es_f(this,"events",new external_events_.EventEmitter),index_es_f(this,"name",Ut),index_es_f(this,"version",index_es_Ft),index_es_f(this,"pending",new Map),index_es_f(this,"cached",[]),index_es_f(this,"initialized",!1),index_es_f(this,"storagePrefix",B),index_es_f(this,"subscribeTimeout",(0,cjs.toMiliseconds)(cjs.ONE_MINUTE)),index_es_f(this,"initialSubscribeTimeout",(0,cjs.toMiliseconds)(cjs.ONE_SECOND*15)),index_es_f(this,"clientId"),index_es_f(this,"batchSubscribeTopicsLimit",500),index_es_f(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),index_es_f(this,"subscribe",async(i,s)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const n=Zc(s),o={topic:i,relay:n,transportType:s?.transportType};this.pending.set(i,o);const a=await this.rpcSubscribe(i,n,s);return typeof a=="string"&&(this.onSubscribe(a,o),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}})),a}catch(n){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(n),n}}),index_es_f(this,"unsubscribe",async(i,s)=>{this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)}),index_es_f(this,"isSubscribed",i=>new Promise(s=>{s(this.topicMap.topics.includes(i))})),index_es_f(this,"isKnownTopic",i=>new Promise(s=>{s(this.topicMap.topics.includes(i)||this.pending.has(i)||this.cached.some(n=>n.topic===i))})),index_es_f(this,"on",(i,s)=>{this.events.on(i,s)}),index_es_f(this,"once",(i,s)=>{this.events.once(i,s)}),index_es_f(this,"off",(i,s)=>{this.events.off(i,s)}),index_es_f(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),index_es_f(this,"start",async()=>{await this.onConnect()}),index_es_f(this,"stop",async()=>{await this.onDisconnect()}),index_es_f(this,"restart",async()=>{await this.restore(),await this.onRestart()}),index_es_f(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const i=[];this.pending.forEach(s=>{i.push(s)}),await this.batchSubscribe(i)}),index_es_f(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,async()=>{await this.checkPending()}),this.events.on(index_es_$.created,async i=>{const s=index_es_$.created;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()}),this.events.on(index_es_$.deleted,async i=>{const s=index_es_$.deleted;this.logger.info(`Emitting ${s}`),this.logger.debug({type:"event",event:s,data:i}),await this.persist()})}),this.relayer=e,this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.clientId=""}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=Zc(i);await this.restartToComplete({topic:e,id:t,relay:s}),await this.rpcUnsubscribe(e,t,s);const n=Nt("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t,i){var s;(!i||i?.transportType===index_es_Q.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const n={method:Yc(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:n});const o=(s=i?.internal)==null?void 0:s.throwOnFailedPublish;try{const a=await this.getSubscriptionId(e);if(i?.transportType===index_es_Q.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(n).catch(l=>this.logger.warn(l))},(0,cjs.toMiliseconds)(cjs.ONE_SECOND)),a;const c=new Promise(async l=>{const d=g=>{g.topic===e&&(this.events.removeListener(index_es_$.created,d),l(g.id))};this.events.on(index_es_$.created,d);try{const g=await yi(new Promise((_,u)=>{this.relayer.request(n).catch(b=>{this.logger.warn(b,b?.message),u(b)}).then(_)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(index_es_$.created,d),l(g)}catch{}}),h=await yi(c,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!h&&o)throw new Error(`Subscribing to ${e} failed, please try again`);return h?a:null}catch(a){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(index_es_C.connection_stalled),o)throw a}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:Yc(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await yi(new Promise(s=>{this.relayer.request(i).catch(n=>this.logger.warn(n)).then(s)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(index_es_C.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,i={method:Yc(t.protocol).batchFetchMessages,params:{topics:e.map(n=>n.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});let s;try{s=await await yi(new Promise((n,o)=>{this.relayer.request(i).catch(a=>{this.logger.warn(a),o(a)}).then(n)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(index_es_C.connection_stalled)}return s}rpcUnsubscribe(e,t,i){const s={method:Yc(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,index_es_He(index_es_ge({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,index_es_ge({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,index_es_ge({},t)),this.topicMap.set(t.topic,e),this.events.emit(index_es_$.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=ht("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(index_es_$.deleted,index_es_He(index_es_ge({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(index_es_$.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let i=0;i<t;i++){const s=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(s)}}this.events.emit(index_es_$.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=ht("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>index_es_He(index_es_ge({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await Ni((0,cjs.toMiliseconds)(cjs.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return kc(e+await this.getClientId())}}var index_es_eo=Object.defineProperty,index_es_Ci=Object.getOwnPropertySymbols,index_es_to=Object.prototype.hasOwnProperty,index_es_io=Object.prototype.propertyIsEnumerable,index_es_Ye=(r,e,t)=>e in r?index_es_eo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_Pi=(r,e)=>{for(var t in e||(e={}))index_es_to.call(e,t)&&index_es_Ye(r,t,e[t]);if(index_es_Ci)for(var t of index_es_Ci(e))index_es_io.call(e,t)&&index_es_Ye(r,t,e[t]);return r},index_es_y=(r,e,t)=>index_es_Ye(r,typeof e!="symbol"?e+"":e,t);class index_es_Si extends d{constructor(e){super(e),index_es_y(this,"protocol","wc"),index_es_y(this,"version",2),index_es_y(this,"core"),index_es_y(this,"logger"),index_es_y(this,"events",new external_events_.EventEmitter),index_es_y(this,"provider"),index_es_y(this,"messages"),index_es_y(this,"subscriber"),index_es_y(this,"publisher"),index_es_y(this,"name",index_es_$t),index_es_y(this,"transportExplicitlyClosed",!1),index_es_y(this,"initialized",!1),index_es_y(this,"connectionAttemptInProgress",!1),index_es_y(this,"relayUrl"),index_es_y(this,"projectId"),index_es_y(this,"packageName"),index_es_y(this,"bundleId"),index_es_y(this,"hasExperiencedNetworkDisruption",!1),index_es_y(this,"pingTimeout"),index_es_y(this,"heartBeatTimeout",(0,cjs.toMiliseconds)(cjs.THIRTY_SECONDS+cjs.FIVE_SECONDS)),index_es_y(this,"reconnectTimeout"),index_es_y(this,"connectPromise"),index_es_y(this,"reconnectInProgress",!1),index_es_y(this,"requestsInFlight",[]),index_es_y(this,"connectTimeout",(0,cjs.toMiliseconds)(cjs.ONE_SECOND*15)),index_es_y(this,"request",async t=>{var i,s;this.logger.debug("Publishing Request Payload");const n=t.id||(0,dist_esm.getBigIntRpcId)().toString();await this.toEstablishConnection();try{this.logger.trace({id:n,method:t.method,topic:(i=t.params)==null?void 0:i.topic},"relayer.request - publishing...");const o=`${n}:${((s=t.params)==null?void 0:s.tag)||""}`;this.requestsInFlight.push(o);const a=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(c=>c!==o),a}catch(o){throw this.logger.debug(`Failed to Publish Request: ${n}`),o}}),index_es_y(this,"resetPingTimeout",()=>{_e()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,i,s,n;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(n=(s=(i=(t=this.provider)==null?void 0:t.connection)==null?void 0:i.socket)==null?void 0:s.terminate)==null||n.call(s)}catch(o){this.logger.warn(o,o?.message)}},this.heartBeatTimeout))}),index_es_y(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),index_es_y(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected \u{1F6DC}"),this.startPingTimeout(),this.events.emit(index_es_C.connect)}),index_es_y(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected \u{1F6D1}"),this.requestsInFlight=[],this.onProviderDisconnect()}),index_es_y(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(index_es_C.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),index_es_y(this,"registerProviderListeners",()=>{this.provider.on(L.payload,this.onPayloadHandler),this.provider.on(L.connect,this.onConnectHandler),this.provider.on(L.disconnect,this.onDisconnectHandler),this.provider.on(L.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?(0,logger_dist_index_es/* generateChildLogger */.U5)(e.logger,this.name):(0,logger_dist_index_es/* pino */.h6)((0,logger_dist_index_es/* getDefaultLoggerOptions */.iP)({level:e.logger||index_es_Nt})),this.messages=new index_es_i(this.logger,e.core),this.subscriber=new index_es_Ti(this,this.logger),this.publisher=new index_es_qn(this,this.logger),this.relayUrl=e?.relayUrl||index_es_Ue,this.projectId=e.projectId,ei()?this.packageName=ri():ni()&&(this.bundleId=ri()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e?.message)}}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get connected(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===1||!1}get connecting(){var e,t,i;return((i=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:i.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:index_es_Q.relay},index_es_le.outbound)}async subscribe(e,t){var i,s,n;this.isInitialized(),(!(t!=null&&t.transportType)||t?.transportType==="relay")&&await this.toEstablishConnection();const o=typeof((i=t?.internal)==null?void 0:i.throwOnFailedPublish)>"u"?!0:(s=t?.internal)==null?void 0:s.throwOnFailedPublish;let a=((n=this.subscriber.topicMap.get(e))==null?void 0:n[0])||"",c;const h=l=>{l.topic===e&&(this.subscriber.off(index_es_$.created,h),c())};return await Promise.all([new Promise(l=>{c=l,this.subscriber.on(index_es_$.created,h)}),new Promise(async(l,d)=>{a=await this.subscriber.subscribe(e,index_es_Pi({internal:{throwOnFailedPublish:o}},t)).catch(g=>{o&&d(g)})||a,l()})]),a}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await yi(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,i)=>{await this.connect(e).then(t).catch(i).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await Na())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if(e?.length===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((i,s)=>i.publishedAt-s.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const i of t)try{await this.onMessageEvent(i)}catch(s){this.logger.warn(s,"Error while processing batch message event: "+s?.message)}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:i}=e;if(!t.sessionExists){const s=Ei(cjs.FIVE_MINUTES),n={topic:i,expiry:s,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(i,n)}this.events.emit(index_es_C.message,e),await this.recordMessageEvent(e,index_es_le.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(i,s)=>{const n=()=>{s(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(L.disconnect,n),await yi(new Promise((o,a)=>{this.provider.connect().then(o).catch(a)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(o=>{s(o)}).finally(()=>{this.provider.off(L.disconnect,n),clearTimeout(this.reconnectTimeout)}),await new Promise(async(o,a)=>{const c=()=>{a(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(L.disconnect,c),await this.subscriber.start().then(o).catch(a).finally(()=>{this.provider.off(L.disconnect,c)})}),this.hasExperiencedNetworkDisruption=!1,i()})}catch(i){await this.subscriber.stop();const s=i;this.logger.warn({},s.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(i=>setTimeout(i,(0,cjs.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,i,s,n;if(_e())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((n=(s=(i=this.provider)==null?void 0:i.connection)==null?void 0:s.socket)==null||n.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(o){this.logger.warn(o,o?.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_ws_connection_dist_index_es/* default */.A(si({sdkVersion:index_es_e,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:i,message:s}=e;await this.messages.set(i,s,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.warn(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,dist_esm.isJsonRpcRequest)(e)){if(!e.method.endsWith(zt))return;const t=e.params,{topic:i,message:s,publishedAt:n,attestation:o}=t.data,a={topic:i,message:s,publishedAt:n,transportType:index_es_Q.relay,attestation:o};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(index_es_Pi({type:"event",event:t.id},a)),this.events.emit(t.id,a),await this.acknowledgePayload(e),await this.onMessageEvent(a)}else (0,dist_esm.isJsonRpcResponse)(e)&&this.events.emit(index_es_C.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,index_es_le.inbound),this.events.emit(index_es_C.message,e))}async acknowledgePayload(e){const t=(0,dist_esm.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(L.payload,this.onPayloadHandler),this.provider.off(L.connect,this.onConnectHandler),this.provider.off(L.disconnect,this.onDisconnectHandler),this.provider.off(L.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await Na();Ua(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(i=>this.logger.error(i,i?.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&Ta())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t?.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(index_es_C.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e?.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,cjs.toMiliseconds)(index_es_Lt)))))}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}}function index_es_so(){}function index_es_Oi(r){if(!r||typeof r!="object")return!1;const e=Object.getPrototypeOf(r);return e===null||e===Object.prototype||Object.getPrototypeOf(e)===null?Object.prototype.toString.call(r)==="[object Object]":!1}function index_es_Ri(r){return Object.getOwnPropertySymbols(r).filter(e=>Object.prototype.propertyIsEnumerable.call(r,e))}function index_es_Ai(r){return r==null?r===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(r)}const index_es_ro="[object RegExp]",index_es_no="[object String]",index_es_oo="[object Number]",index_es_ao="[object Boolean]",index_es_xi="[object Arguments]",index_es_co="[object Symbol]",index_es_ho="[object Date]",index_es_lo="[object Map]",index_es_uo="[object Set]",index_es_go="[object Array]",index_es_po="[object Function]",index_es_yo="[object ArrayBuffer]",index_es_Je="[object Object]",index_es_bo="[object Error]",index_es_mo="[object DataView]",index_es_fo="[object Uint8Array]",index_es_Do="[object Uint8ClampedArray]",index_es_vo="[object Uint16Array]",index_es_wo="[object Uint32Array]",index_es_o="[object BigUint64Array]",index_es_Eo="[object Int8Array]",index_es_Io="[object Int16Array]",index_es_To="[object Int32Array]",Co="[object BigInt64Array]",Po="[object Float32Array]",index_es_So="[object Float64Array]";function index_es_Oo(r,e){return r===e||Number.isNaN(r)&&Number.isNaN(e)}function index_es_Ro(r,e,t){return index_es_pe(r,e,void 0,void 0,void 0,void 0,t)}function index_es_pe(r,e,t,i,s,n,o){const a=o(r,e,t,i,s,n);if(a!==void 0)return a;if(typeof r==typeof e)switch(typeof r){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return r===e;case"number":return r===e||Object.is(r,e);case"function":return r===e;case"object":return index_es_ye(r,e,n,o)}return index_es_ye(r,e,n,o)}function index_es_ye(r,e,t,i){if(Object.is(r,e))return!0;let s=index_es_Ai(r),n=index_es_Ai(e);if(s===index_es_xi&&(s=index_es_Je),n===index_es_xi&&(n=index_es_Je),s!==n)return!1;switch(s){case index_es_no:return r.toString()===e.toString();case index_es_oo:{const c=r.valueOf(),h=e.valueOf();return index_es_Oo(c,h)}case index_es_ao:case index_es_ho:case index_es_co:return Object.is(r.valueOf(),e.valueOf());case index_es_ro:return r.source===e.source&&r.flags===e.flags;case index_es_po:return r===e}t=t??new Map;const o=t.get(r),a=t.get(e);if(o!=null&&a!=null)return o===e;t.set(r,e),t.set(e,r);try{switch(s){case index_es_lo:{if(r.size!==e.size)return!1;for(const[c,h]of r.entries())if(!e.has(c)||!index_es_pe(h,e.get(c),c,r,e,t,i))return!1;return!0}case index_es_uo:{if(r.size!==e.size)return!1;const c=Array.from(r.values()),h=Array.from(e.values());for(let l=0;l<c.length;l++){const d=c[l],g=h.findIndex(_=>index_es_pe(d,_,void 0,r,e,t,i));if(g===-1)return!1;h.splice(g,1)}return!0}case index_es_go:case index_es_fo:case index_es_Do:case index_es_vo:case index_es_wo:case index_es_o:case index_es_Eo:case index_es_Io:case index_es_To:case Co:case Po:case index_es_So:{if(typeof Buffer<"u"&&Buffer.isBuffer(r)!==Buffer.isBuffer(e)||r.length!==e.length)return!1;for(let c=0;c<r.length;c++)if(!index_es_pe(r[c],e[c],c,r,e,t,i))return!1;return!0}case index_es_yo:return r.byteLength!==e.byteLength?!1:index_es_ye(new Uint8Array(r),new Uint8Array(e),t,i);case index_es_mo:return r.byteLength!==e.byteLength||r.byteOffset!==e.byteOffset?!1:index_es_ye(new Uint8Array(r),new Uint8Array(e),t,i);case index_es_bo:return r.name===e.name&&r.message===e.message;case index_es_Je:{if(!(index_es_ye(r.constructor,e.constructor,t,i)||index_es_Oi(r)&&index_es_Oi(e)))return!1;const h=[...Object.keys(r),...index_es_Ri(r)],l=[...Object.keys(e),...index_es_Ri(e)];if(h.length!==l.length)return!1;for(let d=0;d<h.length;d++){const g=h[d],_=r[g];if(!Object.hasOwn(e,g))return!1;const u=e[g];if(!index_es_pe(_,u,g,r,e,t,i))return!1}return!0}default:return!1}}finally{t.delete(r),t.delete(e)}}function index_es_Ao(r,e){return index_es_Ro(r,e,index_es_so)}var index_es_xo=Object.defineProperty,index_es_Ni=Object.getOwnPropertySymbols,index_es_No=Object.prototype.hasOwnProperty,index_es_$o=Object.prototype.propertyIsEnumerable,index_es_Xe=(r,e,t)=>e in r?index_es_xo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_$i=(r,e)=>{for(var t in e||(e={}))index_es_No.call(e,t)&&index_es_Xe(r,t,e[t]);if(index_es_Ni)for(var t of index_es_Ni(e))index_es_$o.call(e,t)&&index_es_Xe(r,t,e[t]);return r},z=(r,e,t)=>index_es_Xe(r,typeof e!="symbol"?e+"":e,t);class index_es_zi extends f{constructor(e,t,i,s=B,n=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,z(this,"map",new Map),z(this,"version",dist_index_es_kt),z(this,"cached",[]),z(this,"initialized",!1),z(this,"getKey"),z(this,"storagePrefix",B),z(this,"recentlyDeleted",[]),z(this,"recentlyDeletedLimit",200),z(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(o=>{this.getKey&&o!==null&&!Et(o)?this.map.set(this.getKey(o),o):la(o)?this.map.set(o.id,o):da(o)&&this.map.set(o.topic,o)}),this.cached=[],this.initialized=!0)}),z(this,"set",async(o,a)=>{this.isInitialized(),this.map.has(o)?await this.update(o,a):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:o,value:a}),this.map.set(o,a),await this.persist())}),z(this,"get",o=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:o}),this.getData(o))),z(this,"getAll",o=>(this.isInitialized(),o?this.values.filter(a=>Object.keys(o).every(c=>index_es_Ao(a[c],o[c]))):this.values)),z(this,"update",async(o,a)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:o,update:a});const c=index_es_$i(index_es_$i({},this.getData(o)),a);this.map.set(o,c),await this.persist()}),z(this,"delete",async(o,a)=>{this.isInitialized(),this.map.has(o)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:o,reason:a}),this.map.delete(o),this.addToRecentlyDeleted(o),await this.persist())}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.storagePrefix=s,this.getKey=n}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:s}=ht("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}const{message:i}=ht("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=ht("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_zo=Object.defineProperty,index_es_Lo=(r,e,t)=>e in r?index_es_zo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_p=(r,e,t)=>index_es_Lo(r,typeof e!="symbol"?e+"":e,t);class index_es_Li{constructor(e,t){this.core=e,this.logger=t,index_es_p(this,"name",index_es_Mt),index_es_p(this,"version",index_es_Kt),index_es_p(this,"events",new (external_events_default())),index_es_p(this,"pairings"),index_es_p(this,"initialized",!1),index_es_p(this,"storagePrefix",B),index_es_p(this,"ignoredPayloadTypes",[Ft]),index_es_p(this,"registeredMethods",[]),index_es_p(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),index_es_p(this,"register",({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]}),index_es_p(this,"create",async i=>{this.isInitialized();const s=jc(),n=await this.core.crypto.setSymKey(s),o=Ei(cjs.FIVE_MINUTES),a={protocol:index_es_xt},c={topic:n,expiry:o,relay:a,active:!1,methods:i?.methods},h=Wc({protocol:this.core.protocol,version:this.core.version,topic:n,symKey:s,relay:a,expiryTimestamp:o,methods:i?.methods});return this.events.emit(index_es_re.create,c),this.core.expirer.set(n,o),await this.pairings.set(n,c),await this.core.relayer.subscribe(n,{transportType:i?.transportType}),{topic:n,uri:h}}),index_es_p(this,"pair",async i=>{this.isInitialized();const s=this.core.eventClient.createEvent({properties:{topic:i?.uri,trace:[index_es_G.pairing_started]}});this.isValidPair(i,s);const{topic:n,symKey:o,relay:a,expiryTimestamp:c,methods:h}=Gc(i.uri);s.props.properties.topic=n,s.addTrace(index_es_G.pairing_uri_validation_success),s.addTrace(index_es_G.pairing_uri_not_expired);let l;if(this.pairings.keys.includes(n)){if(l=this.pairings.get(n),s.addTrace(index_es_G.existing_pairing),l.active)throw s.setError(index_es_Y.active_pairing_already_exists),new Error(`Pairing already exists: ${n}. Please try again with a new connection URI.`);s.addTrace(index_es_G.pairing_not_expired)}const d=c||Ei(cjs.FIVE_MINUTES),g={topic:n,relay:a,expiry:d,active:!1,methods:h};this.core.expirer.set(n,d),await this.pairings.set(n,g),s.addTrace(index_es_G.store_new_pairing),i.activatePairing&&await this.activate({topic:n}),this.events.emit(index_es_re.create,g),s.addTrace(index_es_G.emit_inactive_pairing),this.core.crypto.keychain.has(n)||await this.core.crypto.setSymKey(o,n),s.addTrace(index_es_G.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{s.setError(index_es_Y.no_internet_connection)}try{await this.core.relayer.subscribe(n,{relay:a})}catch(_){throw s.setError(index_es_Y.subscribe_pairing_topic_failure),_}return s.addTrace(index_es_G.subscribe_pairing_topic_success),g}),index_es_p(this,"activate",async({topic:i})=>{this.isInitialized();const s=Ei(cjs.FIVE_MINUTES);this.core.expirer.set(i,s),await this.pairings.update(i,{active:!0,expiry:s})}),index_es_p(this,"ping",async i=>{this.isInitialized(),await this.isValidPing(i),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:s}=i;if(this.pairings.keys.includes(s)){const n=await this.sendRequest(s,"wc_pairingPing",{}),{done:o,resolve:a,reject:c}=gi();this.events.once(xi("pairing_ping",n),({error:h})=>{h?c(h):a()}),await o()}}),index_es_p(this,"updateExpiry",async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})}),index_es_p(this,"updateMetadata",async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})}),index_es_p(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),index_es_p(this,"disconnect",async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",Nt("USER_DISCONNECTED")),await this.deletePairing(s))}),index_es_p(this,"formatUriFromPairing",i=>{this.isInitialized();const{topic:s,relay:n,expiry:o,methods:a}=i,c=this.core.crypto.keychain.get(s);return Wc({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:c,relay:n,expiryTimestamp:o,methods:a})}),index_es_p(this,"sendRequest",async(i,s,n)=>{const o=(0,dist_esm.formatJsonRpcRequest)(s,n),a=await this.core.crypto.encode(i,o),c=index_es_se[s].req;return this.core.history.set(i,o),this.core.relayer.publish(i,a,c),o.id}),index_es_p(this,"sendResult",async(i,s,n)=>{const o=(0,dist_esm.formatJsonRpcResult)(i,n),a=await this.core.crypto.encode(s,o),c=(await this.core.history.get(s,i)).request.method,h=index_es_se[c].res;await this.core.relayer.publish(s,a,h),await this.core.history.resolve(o)}),index_es_p(this,"sendError",async(i,s,n)=>{const o=(0,dist_esm.formatJsonRpcError)(i,n),a=await this.core.crypto.encode(s,o),c=(await this.core.history.get(s,i)).request.method,h=index_es_se[c]?index_es_se[c].res:index_es_se.unregistered_method.res;await this.core.relayer.publish(s,a,h),await this.core.history.resolve(o)}),index_es_p(this,"deletePairing",async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,Nt("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])}),index_es_p(this,"cleanup",async()=>{const i=this.pairings.getAll().filter(s=>vi(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))}),index_es_p(this,"onRelayEventRequest",async i=>{const{topic:s,payload:n}=i;switch(n.method){case"wc_pairingPing":return await this.onPairingPingRequest(s,n);case"wc_pairingDelete":return await this.onPairingDeleteRequest(s,n);default:return await this.onUnknownRpcMethodRequest(s,n)}}),index_es_p(this,"onRelayEventResponse",async i=>{const{topic:s,payload:n}=i,o=(await this.core.history.get(s,n.id)).request.method;switch(o){case"wc_pairingPing":return this.onPairingPingResponse(s,n);default:return this.onUnknownRpcMethodResponse(o)}}),index_es_p(this,"onPairingPingRequest",async(i,s)=>{const{id:n}=s;try{this.isValidPing({topic:i}),await this.sendResult(n,i,!0),this.events.emit(index_es_re.ping,{id:n,topic:i})}catch(o){await this.sendError(n,i,o),this.logger.error(o)}}),index_es_p(this,"onPairingPingResponse",(i,s)=>{const{id:n}=s;setTimeout(()=>{(0,dist_esm.isJsonRpcResult)(s)?this.events.emit(xi("pairing_ping",n),{}):(0,dist_esm.isJsonRpcError)(s)&&this.events.emit(xi("pairing_ping",n),{error:s.error})},500)}),index_es_p(this,"onPairingDeleteRequest",async(i,s)=>{const{id:n}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(index_es_re.delete,{id:n,topic:i})}catch(o){await this.sendError(n,i,o),this.logger.error(o)}}),index_es_p(this,"onUnknownRpcMethodRequest",async(i,s)=>{const{id:n,method:o}=s;try{if(this.registeredMethods.includes(o))return;const a=Nt("WC_METHOD_UNSUPPORTED",o);await this.sendError(n,i,a),this.logger.error(a)}catch(a){await this.sendError(n,i,a),this.logger.error(a)}}),index_es_p(this,"onUnknownRpcMethodResponse",i=>{this.registeredMethods.includes(i)||this.logger.error(Nt("WC_METHOD_UNSUPPORTED",i))}),index_es_p(this,"isValidPair",(i,s)=>{var n;if(!ma(i)){const{message:a}=ht("MISSING_OR_INVALID",`pair() params: ${i}`);throw s.setError(index_es_Y.malformed_pairing_uri),new Error(a)}if(!fa(i.uri)){const{message:a}=ht("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw s.setError(index_es_Y.malformed_pairing_uri),new Error(a)}const o=Gc(i?.uri);if(!((n=o?.relay)!=null&&n.protocol)){const{message:a}=ht("MISSING_OR_INVALID","pair() uri#relay-protocol");throw s.setError(index_es_Y.malformed_pairing_uri),new Error(a)}if(!(o!=null&&o.symKey)){const{message:a}=ht("MISSING_OR_INVALID","pair() uri#symKey");throw s.setError(index_es_Y.malformed_pairing_uri),new Error(a)}if(o!=null&&o.expiryTimestamp&&(0,cjs.toMiliseconds)(o?.expiryTimestamp)<Date.now()){s.setError(index_es_Y.pairing_expired);const{message:a}=ht("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(a)}}),index_es_p(this,"isValidPing",async i=>{if(!ma(i)){const{message:n}=ht("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)}),index_es_p(this,"isValidDisconnect",async i=>{if(!ma(i)){const{message:n}=ht("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)}),index_es_p(this,"isValidPairingTopic",async i=>{if(!nt(i,!1)){const{message:s}=ht("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=ht("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(vi(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=ht("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}}),this.core=e,this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.pairings=new index_es_zi(this.core,this.logger,this.name,this.storagePrefix)}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(index_es_C.message,async e=>{const{topic:t,message:i,transportType:s}=e;if(this.pairings.keys.includes(t)&&s!==index_es_Q.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))try{const n=await this.core.crypto.decode(t,i);(0,dist_esm.isJsonRpcRequest)(n)?(this.core.history.set(t,n),await this.onRelayEventRequest({topic:t,payload:n})):(0,dist_esm.isJsonRpcResponse)(n)&&(await this.core.history.resolve(n),await this.onRelayEventResponse({topic:t,payload:n}),this.core.history.delete(t,n.id)),await this.core.relayer.messages.ack(t,i)}catch(n){this.logger.error(n)}})}registerExpirerEvents(){this.core.expirer.on(index_es_M.expired,async e=>{const{topic:t}=bi(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(index_es_re.expire,{topic:t}))})}}var index_es_ko=Object.defineProperty,index_es_jo=(r,e,t)=>e in r?index_es_ko(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_O=(r,e,t)=>index_es_jo(r,typeof e!="symbol"?e+"":e,t);class index_es_ki extends I{constructor(e,t){super(e,t),this.core=e,this.logger=t,index_es_O(this,"records",new Map),index_es_O(this,"events",new external_events_.EventEmitter),index_es_O(this,"name",index_es_Bt),index_es_O(this,"version",index_es_Vt),index_es_O(this,"cached",[]),index_es_O(this,"initialized",!1),index_es_O(this,"storagePrefix",B),index_es_O(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),index_es_O(this,"set",(i,s,n)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:n}),this.records.has(s.id))return;const o={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:n,expiry:Ei(cjs.THIRTY_DAYS)};this.records.set(o.id,o),this.persist(),this.events.emit(index_es_F.created,o)}),index_es_O(this,"resolve",async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=(0,dist_esm.isJsonRpcError)(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.persist(),this.events.emit(index_es_F.updated,s))}),index_es_O(this,"get",async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s))),index_es_O(this,"delete",(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(n=>{if(n.topic===i){if(typeof s<"u"&&n.id!==s)return;this.records.delete(n.id),this.events.emit(index_es_F.deleted,n)}}),this.persist()}),index_es_O(this,"exists",async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1)),index_es_O(this,"on",(i,s)=>{this.events.on(i,s)}),index_es_O(this,"once",(i,s)=>{this.events.once(i,s)}),index_es_O(this,"off",(i,s)=>{this.events.off(i,s)}),index_es_O(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name)}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:(0,dist_esm.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=ht("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(index_es_F.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=ht("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(index_es_F.created,e=>{const t=index_es_F.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(index_es_F.updated,e=>{const t=index_es_F.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(index_es_F.deleted,e=>{const t=index_es_F.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,cjs.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(index_es_F.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_Uo=Object.defineProperty,index_es_Fo=(r,e,t)=>e in r?index_es_Uo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,A=(r,e,t)=>index_es_Fo(r,typeof e!="symbol"?e+"":e,t);class index_es_ji extends S{constructor(e,t){super(e,t),this.core=e,this.logger=t,A(this,"expirations",new Map),A(this,"events",new external_events_.EventEmitter),A(this,"name",index_es_qt),A(this,"version",index_es_Gt),A(this,"cached",[]),A(this,"initialized",!1),A(this,"storagePrefix",B),A(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),A(this,"has",i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}}),A(this,"set",(i,s)=>{this.isInitialized();const n=this.formatTarget(i),o={target:n,expiry:s};this.expirations.set(n,o),this.checkExpiry(n,o),this.events.emit(index_es_M.created,{target:n,expiration:o})}),A(this,"get",i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)}),A(this,"del",i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),n=this.getExpiration(s);this.expirations.delete(s),this.events.emit(index_es_M.deleted,{target:s,expiration:n})}}),A(this,"on",(i,s)=>{this.events.on(i,s)}),A(this,"once",(i,s)=>{this.events.once(i,s)}),A(this,"off",(i,s)=>{this.events.off(i,s)}),A(this,"removeListener",(i,s)=>{this.events.removeListener(i,s)}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name)}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return mi(e);if(typeof e=="number")return wi(e);const{message:t}=ht("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(index_es_M.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=ht("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=ht("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;(0,cjs.toMiliseconds)(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(index_es_M.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,()=>this.checkExpirations()),this.events.on(index_es_M.created,e=>{const t=index_es_M.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(index_es_M.expired,e=>{const t=index_es_M.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(index_es_M.deleted,e=>{const t=index_es_M.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=ht("NOT_INITIALIZED",this.name);throw new Error(e)}}}var index_es_Mo=Object.defineProperty,index_es_Ko=(r,e,t)=>e in r?index_es_Mo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_w=(r,e,t)=>index_es_Ko(r,typeof e!="symbol"?e+"":e,t);class index_es_Ui extends M{constructor(e,t,i){super(e,t,i),this.core=e,this.logger=t,this.store=i,index_es_w(this,"name",index_es_Wt),index_es_w(this,"abortController"),index_es_w(this,"isDevEnv"),index_es_w(this,"verifyUrlV3",index_es_Yt),index_es_w(this,"storagePrefix",B),index_es_w(this,"version",index_es_Le),index_es_w(this,"publicKey"),index_es_w(this,"fetchPromise"),index_es_w(this,"init",async()=>{var s;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,cjs.toMiliseconds)((s=this.publicKey)==null?void 0:s.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),index_es_w(this,"register",async s=>{if(!Tt()||this.isDevEnv)return;const n=window.location.origin,{id:o,decryptedId:a}=s,c=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${o}&decryptedId=${a}`;try{const h=(0,dist_cjs.getDocument)(),l=this.startAbortTimer(cjs.ONE_SECOND*5),d=await new Promise((g,_)=>{const u=()=>{window.removeEventListener("message",x),h.body.removeChild(b),_("attestation aborted")};this.abortController.signal.addEventListener("abort",u);const b=h.createElement("iframe");b.src=c,b.style.display="none",b.addEventListener("error",u,{signal:this.abortController.signal});const x=I=>{if(I.data&&typeof I.data=="string")try{const D=JSON.parse(I.data);if(D.type==="verify_attestation"){if((0,relay_auth_dist_index_es/* decodeJWT */.Cq)(D.attestation).payload.id!==o)return;clearInterval(l),h.body.removeChild(b),this.abortController.signal.removeEventListener("abort",u),window.removeEventListener("message",x),g(D.attestation===null?"":D.attestation)}}catch(D){this.logger.warn(D)}};h.body.appendChild(b),window.addEventListener("message",x,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",d),d}catch(h){this.logger.warn(h)}return""}),index_es_w(this,"resolve",async s=>{if(this.isDevEnv)return"";const{attestationId:n,hash:o,encryptedId:a}=s;if(n===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(n){if((0,relay_auth_dist_index_es/* decodeJWT */.Cq)(n).payload.id!==a)return;const h=await this.isValidJwtAttestation(n);if(h){if(!h.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return h}}if(!o)return;const c=this.getVerifyUrl(s?.verifyUrl);return this.fetchAttestation(o,c)}),index_es_w(this,"fetchAttestation",async(s,n)=>{this.logger.debug(`resolving attestation: ${s} from url: ${n}`);const o=this.startAbortTimer(cjs.ONE_SECOND*5),a=await fetch(`${n}/attestation/${s}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(o),a.status===200?await a.json():void 0}),index_es_w(this,"getVerifyUrl",s=>{let n=s||index_es_ue;return index_es_Jt.includes(n)||(this.logger.info(`verify url: ${n}, not included in trusted list, assigning default: ${index_es_ue}`),n=index_es_ue),n}),index_es_w(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const s=this.startAbortTimer(cjs.FIVE_SECONDS),n=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(s),await n.json()}catch(s){this.logger.warn(s)}}),index_es_w(this,"persistPublicKey",async s=>{this.logger.debug("persisting public key to local storage",s),await this.store.setItem(this.storeKey,s),this.publicKey=s}),index_es_w(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),index_es_w(this,"isValidJwtAttestation",async s=>{const n=await this.getPublicKey();try{if(n)return this.validateAttestation(s,n)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}const o=await this.fetchAndPersistPublicKey();try{if(o)return this.validateAttestation(s,o)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}}),index_es_w(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),index_es_w(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async n=>{const o=await this.fetchPublicKey();o&&(await this.persistPublicKey(o),n(o))});const s=await this.fetchPromise;return this.fetchPromise=void 0,s}),index_es_w(this,"validateAttestation",(s,n)=>{const o=zc(s,n.publicKey),a={hasExpired:(0,cjs.toMiliseconds)(o.exp)<Date.now(),payload:o};if(a.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:a.payload.origin,isScam:a.payload.isScam,isVerified:a.payload.isVerified}}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.name),this.abortController=new AbortController,this.isDevEnv=Ii(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,cjs.toMiliseconds)(e))}}var index_es_Bo=Object.defineProperty,index_es_Vo=(r,e,t)=>e in r?index_es_Bo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_Fi=(r,e,t)=>index_es_Vo(r,typeof e!="symbol"?e+"":e,t);class index_es_Mi extends O{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,index_es_Fi(this,"context",index_es_Xt),index_es_Fi(this,"registerDeviceToken",async i=>{const{clientId:s,token:n,notificationType:o,enableEncrypted:a=!1}=i,c=`${Zt}/${this.projectId}/clients`;await fetch(c,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:s,type:o,token:n,always_raw:a})})}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.context)}}var index_es_qo=Object.defineProperty,index_es_Ki=Object.getOwnPropertySymbols,index_es_Go=Object.prototype.hasOwnProperty,index_es_Wo=Object.prototype.propertyIsEnumerable,index_es_Ze=(r,e,t)=>e in r?index_es_qo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_be=(r,e)=>{for(var t in e||(e={}))index_es_Go.call(e,t)&&index_es_Ze(r,t,e[t]);if(index_es_Ki)for(var t of index_es_Ki(e))index_es_Wo.call(e,t)&&index_es_Ze(r,t,e[t]);return r},index_es_E=(r,e,t)=>index_es_Ze(r,typeof e!="symbol"?e+"":e,t);class Bi extends R{constructor(e,t,i=!0){super(e,t,i),this.core=e,this.logger=t,index_es_E(this,"context",index_es_ei),index_es_E(this,"storagePrefix",B),index_es_E(this,"storageVersion",index_es_Qt),index_es_E(this,"events",new Map),index_es_E(this,"shouldPersist",!1),index_es_E(this,"init",async()=>{if(!Ii())try{const s={eventId:index_es_Bi(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:Mn(this.core.relayer.protocol,this.core.relayer.version,index_es_e)}}};await this.sendEvent([s])}catch(s){this.logger.warn(s)}}),index_es_E(this,"createEvent",s=>{const{event:n="ERROR",type:o="",properties:{topic:a,trace:c}}=s,h=index_es_Bi(),l=this.core.projectId||"",d=Date.now(),g=index_es_be({eventId:h,timestamp:d,props:{event:n,type:o,properties:{topic:a,trace:c}},bundleId:l,domain:this.getAppDomain()},this.setMethods(h));return this.telemetryEnabled&&(this.events.set(h,g),this.shouldPersist=!0),g}),index_es_E(this,"getEvent",s=>{const{eventId:n,topic:o}=s;if(n)return this.events.get(n);const a=Array.from(this.events.values()).find(c=>c.props.properties.topic===o);if(a)return index_es_be(index_es_be({},a),this.setMethods(a.eventId))}),index_es_E(this,"deleteEvent",s=>{const{eventId:n}=s;this.events.delete(n),this.shouldPersist=!0}),index_es_E(this,"setEventListeners",()=>{this.core.heartbeat.on(index_es/* HEARTBEAT_EVENTS */.li.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(s=>{(0,cjs.fromMiliseconds)(Date.now())-(0,cjs.fromMiliseconds)(s.timestamp)>index_es_ti&&(this.events.delete(s.eventId),this.shouldPersist=!0)})})}),index_es_E(this,"setMethods",s=>({addTrace:n=>this.addTrace(s,n),setError:n=>this.setError(s,n)})),index_es_E(this,"addTrace",(s,n)=>{const o=this.events.get(s);o&&(o.props.properties.trace.push(n),this.events.set(s,o),this.shouldPersist=!0)}),index_es_E(this,"setError",(s,n)=>{const o=this.events.get(s);o&&(o.props.type=n,o.timestamp=Date.now(),this.events.set(s,o),this.shouldPersist=!0)}),index_es_E(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),index_es_E(this,"restore",async()=>{try{const s=await this.core.storage.getItem(this.storageKey)||[];if(!s.length)return;s.forEach(n=>{this.events.set(n.eventId,index_es_be(index_es_be({},n),this.setMethods(n.eventId)))})}catch(s){this.logger.warn(s)}}),index_es_E(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const s=[];for(const[n,o]of this.events)o.props.type&&s.push(o);if(s.length!==0)try{if((await this.sendEvent(s)).ok)for(const n of s)this.events.delete(n.eventId),this.shouldPersist=!0}catch(n){this.logger.warn(n)}}),index_es_E(this,"sendEvent",async s=>{const n=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${index_es_ii}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${index_es_e}${n}`,{method:"POST",body:JSON.stringify(s)})}),index_es_E(this,"getAppDomain",()=>Pn().url),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(t,this.context),this.telemetryEnabled=i,i?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var index_es_Ho=Object.defineProperty,index_es_Vi=Object.getOwnPropertySymbols,index_es_Yo=Object.prototype.hasOwnProperty,index_es_Jo=Object.prototype.propertyIsEnumerable,index_es_Qe=(r,e,t)=>e in r?index_es_Ho(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,index_es_qi=(r,e)=>{for(var t in e||(e={}))index_es_Yo.call(e,t)&&index_es_Qe(r,t,e[t]);if(index_es_Vi)for(var t of index_es_Vi(e))index_es_Jo.call(e,t)&&index_es_Qe(r,t,e[t]);return r},index_es_v=(r,e,t)=>index_es_Qe(r,typeof e!="symbol"?e+"":e,t);class index_es_Te extends h{constructor(e){var t;super(e),index_es_v(this,"protocol",index_es_ze),index_es_v(this,"version",index_es_Le),index_es_v(this,"name",index_es_he),index_es_v(this,"relayUrl"),index_es_v(this,"projectId"),index_es_v(this,"customStoragePrefix"),index_es_v(this,"events",new external_events_.EventEmitter),index_es_v(this,"logger"),index_es_v(this,"heartbeat"),index_es_v(this,"relayer"),index_es_v(this,"crypto"),index_es_v(this,"storage"),index_es_v(this,"history"),index_es_v(this,"expirer"),index_es_v(this,"pairing"),index_es_v(this,"verify"),index_es_v(this,"echoClient"),index_es_v(this,"linkModeSupportedApps"),index_es_v(this,"eventClient"),index_es_v(this,"initialized",!1),index_es_v(this,"logChunkController"),index_es_v(this,"on",(a,c)=>this.events.on(a,c)),index_es_v(this,"once",(a,c)=>this.events.once(a,c)),index_es_v(this,"off",(a,c)=>this.events.off(a,c)),index_es_v(this,"removeListener",(a,c)=>this.events.removeListener(a,c)),index_es_v(this,"dispatchEnvelope",({topic:a,message:c,sessionExists:h})=>{if(!a||!c)return;const l={topic:a,message:c,publishedAt:Date.now(),transportType:index_es_Q.link_mode};this.relayer.onLinkMessageEvent(l,{sessionExists:h})});const i=this.getGlobalCore(e?.customStoragePrefix);if(i)try{return this.customStoragePrefix=i.customStoragePrefix,this.logger=i.logger,this.heartbeat=i.heartbeat,this.crypto=i.crypto,this.history=i.history,this.expirer=i.expirer,this.storage=i.storage,this.relayer=i.relayer,this.pairing=i.pairing,this.verify=i.verify,this.echoClient=i.echoClient,this.linkModeSupportedApps=i.linkModeSupportedApps,this.eventClient=i.eventClient,this.initialized=i.initialized,this.logChunkController=i.logChunkController,i}catch(a){console.warn("Failed to copy global core",a)}this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||index_es_Ue,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const s=(0,logger_dist_index_es/* getDefaultLoggerOptions */.iP)({level:typeof e?.logger=="string"&&e.logger?e.logger:index_es_Et.logger,name:index_es_he}),{logger:n,chunkLoggerController:o}=(0,logger_dist_index_es/* generatePlatformLogger */.D5)({opts:s,maxSizeInBytes:e?.maxLogBlobSizeInBytes,loggerOverride:e?.logger});this.logChunkController=o,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var a,c;(a=this.logChunkController)!=null&&a.downloadLogsBlobInBrowser&&((c=this.logChunkController)==null||c.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(n,this.name),this.heartbeat=new index_es/* HeartBeat */.VH,this.crypto=new index_es_vi(this,this.logger,e?.keychain),this.history=new index_es_ki(this,this.logger),this.expirer=new index_es_ji(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new dist_index_es/* default */.A(index_es_qi(index_es_qi({},index_es_It),e?.storageOptions)),this.relayer=new index_es_Si({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new index_es_Li(this,this.logger),this.verify=new index_es_Ui(this,this.logger,this.storage),this.echoClient=new index_es_Mi(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new Bi(this,this.logger,e?.telemetryEnabled),this.setGlobalCore(this)}static async init(e){const t=new index_es_Te(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem(index_es_jt,i),t}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(index_es_Fe,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(index_es_Fe)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}getGlobalCore(e=""){try{if(this.isGlobalCoreDisabled())return;const t=`_walletConnectCore_${e}`,i=`${t}_count`;return globalThis[i]=(globalThis[i]||0)+1,globalThis[i]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i]} times.`),globalThis[t]}catch(t){console.warn("Failed to get global WalletConnect core",t);return}}setGlobalCore(e){var t;try{if(this.isGlobalCoreDisabled())return;const i=`_walletConnectCore_${((t=e.opts)==null?void 0:t.customStoragePrefix)||""}`;globalThis[i]=e}catch(i){console.warn("Failed to set global WalletConnect core",i)}}isGlobalCoreDisabled(){try{return typeof process<"u"&&process.env.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}}const index_es_Xo=index_es_Te;
//# sourceMappingURL=index.es.js.map

;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/errors/version.js
const version = '2.23.2';
//# sourceMappingURL=version.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/errors/base.js

let errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath
        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`
        : undefined,
    version: `viem@${version}`,
};
function setErrorConfig(config) {
    errorConfig = config;
}
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.details;
            if (args.cause?.message)
                return args.cause.message;
            return args.details;
        })();
        const docsPath = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
        ].join('\n');
        super(message, args.cause ? { cause: args.cause } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err &&
        typeof err === 'object' &&
        'cause' in err &&
        err.cause !== undefined)
        return walk(err.cause, fn);
    return fn ? null : err;
}
//# sourceMappingURL=base.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
    if (!value)
        return false;
    if (typeof value !== 'string')
        return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}
//# sourceMappingURL=isHex.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/errors/data.js

class SliceOffsetOutOfBoundsError extends BaseError {
    constructor({ offset, position, size, }) {
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`, { name: 'SliceOffsetOutOfBoundsError' });
    }
}
class SizeExceedsPaddingSizeError extends BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });
    }
}
class InvalidBytesLengthError extends BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`, { name: 'InvalidBytesLengthError' });
    }
}
//# sourceMappingURL=data.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/data/pad.js

function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string')
        return padHex(hexOrBytes, { dir, size });
    return padBytes(hexOrBytes, { dir, size });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null)
        return bytes;
    if (bytes.length > size)
        throw new SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
//# sourceMappingURL=pad.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/errors/encoding.js

class IntegerOutOfRangeError extends BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });
    }
}
class InvalidBytesBooleanError extends BaseError {
    constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: 'InvalidBytesBooleanError',
        });
    }
}
class encoding_InvalidHexBooleanError extends BaseError {
    constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: 'InvalidHexBooleanError' });
    }
}
class InvalidHexValueError extends BaseError {
    constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, { name: 'InvalidHexValueError' });
    }
}
class SizeOverflowError extends BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: 'SizeOverflowError' });
    }
}
//# sourceMappingURL=encoding.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/data/size.js

/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */
function size_size(value) {
    if (isHex(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
    return value.length;
}
//# sourceMappingURL=size.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/encoding/fromHex.js




function assertSize(hexOrBytes, { size }) {
    if (size_size(hexOrBytes) > size)
        throw new SizeOverflowError({
            givenSize: size_size(hexOrBytes),
            maxSize: size,
        });
}
/**
 * Decodes a hex string into a string, number, bigint, boolean, or byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex
 * - Example: https://viem.sh/docs/utilities/fromHex#usage
 *
 * @param hex Hex string to decode.
 * @param toOrOpts Type to convert to or options.
 * @returns Decoded value.
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x1a4', 'number')
 * // 420
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')
 * // 'Hello world'
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *   size: 32,
 *   to: 'string'
 * })
 * // 'Hello world'
 */
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === 'number')
        return hexToNumber(hex, opts);
    if (to === 'bigint')
        return hexToBigInt(hex, opts);
    if (to === 'string')
        return hexToString(hex, opts);
    if (to === 'boolean')
        return hexToBool(hex, opts);
    return hexToBytes(hex, opts);
}
/**
 * Decodes a hex value into a bigint.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns BigInt value.
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x1a4', { signed: true })
 * // 420n
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420n
 */
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
        assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
        return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
    if (value <= max)
        return value;
    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
}
/**
 * Decodes a hex value into a boolean.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Boolean value.
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x01')
 * // true
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })
 * // true
 */
function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = trim(hex);
    }
    if (trim(hex) === '0x00')
        return false;
    if (trim(hex) === '0x01')
        return true;
    throw new InvalidHexBooleanError(hex);
}
/**
 * Decodes a hex string into a number.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Number value.
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToNumber('0x1a4')
 * // 420
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420
 */
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
/**
 * Decodes a hex value into a UTF-8 string.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns String value.
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c6421')
 * // 'Hello world!'
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *  size: 32,
 * })
 * // 'Hello world'
 */
function hexToString(hex, opts = {}) {
    let bytes = hexToBytes(hex);
    if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = trim(bytes, { dir: 'right' });
    }
    return new TextDecoder().decode(bytes);
}
//# sourceMappingURL=fromHex.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/encoding/toHex.js



const hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
/**
 * Encodes a string, number, bigint, or ByteArray into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex
 * - Example: https://viem.sh/docs/utilities/toHex#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world')
 * // '0x48656c6c6f20776f726c6421'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex(420)
 * // '0x1a4'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world', { size: 32 })
 * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
 */
function toHex(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToHex(value, opts);
    if (typeof value === 'string') {
        return stringToHex(value, opts);
    }
    if (typeof value === 'boolean')
        return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
/**
 * Encodes a boolean into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#booltohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true)
 * // '0x1'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(false)
 * // '0x0'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true, { size: 32 })
 * // '0x0000000000000000000000000000000000000000000000000000000000000001'
 */
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === 'number') {
        assertSize(hex, { size: opts.size });
        return pad(hex, { size: opts.size });
    }
    return hex;
}
/**
 * Encodes a bytes array into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function bytesToHex(value, opts = {}) {
    let string = '';
    for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === 'number') {
        assertSize(hex, { size: opts.size });
        return pad(hex, { dir: 'right', size: opts.size });
    }
    return hex;
}
/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`,
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size)
        return pad(hex, { size });
    return hex;
}
const encoder = /*#__PURE__*/ new TextEncoder();
/**
 * Encodes a UTF-8 string into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}
//# sourceMappingURL=toHex.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/encoding/toBytes.js





const toBytes_encoder = /*#__PURE__*/ new TextEncoder();
/**
 * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes
 * - Example: https://viem.sh/docs/utilities/toBytes#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes('Hello world')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */
function toBytes(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToBytes(value, opts);
    if (typeof value === 'boolean')
        return boolToBytes(value, opts);
    if (isHex(value))
        return toBytes_hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
/**
 * Encodes a boolean into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
 *
 * @param value Boolean value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true)
 * // Uint8Array([1])
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true, { size: 32 })
 * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
 */
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === 'number') {
        assertSize(bytes, { size: opts.size });
        return pad(bytes, { size: opts.size });
    }
    return bytes;
}
// We use very optimized technique to convert hex string to byte array
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102,
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
    return undefined;
}
/**
 * Encodes a hex string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
 *
 * @param hex Hex string to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */
function toBytes_hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = pad(hex, { dir: 'right', size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
        hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
/**
 * Encodes a number into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
 *
 * @param value Number to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */
function numberToBytes(value, opts) {
    const hex = numberToHex(value, opts);
    return toBytes_hexToBytes(hex);
}
/**
 * Encodes a UTF-8 string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
 *
 * @param value String to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */
function stringToBytes(value, opts = {}) {
    const bytes = toBytes_encoder.encode(value);
    if (typeof opts.size === 'number') {
        assertSize(bytes, { size: opts.size });
        return pad(bytes, { dir: 'right', size: opts.size });
    }
    return bytes;
}
//# sourceMappingURL=toBytes.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
/**
 * Internal assertion helpers.
 * @module
 */
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Is number an Uint8Array? Copied from utils for perf. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is Uint8Array. */
function _assert_abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    _assert_abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}

//# sourceMappingURL=_assert.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore

// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
/* harmony default export */ const _u64 = ((/* unused pure expression or super */ null && (u64)));
//# sourceMappingURL=_u64.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/node_modules/@noble/hashes/esm/utils.js
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.


// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function utils_isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
// Cast array to different type
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
// Cast array to view
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
// The byte swap operation for uint32
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
const byteSwapIfBE = (/* unused pure expression or super */ null && (isLE
    ? (n) => n
    : (n) => byteSwap(n)));
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const utils_hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function utils_bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += utils_hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function utils_hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
 * Convert JS string to byte array.
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('utf8ToBytes expected string, got ' + typeof str);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function utils_toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    _assert_abytes(data);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
/** For runtime check if class implements interface */
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** Wraps hash function, creating an interface on top of it */
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(utils_toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(utils_toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function utils_wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(utils_toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto && typeof crypto.randomBytes === 'function') {
        return crypto.randomBytes(bytesLength);
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */



// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
/** Keccak sponge function. */
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        anumber(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        if (!isLE)
            byteSwap32(this.state32);
        keccakP(this.state32, this.rounds);
        if (!isLE)
            byteSwap32(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        aexists(this);
        const { blockLen, state } = this;
        data = utils_toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        aexists(this, false);
        _assert_abytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        anumber(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        aoutput(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
const sha3_224 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 144, 224 / 8)));
/** SHA3-256 hash function. Different from keccak-256. */
const sha3_256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 136, 256 / 8)));
/** SHA3-384 hash function. */
const sha3_384 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 104, 384 / 8)));
/** SHA3-512 hash function. */
const sha3_512 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 72, 512 / 8)));
/** keccak-224 hash function. */
const keccak_224 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x01, 144, 224 / 8)));
/** keccak-256 hash function. Different from SHA3-256. */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);
/** keccak-384 hash function. */
const keccak_384 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x01, 104, 384 / 8)));
/** keccak-512 hash function. */
const keccak_512 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x01, 72, 512 / 8)));
const genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
const shake128 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 168, 128 / 8)));
/** SHAKE256 XOF with 256-bit security. */
const shake256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 136, 256 / 8)));
//# sourceMappingURL=sha3.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/hash/keccak256.js




function keccak256(value, to_) {
    const to = to_ || 'hex';
    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
    if (to === 'bytes')
        return bytes;
    return toHex(bytes);
}
//# sourceMappingURL=keccak256.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/lru.js
/**
 * Map with a LRU (Least recently used) policy.
 *
 * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
 */
class LruMap extends Map {
    constructor(size) {
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
                this.delete(firstKey);
        }
        return this;
    }
}
//# sourceMappingURL=lru.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/address/getAddress.js





const checksumAddressCache = /*#__PURE__*/ new LruMap(8192);
function checksumAddress(address_, 
/**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */
chainId) {
    if (checksumAddressCache.has(`${address_}.${chainId}`))
        return checksumAddressCache.get(`${address_}.${chainId}`);
    const hexAddress = chainId
        ? `${chainId}${address_.toLowerCase()}`
        : address_.substring(2).toLowerCase();
    const hash = keccak256(stringToBytes(hexAddress), 'bytes');
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
    for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
            address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
            address[i + 1] = address[i + 1].toUpperCase();
        }
    }
    const result = `0x${address.join('')}`;
    checksumAddressCache.set(`${address_}.${chainId}`, result);
    return result;
}
function getAddress(address, 
/**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */
chainId) {
    if (!isAddress(address, { strict: false }))
        throw new InvalidAddressError({ address });
    return checksumAddress(address, chainId);
}
//# sourceMappingURL=getAddress.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js


/**
 * @description Converts an ECDSA public key to an address.
 *
 * @param publicKey The public key to convert.
 *
 * @returns The address.
 */
function publicKeyToAddress(publicKey) {
    const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
    return checksumAddress(`0x${address}`);
}
//# sourceMappingURL=publicKeyToAddress.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/signature/recoverPublicKey.js



async function recoverPublicKey({ hash, signature, }) {
    const hashHex = isHex(hash) ? hash : toHex(hash);
    const { secp256k1 } = await __webpack_require__.e(/* import() */ 2791).then(__webpack_require__.bind(__webpack_require__, 432791));
    const signature_ = (() => {
        // typeof signature: `Signature`
        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
            const { r, s, v, yParity } = signature;
            const yParityOrV = Number(yParity ?? v);
            const recoveryBit = toRecoveryBit(yParityOrV);
            return new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit);
        }
        // typeof signature: `Hex | ByteArray`
        const signatureHex = isHex(signature) ? signature : toHex(signature);
        const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
        const recoveryBit = toRecoveryBit(yParityOrV);
        return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_
        .recoverPublicKey(hashHex.substring(2))
        .toHex(false);
    return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1)
        return yParityOrV;
    if (yParityOrV === 27)
        return 0;
    if (yParityOrV === 28)
        return 1;
    throw new Error('Invalid yParityOrV value');
}
//# sourceMappingURL=recoverPublicKey.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/viem/_esm/utils/signature/recoverAddress.js


async function recoverAddress({ hash, signature, }) {
    return publicKeyToAddress(await recoverPublicKey({ hash: hash, signature }));
}
//# sourceMappingURL=recoverAddress.js.map
;// ./node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/utils/dist/index.es.js
const index_es_ae=":";function index_es_Ne(t){const[e,n]=t.split(index_es_ae);return{namespace:e,reference:n}}function dist_index_es_An(t){const{namespace:e,reference:n}=t;return[e,n].join(index_es_ae)}function dist_index_es_Ue(t){const[e,n,r]=t.split(index_es_ae);return{namespace:e,reference:n,address:r}}function dist_index_es_Bn(t){const{namespace:e,reference:n,address:r}=t;return[e,n,r].join(index_es_ae)}function dist_index_es_Te(t,e){const n=[];return t.forEach(r=>{const o=e(r);n.includes(o)||n.push(o)}),n}function dist_index_es_In(t){const{address:e}=dist_index_es_Ue(t);return e}function dist_index_es_Nn(t){const{namespace:e,reference:n}=dist_index_es_Ue(t);return dist_index_es_An({namespace:e,reference:n})}function dist_index_es_Ho(t,e){const{namespace:n,reference:r}=index_es_Ne(e);return dist_index_es_Bn({namespace:n,reference:r,address:t})}function dist_index_es_qo(t){return dist_index_es_Te(t,dist_index_es_In)}function dist_index_es_Un(t){return dist_index_es_Te(t,dist_index_es_Nn)}function dist_index_es_Ko(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...o.accounts)}),n}function dist_index_es_Fo(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...dist_index_es_Un(o.accounts))}),n}function dist_index_es_zo(t,e=[]){const n=[];return Object.keys(t).forEach(r=>{if(e.length&&!e.includes(r))return;const o=t[r];n.push(...dist_index_es_ue(r,o))}),n}function dist_index_es_ue(t,e){return t.includes(":")?[t]:e.chains||[]}var index_es_Zo=Object.defineProperty,dist_index_es_Yo=Object.defineProperties,dist_index_es_Go=Object.getOwnPropertyDescriptors,dist_index_es_Tn=Object.getOwnPropertySymbols,dist_index_es_Wo=Object.prototype.hasOwnProperty,dist_index_es_Xo=Object.prototype.propertyIsEnumerable,dist_index_es_Rn=(t,e,n)=>e in t?index_es_Zo(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,dist_index_es_n=(t,e)=>{for(var n in e||(e={}))dist_index_es_Wo.call(e,n)&&dist_index_es_Rn(t,n,e[n]);if(dist_index_es_Tn)for(var n of dist_index_es_Tn(e))dist_index_es_Xo.call(e,n)&&dist_index_es_Rn(t,n,e[n]);return t},dist_index_es_Jo=(t,e)=>dist_index_es_Yo(t,dist_index_es_Go(e));const dist_index_es_$n="ReactNative",dist_index_es_Y={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},index_es_fe=" ",index_es_Qo=":",dist_index_es_Ln="/",index_es_Re=2,dist_index_es_ti=1e3,dist_index_es_jn="js";function dist_index_es_e(){return typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"}function index_es_pt(){return!(0,dist_cjs.getDocument)()&&!!(0,dist_cjs.getNavigator)()&&navigator.product===dist_index_es_$n}function dist_index_es_ei(){return index_es_pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="android"}function dist_index_es_ni(){return index_es_pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="ios"}function dist_index_es_Tt(){return!dist_index_es_e()&&!!(0,dist_cjs.getNavigator)()&&!!(0,dist_cjs.getDocument)()}function dist_index_es_xt(){return index_es_pt()?dist_index_es_Y.reactNative:dist_index_es_e()?dist_index_es_Y.node:dist_index_es_Tt()?dist_index_es_Y.browser:dist_index_es_Y.unknown}function dist_index_es_ri(){var t;try{return index_es_pt()&&typeof global<"u"&&typeof(global==null?void 0:global.Application)<"u"?(t=global.Application)==null?void 0:t.applicationId:void 0}catch{return}}function dist_index_es_Cn(t,e){const n=new URLSearchParams(t);for(const r of Object.keys(e).sort())if(e.hasOwnProperty(r)){const o=e[r];o!==void 0&&n.set(r,o)}return n.toString()}function dist_index_es_oi(t){var e,n;const r=dist_index_es_Pn();try{return t!=null&&t.url&&r.url&&new URL(t.url).host!==new URL(r.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`),t.url=r.url),(e=t?.icons)!=null&&e.length&&t.icons.length>0&&(t.icons=t.icons.filter(o=>o!=="")),dist_index_es_Jo(dist_index_es_n(dist_index_es_n({},r),t),{url:t?.url||r.url,name:t?.name||r.name,description:t?.description||r.description,icons:(n=t?.icons)!=null&&n.length&&t.icons.length>0?t.icons:r.icons})}catch(o){return console.warn("Error populating app metadata",o),t||r}}function dist_index_es_Pn(){return (0,window_metadata_dist_cjs/* getWindowMetadata */.g)()||{name:"",description:"",url:"",icons:[""]}}function dist_index_es_ii(t,e){var n;const r=dist_index_es_xt(),o={protocol:t,version:e,env:r};return r==="browser"&&(o.host=((n=On())==null?void 0:n.host)||"unknown"),o}function dist_index_es_kn(){if(dist_index_es_xt()===dist_index_es_Y.reactNative&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"){const{OS:n,Version:r}=global.Platform;return[n,r].join("-")}const t=jo();if(t===null)return"unknown";const e=t.os?t.os.replace(" ","").toLowerCase():"unknown";return t.type==="browser"?[e,t.name,t.version].join("-"):[e,t.version].join("-")}function dist_index_es_Vn(){var t;const e=dist_index_es_xt();return e===dist_index_es_Y.browser?[e,((t=On())==null?void 0:t.host)||"unknown"].join(":"):e}function dist_index_es_Mn(t,e,n){const r=dist_index_es_kn(),o=dist_index_es_Vn();return[[t,e].join("-"),[dist_index_es_jn,n].join("-"),r,o].join("/")}function dist_index_es_si({protocol:t,version:e,relayUrl:n,sdkVersion:r,auth:o,projectId:i,useOnCloseEvent:s,bundleId:c,packageName:a}){const u=n.split("?"),l=dist_index_es_Mn(t,e,r),f={auth:o,ua:l,projectId:i,useOnCloseEvent:s||void 0,packageName:a||void 0,bundleId:c||void 0},h=dist_index_es_Cn(u[1]||"",f);return u[0]+"?"+h}function dist_index_es_ci(t){let e=(t.match(/^[^:]+(?=:\/\/)/gi)||[])[0];const n=typeof e<"u"?t.split("://")[1]:t;return e=e==="wss"?"https":"http",[e,n].join("://")}function dist_index_es_ai(t,e,n){if(!t[e]||typeof t[e]!==n)throw new Error(`Missing or invalid "${e}" param`)}function dist_index_es_Dn(t,e=index_es_Re){return dist_index_es_Hn(t.split(dist_index_es_Ln),e)}function dist_index_es_ui(t){return dist_index_es_Dn(t).join(index_es_fe)}function index_es_gt(t,e){return t.filter(n=>e.includes(n)).length===t.length}function dist_index_es_Hn(t,e=index_es_Re){return t.slice(Math.max(t.length-e,0))}function dist_index_es_fi(t){return Object.fromEntries(t.entries())}function dist_index_es_li(t){return new Map(Object.entries(t))}function dist_index_es_di(t,e){const n={};return Object.keys(t).forEach(r=>{n[r]=e(t[r])}),n}const dist_index_es_hi=t=>t;function dist_index_es_qn(t){return t.trim().replace(/^\w/,e=>e.toUpperCase())}function dist_index_es_pi(t){return t.split(index_es_fe).map(e=>dist_index_es_qn(e)).join(index_es_fe)}function dist_index_es_gi(t=cjs.FIVE_MINUTES,e){const n=(0,cjs.toMiliseconds)(t||cjs.FIVE_MINUTES);let r,o,i,s;return{resolve:c=>{i&&r&&(clearTimeout(i),r(c),s=Promise.resolve(c))},reject:c=>{i&&o&&(clearTimeout(i),o(c))},done:()=>new Promise((c,a)=>{if(s)return c(s);i=setTimeout(()=>{const u=new Error(e);s=Promise.reject(u),a(u)},n),r=c,o=a})}}function dist_index_es_yi(t,e,n){return new Promise(async(r,o)=>{const i=setTimeout(()=>o(new Error(n)),e);try{const s=await t;r(s)}catch(s){o(s)}clearTimeout(i)})}function index_es_$e(t,e){if(typeof e=="string"&&e.startsWith(`${t}:`))return e;if(t.toLowerCase()==="topic"){if(typeof e!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${e}`}else if(t.toLowerCase()==="id"){if(typeof e!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${e}`}throw new Error(`Unknown expirer target type: ${t}`)}function dist_index_es_mi(t){return index_es_$e("topic",t)}function dist_index_es_wi(t){return index_es_$e("id",t)}function dist_index_es_bi(t){const[e,n]=t.split(":"),r={id:void 0,topic:void 0};if(e==="topic"&&typeof n=="string")r.topic=n;else if(e==="id"&&Number.isInteger(Number(n)))r.id=Number(n);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`);return r}function dist_index_es_Ei(t,e){return (0,cjs.fromMiliseconds)((e||Date.now())+(0,cjs.toMiliseconds)(t))}function dist_index_es_vi(t){return Date.now()>=(0,cjs.toMiliseconds)(t)}function dist_index_es_xi(t,e){return`${t}${e?`:${e}`:""}`}function index_es_ot(t=[],e=[]){return[...new Set([...t,...e])]}async function dist_index_es_Si({id:t,topic:e,wcDeepLink:n}){var r;try{if(!n)return;const o=typeof n=="string"?JSON.parse(n):n,i=o?.href;if(typeof i!="string")return;const s=dist_index_es_Kn(i,t,e),c=dist_index_es_xt();if(c===dist_index_es_Y.browser){if(!((r=(0,dist_cjs.getDocument)())!=null&&r.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}dist_index_es_Fn(s)}else c===dist_index_es_Y.reactNative&&typeof(global==null?void 0:global.Linking)<"u"&&await global.Linking.openURL(s)}catch(o){console.error(o)}}function dist_index_es_Kn(t,e,n){const r=`requestId=${e}&sessionTopic=${n}`;t.endsWith("/")&&(t=t.slice(0,-1));let o=`${t}`;if(t.startsWith("https://t.me")){const i=t.includes("?")?"&startapp=":"?startapp=";o=`${o}${i}${dist_index_es_Yn(r,!0)}`}else o=`${o}/wc?${r}`;return o}function dist_index_es_Fn(t){let e="_self";dist_index_es_Zn()?e="_top":(dist_index_es_zn()||t.startsWith("https://")||t.startsWith("http://"))&&(e="_blank"),window.open(t,e,"noreferrer noopener")}async function dist_index_es_Oi(t,e){let n="";try{if(dist_index_es_Tt()&&(n=localStorage.getItem(e),n))return n;n=await t.getItem(e)}catch(r){console.error(r)}return n}function dist_index_es_Le(t,e){return t.filter(n=>e.includes(n))}function dist_index_es_Ai(t,e){if(!t.includes(e))return null;const n=t.split(/([&,?,=])/),r=n.indexOf(e);return n[r+2]}function dist_index_es_Bi(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,t=>{const e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)})}function dist_index_es_Ii(){return typeof process<"u"&&process.env.IS_VITEST==="true"}function dist_index_es_zn(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function dist_index_es_Zn(){try{return window.self!==window.top}catch{return!1}}function dist_index_es_Yn(t,e=!1){const n=Buffer.from(t).toString("base64");return e?n.replace(/[=]/g,""):n}function dist_index_es_je(t){return Buffer.from(t,"base64").toString("utf-8")}function dist_index_es_Ni(t){return new Promise(e=>setTimeout(e,t))}function dist_index_es_Wt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function dist_index_es_Ui(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function dist_index_es_Xt(t,...e){if(!dist_index_es_Ui(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function dist_index_es_Ce(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");dist_index_es_Wt(t.outputLen),dist_index_es_Wt(t.blockLen)}function dist_index_es_Rt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function dist_index_es_Gn(t,e){dist_index_es_Xt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const dist_index_es_le=BigInt(2**32-1),dist_index_es_Wn=BigInt(32);function dist_index_es_Ti(t,e=!1){return e?{h:Number(t&dist_index_es_le),l:Number(t>>dist_index_es_Wn&dist_index_es_le)}:{h:Number(t>>dist_index_es_Wn&dist_index_es_le)|0,l:Number(t&dist_index_es_le)|0}}function dist_index_es_Ri(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=dist_index_es_Ti(t[o],e);[n[o],r[o]]=[i,s]}return[n,r]}const dist_index_es_i=(t,e,n)=>t<<n|e>>>32-n,dist_index_es_$i=(t,e,n)=>e<<n|t>>>32-n,dist_index_es_Li=(t,e,n)=>e<<n-32|t>>>64-n,dist_index_es_ji=(t,e,n)=>t<<n-32|e>>>64-n,index_es_t=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function dist_index_es_Ci(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function index_es_Pe(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function index_es_ct(t,e){return t<<32-e|t>>>e}const dist_index_es_Xn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function dist_index_es_Pi(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}function dist_index_es_Jn(t){for(let e=0;e<t.length;e++)t[e]=dist_index_es_Pi(t[e])}function dist_index_es_ki(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function dist_index_es_$t(t){return typeof t=="string"&&(t=dist_index_es_ki(t)),dist_index_es_Xt(t),t}function dist_index_es_Vi(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];dist_index_es_Xt(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}class dist_index_es_ke{clone(){return this._cloneInto()}}function dist_index_es_Qn(t){const e=r=>t().update(dist_index_es_$t(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function dist_index_es_Lt(t=32){if(index_es_t&&typeof index_es_t.getRandomValues=="function")return index_es_t.getRandomValues(new Uint8Array(t));if(index_es_t&&typeof index_es_t.randomBytes=="function")return index_es_t.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}const dist_index_es_tr=[],dist_index_es_er=[],dist_index_es_nr=[],dist_index_es_Mi=BigInt(0),dist_index_es_Jt=BigInt(1),dist_index_es_Di=BigInt(2),index_es_Hi=BigInt(7),dist_index_es_qi=BigInt(256),dist_index_es_Ki=BigInt(113);for(let t=0,e=dist_index_es_Jt,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],dist_index_es_tr.push(2*(5*r+n)),dist_index_es_er.push((t+1)*(t+2)/2%64);let o=dist_index_es_Mi;for(let i=0;i<7;i++)e=(e<<dist_index_es_Jt^(e>>index_es_Hi)*dist_index_es_Ki)%dist_index_es_qi,e&dist_index_es_Di&&(o^=dist_index_es_Jt<<(dist_index_es_Jt<<BigInt(i))-dist_index_es_Jt);dist_index_es_nr.push(o)}const[dist_index_es_Fi,dist_index_es_zi]=dist_index_es_Ri(dist_index_es_nr,!0),dist_index_es_rr=(t,e,n)=>n>32?dist_index_es_Li(t,e,n):dist_index_es_i(t,e,n),dist_index_es_or=(t,e,n)=>n>32?dist_index_es_ji(t,e,n):dist_index_es_$i(t,e,n);function index_es_Zi(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let s=0;s<10;s++)n[s]=t[s]^t[s+10]^t[s+20]^t[s+30]^t[s+40];for(let s=0;s<10;s+=2){const c=(s+8)%10,a=(s+2)%10,u=n[a],l=n[a+1],f=dist_index_es_rr(u,l,1)^n[c],h=dist_index_es_or(u,l,1)^n[c+1];for(let y=0;y<50;y+=10)t[s+y]^=f,t[s+y+1]^=h}let o=t[2],i=t[3];for(let s=0;s<24;s++){const c=dist_index_es_er[s],a=dist_index_es_rr(o,i,c),u=dist_index_es_or(o,i,c),l=dist_index_es_tr[s];o=t[l],i=t[l+1],t[l]=a,t[l+1]=u}for(let s=0;s<50;s+=10){for(let c=0;c<10;c++)n[c]=t[s+c];for(let c=0;c<10;c++)t[s+c]^=~n[(c+2)%10]&n[(c+4)%10]}t[0]^=dist_index_es_Fi[r],t[1]^=dist_index_es_zi[r]}n.fill(0)}class dist_index_es_En extends dist_index_es_ke{constructor(e,n,r,o=!1,i=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,dist_index_es_Wt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=dist_index_es_Ci(this.state)}keccak(){dist_index_es_Xn||dist_index_es_Jn(this.state32),index_es_Zi(this.state32,this.rounds),dist_index_es_Xn||dist_index_es_Jn(this.state32),this.posOut=0,this.pos=0}update(e){dist_index_es_Rt(this);const{blockLen:n,state:r}=this;e=dist_index_es_$t(e);const o=e.length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);for(let c=0;c<s;c++)r[this.pos++]^=e[i++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:r,blockLen:o}=this;e[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){dist_index_es_Rt(this,!1),dist_index_es_Xt(e),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,i=e.length;o<i;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,i-o);e.set(n.subarray(this.posOut,this.posOut+s),o),this.posOut+=s,o+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return dist_index_es_Wt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(dist_index_es_Gn(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:n,suffix:r,outputLen:o,rounds:i,enableXOF:s}=this;return e||(e=new dist_index_es_En(n,r,o,s,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=o,e.enableXOF=s,e.destroyed=this.destroyed,e}}const index_es_Yi=(t,e,n)=>dist_index_es_Qn(()=>new dist_index_es_En(e,t,n)),index_es_Gi=index_es_Yi(1,136,256/8),index_es_Wi="https://rpc.walletconnect.org/v1";function dist_index_es_Ve(t){const e=`Ethereum Signed Message:
${t.length}`,n=new TextEncoder().encode(e+t);return"0x"+Buffer.from(index_es_Gi(n)).toString("hex")}async function dist_index_es_ir(t,e,n,r,o,i){switch(n.t){case"eip191":return await dist_index_es_sr(t,e,n.s);case"eip1271":return await dist_index_es_cr(t,e,n.s,r,o,i);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`)}}async function dist_index_es_sr(t,e,n){return(await recoverAddress({hash:dist_index_es_Ve(e),signature:n})).toLowerCase()===t.toLowerCase()}async function dist_index_es_cr(t,e,n,r,o,i){const s=index_es_Ne(r);if(!s.namespace||!s.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);try{const c="0x1626ba7e",a="0000000000000000000000000000000000000000000000000000000000000040",u="0000000000000000000000000000000000000000000000000000000000000041",l=n.substring(2),f=dist_index_es_Ve(e).substring(2),h=c+f+a+u+l,y=await fetch(`${i||index_es_Wi}/?chainId=${r}&projectId=${o}`,{method:"POST",body:JSON.stringify({id:index_es_Xi(),jsonrpc:"2.0",method:"eth_call",params:[{to:t,data:h},"latest"]})}),{result:E}=await y.json();return E?E.slice(0,c.length).toLowerCase()===c.toLowerCase():!1}catch(c){return console.error("isValidEip1271Signature: ",c),!1}}function index_es_Xi(){return Date.now()+Math.floor(Math.random()*1e3)}function index_es_Ji(t){const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);const r=n[0];if(r===0)throw new Error("No signatures found");const o=1+r*64;if(n.length<o)throw new Error("Transaction data too short for claimed signature count");if(n.length<100)throw new Error("Transaction too short");const i=Buffer.from(t,"base64").slice(1,65);return src_esm/* default */.A.encode(i)}var index_es_Qi=Object.defineProperty,index_es_ts=Object.defineProperties,dist_index_es_es=Object.getOwnPropertyDescriptors,dist_index_es_ar=Object.getOwnPropertySymbols,index_es_ns=Object.prototype.hasOwnProperty,index_es_rs=Object.prototype.propertyIsEnumerable,dist_index_es_ur=(t,e,n)=>e in t?index_es_Qi(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,dist_index_es_Me=(t,e)=>{for(var n in e||(e={}))index_es_ns.call(e,n)&&dist_index_es_ur(t,n,e[n]);if(dist_index_es_ar)for(var n of dist_index_es_ar(e))index_es_rs.call(e,n)&&dist_index_es_ur(t,n,e[n]);return t},dist_index_es_fr=(t,e)=>index_es_ts(t,dist_index_es_es(e));const index_es_os="did:pkh:",dist_index_es_de=t=>t?.split(":"),dist_index_es_lr=t=>{const e=t&&dist_index_es_de(t);if(e)return t.includes(index_es_os)?e[3]:e[1]},dist_index_es_dr=t=>{const e=t&&dist_index_es_de(t);if(e)return e[2]+":"+e[3]},index_es_De=t=>{const e=t&&dist_index_es_de(t);if(e)return e.pop()};async function index_es_is(t){const{cacao:e,projectId:n}=t,{s:r,p:o}=e,i=dist_index_es_hr(o,o.iss),s=index_es_De(o.iss);return await dist_index_es_ir(s,i,r,dist_index_es_dr(o.iss),n)}const dist_index_es_hr=(t,e)=>{const n=`${t.domain} wants you to sign in with your Ethereum account:`,r=index_es_De(e);if(!t.aud&&!t.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let o=t.statement||void 0;const i=`URI: ${t.aud||t.uri}`,s=`Version: ${t.version}`,c=`Chain ID: ${dist_index_es_lr(e)}`,a=`Nonce: ${t.nonce}`,u=`Issued At: ${t.iat}`,l=t.exp?`Expiration Time: ${t.exp}`:void 0,f=t.nbf?`Not Before: ${t.nbf}`:void 0,h=t.requestId?`Request ID: ${t.requestId}`:void 0,y=t.resources?`Resources:${t.resources.map(p=>`
- ${p}`).join("")}`:void 0,E=dist_index_es_pe(t.resources);if(E){const p=index_es_yt(E);o=dist_index_es_Ke(o,p)}return[n,r,"",o,"",i,s,c,a,u,l,f,h,y].filter(p=>p!=null).join(`
`)};function index_es_ss(t,e,n){return n.includes("did:pkh:")||(n=`did:pkh:${n}`),{h:{t:"caip122"},p:{iss:n,domain:t.domain,aud:t.aud,version:t.version,nonce:t.nonce,iat:t.iat,statement:t.statement,requestId:t.requestId,resources:t.resources,nbf:t.nbf,exp:t.exp},s:e}}function index_es_cs(t){var e;const{authPayload:n,chains:r,methods:o}=t,i=n.statement||"";if(!(r!=null&&r.length))return n;const s=n.chains,c=dist_index_es_Le(s,r);if(!(c!=null&&c.length))throw new Error("No supported chains");const a=dist_index_es_pr(n.resources);if(!a)return n;index_es_at(a);const u=dist_index_es_gr(a,"eip155");let l=n?.resources||[];if(u!=null&&u.length){const f=dist_index_es_yr(u),h=dist_index_es_Le(f,o);if(!(h!=null&&h.length))throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f)}, supported: ${JSON.stringify(o)}`);const y=dist_index_es_He("request",h,{chains:c}),E=dist_index_es_Er(a,"eip155",y);l=((e=n?.resources)==null?void 0:e.slice(0,-1))||[],l.push(dist_index_es_he(E))}return dist_index_es_fr(dist_index_es_Me({},n),{statement:dist_index_es_xr(i,dist_index_es_pe(l)),chains:c,resources:n!=null&&n.resources||l.length>0?l:void 0})}function dist_index_es_pr(t){const e=dist_index_es_pe(t);if(e&&dist_index_es_qe(e))return index_es_yt(e)}function index_es_as(t,e){var n;return(n=t?.att)==null?void 0:n.hasOwnProperty(e)}function dist_index_es_gr(t,e){var n,r;return(n=t?.att)!=null&&n[e]?Object.keys((r=t?.att)==null?void 0:r[e]):[]}function index_es_us(t){return t?.map(e=>Object.keys(e))||[]}function dist_index_es_yr(t){return t?.map(e=>{var n;return(n=e.split("/"))==null?void 0:n[1]})||[]}function dist_index_es_mr(t){return Buffer.from(JSON.stringify(t)).toString("base64")}function dist_index_es_wr(t){return JSON.parse(Buffer.from(t,"base64").toString("utf-8"))}function index_es_at(t){if(!t)throw new Error("No recap provided, value is undefined");if(!t.att)throw new Error("No `att` property found");const e=Object.keys(t.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(n=>{const r=t.att[n];if(Array.isArray(r))throw new Error(`Resource must be an object: ${n}`);if(typeof r!="object")throw new Error(`Resource must be an object: ${n}`);if(!Object.keys(r).length)throw new Error(`Resource object is empty: ${n}`);Object.keys(r).forEach(o=>{const i=r[o];if(!Array.isArray(i))throw new Error(`Ability limits ${o} must be an array of objects, found: ${i}`);if(!i.length)throw new Error(`Value of ${o} is empty array, must be an array with objects`);i.forEach(s=>{if(typeof s!="object")throw new Error(`Ability limits (${o}) must be an array of objects, found: ${s}`)})})})}function dist_index_es_br(t,e,n,r={}){return n?.sort((o,i)=>o.localeCompare(i)),{att:{[t]:dist_index_es_He(e,n,r)}}}function dist_index_es_Er(t,e,n){var r;t.att[e]=dist_index_es_Me({},n);const o=(r=Object.keys(t.att))==null?void 0:r.sort((s,c)=>s.localeCompare(c)),i={att:{}};return o.reduce((s,c)=>(s.att[c]=t.att[c],s),i)}function dist_index_es_He(t,e,n={}){e=e?.sort((o,i)=>o.localeCompare(i));const r=e.map(o=>({[`${t}/${o}`]:[n]}));return Object.assign({},...r)}function dist_index_es_he(t){return index_es_at(t),`urn:recap:${dist_index_es_mr(t).replace(/=/g,"")}`}function index_es_yt(t){const e=dist_index_es_wr(t.replace("urn:recap:",""));return index_es_at(e),e}function index_es_fs(t,e,n){const r=dist_index_es_br(t,e,n);return dist_index_es_he(r)}function dist_index_es_qe(t){return t&&t.includes("urn:recap:")}function index_es_ls(t,e){const n=index_es_yt(t),r=index_es_yt(e),o=dist_index_es_vr(n,r);return dist_index_es_he(o)}function dist_index_es_vr(t,e){index_es_at(t),index_es_at(e);const n=Object.keys(t.att).concat(Object.keys(e.att)).sort((o,i)=>o.localeCompare(i)),r={att:{}};return n.forEach(o=>{var i,s;Object.keys(((i=t.att)==null?void 0:i[o])||{}).concat(Object.keys(((s=e.att)==null?void 0:s[o])||{})).sort((c,a)=>c.localeCompare(a)).forEach(c=>{var a,u;r.att[o]=dist_index_es_fr(dist_index_es_Me({},r.att[o]),{[c]:((a=t.att[o])==null?void 0:a[c])||((u=e.att[o])==null?void 0:u[c])})})}),r}function dist_index_es_Ke(t="",e){index_es_at(e);const n="I further authorize the stated URI to perform the following actions on my behalf: ";if(t.includes(n))return t;const r=[];let o=0;Object.keys(e.att).forEach(c=>{const a=Object.keys(e.att[c]).map(f=>({ability:f.split("/")[0],action:f.split("/")[1]}));a.sort((f,h)=>f.action.localeCompare(h.action));const u={};a.forEach(f=>{u[f.ability]||(u[f.ability]=[]),u[f.ability].push(f.action)});const l=Object.keys(u).map(f=>(o++,`(${o}) '${f}': '${u[f].join("', '")}' for '${c}'.`));r.push(l.join(", ").replace(".,","."))});const i=r.join(" "),s=`${n}${i}`;return`${t?t+" ":""}${s}`}function index_es_ds(t){var e;const n=index_es_yt(t);index_es_at(n);const r=(e=n.att)==null?void 0:e.eip155;return r?Object.keys(r).map(o=>o.split("/")[1]):[]}function index_es_hs(t){const e=index_es_yt(t);index_es_at(e);const n=[];return Object.values(e.att).forEach(r=>{Object.values(r).forEach(o=>{var i;(i=o?.[0])!=null&&i.chains&&n.push(o[0].chains)})}),[...new Set(n.flat())]}function dist_index_es_xr(t,e){if(!e)return t;const n=index_es_yt(e);return index_es_at(n),dist_index_es_Ke(t,n)}function dist_index_es_pe(t){if(!t)return;const e=t?.[t.length-1];return dist_index_es_qe(e)?e:void 0}function dist_index_es_Fe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function dist_index_es_Sr(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function index_es_tt(t,...e){if(!dist_index_es_Sr(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function dist_index_es_Or(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function index_es_ps(t,e){index_es_tt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function dist_index_es_Ar(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}const index_es_mt=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),index_es_gs=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),index_es_ys=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!index_es_ys)throw new Error("Non little-endian hardware is not supported");function index_es_ms(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function dist_index_es_ze(t){if(typeof t=="string")t=index_es_ms(t);else if(dist_index_es_Sr(t))t=dist_index_es_Ze(t);else throw new Error("Uint8Array expected, got "+typeof t);return t}function index_es_ws(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function index_es_bs(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const index_es_Es=(t,e)=>{function n(r,...o){if(index_es_tt(r),t.nonceLength!==void 0){const l=o[0];if(!l)throw new Error("nonce / iv required");t.varSizeNonce?index_es_tt(l):index_es_tt(l,t.nonceLength)}const i=t.tagLength;i&&o[1]!==void 0&&index_es_tt(o[1]);const s=e(r,...o),c=(l,f)=>{if(f!==void 0){if(l!==2)throw new Error("cipher output not supported");index_es_tt(f)}};let a=!1;return{encrypt(l,f){if(a)throw new Error("cannot encrypt() twice with same key + nonce");return a=!0,index_es_tt(l),c(s.encrypt.length,f),s.encrypt(l,f)},decrypt(l,f){if(index_es_tt(l),i&&l.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return c(s.decrypt.length,f),s.decrypt(l,f)}}}return Object.assign(n,t),n};function dist_index_es_Br(t,e,n=!0){if(e===void 0)return new Uint8Array(t);if(e.length!==t)throw new Error("invalid output length, expected "+t+", got: "+e.length);if(n&&!index_es_vs(e))throw new Error("invalid output, must be aligned");return e}function dist_index_es_Ir(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,u=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+u,c,r)}function index_es_vs(t){return t.byteOffset%4===0}function dist_index_es_Ze(t){return Uint8Array.from(t)}function dist_index_es_jt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}const dist_index_es_Nr=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),index_es_xs=dist_index_es_Nr("expand 16-byte k"),index_es_Ss=dist_index_es_Nr("expand 32-byte k"),index_es_Os=index_es_mt(index_es_xs),index_es_As=index_es_mt(index_es_Ss);function utils_dist_index_es_V(t,e){return t<<e|t>>>32-e}function dist_index_es_Ye(t){return t.byteOffset%4===0}const dist_index_es_ge=64,index_es_Bs=16,dist_index_es_Ur=2**32-1,dist_index_es_Tr=new Uint32Array;function index_es_Is(t,e,n,r,o,i,s,c){const a=o.length,u=new Uint8Array(dist_index_es_ge),l=index_es_mt(u),f=dist_index_es_Ye(o)&&dist_index_es_Ye(i),h=f?index_es_mt(o):dist_index_es_Tr,y=f?index_es_mt(i):dist_index_es_Tr;for(let E=0;E<a;s++){if(t(e,n,r,l,s,c),s>=dist_index_es_Ur)throw new Error("arx: counter overflow");const p=Math.min(dist_index_es_ge,a-E);if(f&&p===dist_index_es_ge){const d=E/4;if(E%4!==0)throw new Error("arx: invalid block position");for(let v=0,m;v<index_es_Bs;v++)m=d+v,y[m]=h[m]^l[v];E+=dist_index_es_ge;continue}for(let d=0,v;d<p;d++)v=E+d,i[v]=o[v]^u[d];E+=p}}function index_es_Ns(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:i,rounds:s}=index_es_ws({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return dist_index_es_Fe(o),dist_index_es_Fe(s),dist_index_es_Ar(i),dist_index_es_Ar(n),(c,a,u,l,f=0)=>{index_es_tt(c),index_es_tt(a),index_es_tt(u);const h=u.length;if(l===void 0&&(l=new Uint8Array(h)),index_es_tt(l),dist_index_es_Fe(f),f<0||f>=dist_index_es_Ur)throw new Error("arx: counter overflow");if(l.length<h)throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);const y=[];let E=c.length,p,d;if(E===32)y.push(p=dist_index_es_Ze(c)),d=index_es_As;else if(E===16&&n)p=new Uint8Array(32),p.set(c),p.set(c,16),d=index_es_Os,y.push(p);else throw new Error(`arx: invalid 32-byte key, got length=${E}`);dist_index_es_Ye(a)||y.push(a=dist_index_es_Ze(a));const v=index_es_mt(p);if(r){if(a.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,v,index_es_mt(a.subarray(0,16)),v),a=a.subarray(16)}const m=16-o;if(m!==a.length)throw new Error(`arx: nonce must be ${m} or 16 bytes`);if(m!==12){const N=new Uint8Array(12);N.set(a,i?0:12-a.length),a=N,y.push(a)}const O=index_es_mt(a);return index_es_Is(t,d,v,O,u,l,f,s),dist_index_es_jt(...y),l}}const dist_index_es_F=(t,e)=>t[e++]&255|(t[e++]&255)<<8;class index_es_Us{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=dist_index_es_ze(e),index_es_tt(e,32);const n=dist_index_es_F(e,0),r=dist_index_es_F(e,2),o=dist_index_es_F(e,4),i=dist_index_es_F(e,6),s=dist_index_es_F(e,8),c=dist_index_es_F(e,10),a=dist_index_es_F(e,12),u=dist_index_es_F(e,14);this.r[0]=n&8191,this.r[1]=(n>>>13|r<<3)&8191,this.r[2]=(r>>>10|o<<6)&7939,this.r[3]=(o>>>7|i<<9)&8191,this.r[4]=(i>>>4|s<<12)&255,this.r[5]=s>>>1&8190,this.r[6]=(s>>>14|c<<2)&8191,this.r[7]=(c>>>11|a<<5)&8065,this.r[8]=(a>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let l=0;l<8;l++)this.pad[l]=dist_index_es_F(e,16+2*l)}process(e,n,r=!1){const o=r?0:2048,{h:i,r:s}=this,c=s[0],a=s[1],u=s[2],l=s[3],f=s[4],h=s[5],y=s[6],E=s[7],p=s[8],d=s[9],v=dist_index_es_F(e,n+0),m=dist_index_es_F(e,n+2),O=dist_index_es_F(e,n+4),N=dist_index_es_F(e,n+6),$=dist_index_es_F(e,n+8),B=dist_index_es_F(e,n+10),A=dist_index_es_F(e,n+12),T=dist_index_es_F(e,n+14);let S=i[0]+(v&8191),L=i[1]+((v>>>13|m<<3)&8191),U=i[2]+((m>>>10|O<<6)&8191),_=i[3]+((O>>>7|N<<9)&8191),j=i[4]+((N>>>4|$<<12)&8191),g=i[5]+($>>>1&8191),w=i[6]+(($>>>14|B<<2)&8191),b=i[7]+((B>>>11|A<<5)&8191),I=i[8]+((A>>>8|T<<8)&8191),R=i[9]+(T>>>5|o),x=0,C=x+S*c+L*(5*d)+U*(5*p)+_*(5*E)+j*(5*y);x=C>>>13,C&=8191,C+=g*(5*h)+w*(5*f)+b*(5*l)+I*(5*u)+R*(5*a),x+=C>>>13,C&=8191;let P=x+S*a+L*c+U*(5*d)+_*(5*p)+j*(5*E);x=P>>>13,P&=8191,P+=g*(5*y)+w*(5*h)+b*(5*f)+I*(5*l)+R*(5*u),x+=P>>>13,P&=8191;let k=x+S*u+L*a+U*c+_*(5*d)+j*(5*p);x=k>>>13,k&=8191,k+=g*(5*E)+w*(5*y)+b*(5*h)+I*(5*f)+R*(5*l),x+=k>>>13,k&=8191;let M=x+S*l+L*u+U*a+_*c+j*(5*d);x=M>>>13,M&=8191,M+=g*(5*p)+w*(5*E)+b*(5*y)+I*(5*h)+R*(5*f),x+=M>>>13,M&=8191;let D=x+S*f+L*l+U*u+_*a+j*c;x=D>>>13,D&=8191,D+=g*(5*d)+w*(5*p)+b*(5*E)+I*(5*y)+R*(5*h),x+=D>>>13,D&=8191;let z=x+S*h+L*f+U*l+_*u+j*a;x=z>>>13,z&=8191,z+=g*c+w*(5*d)+b*(5*p)+I*(5*E)+R*(5*y),x+=z>>>13,z&=8191;let Z=x+S*y+L*h+U*f+_*l+j*u;x=Z>>>13,Z&=8191,Z+=g*a+w*c+b*(5*d)+I*(5*p)+R*(5*E),x+=Z>>>13,Z&=8191;let st=x+S*E+L*y+U*h+_*f+j*l;x=st>>>13,st&=8191,st+=g*u+w*a+b*c+I*(5*d)+R*(5*p),x+=st>>>13,st&=8191;let W=x+S*p+L*E+U*y+_*h+j*f;x=W>>>13,W&=8191,W+=g*l+w*u+b*a+I*c+R*(5*d),x+=W>>>13,W&=8191;let J=x+S*d+L*p+U*E+_*y+j*h;x=J>>>13,J&=8191,J+=g*f+w*l+b*u+I*a+R*c,x+=J>>>13,J&=8191,x=(x<<2)+x|0,x=x+C|0,C=x&8191,x=x>>>13,P+=x,i[0]=C,i[1]=P,i[2]=k,i[3]=M,i[4]=D,i[5]=z,i[6]=Z,i[7]=st,i[8]=W,i[9]=J}finalize(){const{h:e,pad:n}=this,r=new Uint16Array(10);let o=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=o,o=e[c]>>>13,e[c]&=8191;e[0]+=o*5,o=e[0]>>>13,e[0]&=8191,e[1]+=o,o=e[1]>>>13,e[1]&=8191,e[2]+=o,r[0]=e[0]+5,o=r[0]>>>13,r[0]&=8191;for(let c=1;c<10;c++)r[c]=e[c]+o,o=r[c]>>>13,r[c]&=8191;r[9]-=8192;let i=(o^1)-1;for(let c=0;c<10;c++)r[c]&=i;i=~i;for(let c=0;c<10;c++)e[c]=e[c]&i|r[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let s=e[0]+n[0];e[0]=s&65535;for(let c=1;c<8;c++)s=(e[c]+n[c]|0)+(s>>>16)|0,e[c]=s&65535;dist_index_es_jt(r)}update(e){dist_index_es_Or(this);const{buffer:n,blockLen:r}=this;e=dist_index_es_ze(e);const o=e.length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s===r){for(;r<=o-i;i+=r)this.process(e,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(n,0,!1),this.pos=0)}return this}destroy(){dist_index_es_jt(this.h,this.r,this.buffer,this.pad)}digestInto(e){dist_index_es_Or(this),index_es_ps(e,this),this.finished=!0;const{buffer:n,h:r}=this;let{pos:o}=this;if(o){for(n[o++]=1;o<16;o++)n[o]=0;this.process(n,0,!0)}this.finalize();let i=0;for(let s=0;s<8;s++)e[i++]=r[s]>>>0,e[i++]=r[s]>>>8;return e}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}}function index_es_Ts(t){const e=(r,o)=>t(o).update(dist_index_es_ze(r)).digest(),n=t(new Uint8Array(32));return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}const index_es_Rs=index_es_Ts(t=>new index_es_Us(t));function index_es_s(t,e,n,r,o,i=20){let s=t[0],c=t[1],a=t[2],u=t[3],l=e[0],f=e[1],h=e[2],y=e[3],E=e[4],p=e[5],d=e[6],v=e[7],m=o,O=n[0],N=n[1],$=n[2],B=s,A=c,T=a,S=u,L=l,U=f,_=h,j=y,g=E,w=p,b=d,I=v,R=m,x=O,C=N,P=$;for(let M=0;M<i;M+=2)B=B+L|0,R=utils_dist_index_es_V(R^B,16),g=g+R|0,L=utils_dist_index_es_V(L^g,12),B=B+L|0,R=utils_dist_index_es_V(R^B,8),g=g+R|0,L=utils_dist_index_es_V(L^g,7),A=A+U|0,x=utils_dist_index_es_V(x^A,16),w=w+x|0,U=utils_dist_index_es_V(U^w,12),A=A+U|0,x=utils_dist_index_es_V(x^A,8),w=w+x|0,U=utils_dist_index_es_V(U^w,7),T=T+_|0,C=utils_dist_index_es_V(C^T,16),b=b+C|0,_=utils_dist_index_es_V(_^b,12),T=T+_|0,C=utils_dist_index_es_V(C^T,8),b=b+C|0,_=utils_dist_index_es_V(_^b,7),S=S+j|0,P=utils_dist_index_es_V(P^S,16),I=I+P|0,j=utils_dist_index_es_V(j^I,12),S=S+j|0,P=utils_dist_index_es_V(P^S,8),I=I+P|0,j=utils_dist_index_es_V(j^I,7),B=B+U|0,P=utils_dist_index_es_V(P^B,16),b=b+P|0,U=utils_dist_index_es_V(U^b,12),B=B+U|0,P=utils_dist_index_es_V(P^B,8),b=b+P|0,U=utils_dist_index_es_V(U^b,7),A=A+_|0,R=utils_dist_index_es_V(R^A,16),I=I+R|0,_=utils_dist_index_es_V(_^I,12),A=A+_|0,R=utils_dist_index_es_V(R^A,8),I=I+R|0,_=utils_dist_index_es_V(_^I,7),T=T+j|0,x=utils_dist_index_es_V(x^T,16),g=g+x|0,j=utils_dist_index_es_V(j^g,12),T=T+j|0,x=utils_dist_index_es_V(x^T,8),g=g+x|0,j=utils_dist_index_es_V(j^g,7),S=S+L|0,C=utils_dist_index_es_V(C^S,16),w=w+C|0,L=utils_dist_index_es_V(L^w,12),S=S+L|0,C=utils_dist_index_es_V(C^S,8),w=w+C|0,L=utils_dist_index_es_V(L^w,7);let k=0;r[k++]=s+B|0,r[k++]=c+A|0,r[k++]=a+T|0,r[k++]=u+S|0,r[k++]=l+L|0,r[k++]=f+U|0,r[k++]=h+_|0,r[k++]=y+j|0,r[k++]=E+g|0,r[k++]=p+w|0,r[k++]=d+b|0,r[k++]=v+I|0,r[k++]=m+R|0,r[k++]=O+x|0,r[k++]=N+C|0,r[k++]=$+P|0}const index_es_$s=index_es_Ns(index_es_s,{counterRight:!1,counterLength:4,allowShortKeys:!1}),index_es_Ls=new Uint8Array(16),dist_index_es_Rr=(t,e)=>{t.update(e);const n=e.length%16;n&&t.update(index_es_Ls.subarray(n))},index_es_js=new Uint8Array(32);function dist_index_es_r(t,e,n,r,o){const i=t(e,n,index_es_js),s=index_es_Rs.create(i);o&&dist_index_es_Rr(s,o),dist_index_es_Rr(s,r);const c=new Uint8Array(16),a=index_es_gs(c);dist_index_es_Ir(a,0,BigInt(o?o.length:0),!0),dist_index_es_Ir(a,8,BigInt(r.length),!0),s.update(c);const u=s.digest();return dist_index_es_jt(i,c),u}const index_es_Cs=t=>(e,n,r)=>({encrypt(i,s){const c=i.length;s=dist_index_es_Br(c+16,s,!1),s.set(i);const a=s.subarray(0,-16);t(e,n,a,a,1);const u=dist_index_es_r(t,e,n,a,r);return s.set(u,c),dist_index_es_jt(u),s},decrypt(i,s){s=dist_index_es_Br(i.length-16,s,!1);const c=i.subarray(0,-16),a=i.subarray(-16),u=dist_index_es_r(t,e,n,c,r);if(!index_es_bs(a,u))throw new Error("invalid tag");return s.set(i.subarray(0,-16)),t(e,n,s,s,1),dist_index_es_jt(u),s}}),dist_index_es_$r=index_es_Es({blockSize:64,nonceLength:12,tagLength:16},index_es_Cs(index_es_$s));class dist_index_es_Lr extends dist_index_es_ke{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,dist_index_es_Ce(e);const r=dist_index_es_$t(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?e.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(e){return dist_index_es_Rt(this),this.iHash.update(e),this}digestInto(e){dist_index_es_Rt(this),dist_index_es_Xt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=s,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const dist_index_es_ye=(t,e,n)=>new dist_index_es_Lr(t,e).update(n).digest();dist_index_es_ye.create=(t,e)=>new dist_index_es_Lr(t,e);function index_es_Ps(t,e,n){return dist_index_es_Ce(t),n===void 0&&(n=new Uint8Array(t.outputLen)),dist_index_es_ye(t,dist_index_es_$t(n),dist_index_es_$t(e))}const dist_index_es_Ge=new Uint8Array([0]),dist_index_es_jr=new Uint8Array;function index_es_ks(t,e,n,r=32){if(dist_index_es_Ce(t),dist_index_es_Wt(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/t.outputLen);n===void 0&&(n=dist_index_es_jr);const i=new Uint8Array(o*t.outputLen),s=dist_index_es_ye.create(t,e),c=s._cloneInto(),a=new Uint8Array(s.outputLen);for(let u=0;u<o;u++)dist_index_es_Ge[0]=u+1,c.update(u===0?dist_index_es_jr:a).update(n).update(dist_index_es_Ge).digestInto(a),i.set(a,t.outputLen*u),s._cloneInto(c);return s.destroy(),c.destroy(),a.fill(0),dist_index_es_Ge.fill(0),i.slice(0,r)}const index_es_Vs=(t,e,n,r,o)=>index_es_ks(t,index_es_Ps(t,e,n),r,o);function index_es_Ms(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,u=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+u,c,r)}function index_es_Ds(t,e,n){return t&e^~t&n}function dist_index_es_Hs(t,e,n){return t&e^t&n^e&n}class index_es_qs extends dist_index_es_ke{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=index_es_Pe(this.buffer)}update(e){dist_index_es_Rt(this);const{view:n,buffer:r,blockLen:o}=this;e=dist_index_es_$t(e);const i=e.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=index_es_Pe(e);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(e.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){dist_index_es_Rt(this),dist_index_es_Gn(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let f=s;f<o;f++)n[f]=0;index_es_Ms(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=index_es_Pe(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)c.setUint32(4*f,l[f],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=s,o%n&&e.buffer.set(r),e}}const index_es_Ks=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),index_es_wt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),index_es_bt=new Uint32Array(64);class index_es_Fs extends index_es_qs{constructor(){super(64,32,8,!1),this.A=index_es_wt[0]|0,this.B=index_es_wt[1]|0,this.C=index_es_wt[2]|0,this.D=index_es_wt[3]|0,this.E=index_es_wt[4]|0,this.F=index_es_wt[5]|0,this.G=index_es_wt[6]|0,this.H=index_es_wt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:s,G:c,H:a}=this;return[e,n,r,o,i,s,c,a]}set(e,n,r,o,i,s,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=a|0}process(e,n){for(let f=0;f<16;f++,n+=4)index_es_bt[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const h=index_es_bt[f-15],y=index_es_bt[f-2],E=index_es_ct(h,7)^index_es_ct(h,18)^h>>>3,p=index_es_ct(y,17)^index_es_ct(y,19)^y>>>10;index_es_bt[f]=p+index_es_bt[f-7]+E+index_es_bt[f-16]|0}let{A:r,B:o,C:i,D:s,E:c,F:a,G:u,H:l}=this;for(let f=0;f<64;f++){const h=index_es_ct(c,6)^index_es_ct(c,11)^index_es_ct(c,25),y=l+h+index_es_Ds(c,a,u)+index_es_Ks[f]+index_es_bt[f]|0,p=(index_es_ct(r,2)^index_es_ct(r,13)^index_es_ct(r,22))+dist_index_es_Hs(r,o,i)|0;l=u,u=a,a=c,c=s+y|0,s=i,i=o,o=r,r=y+p|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,o,i,s,c,a,u,l)}roundClean(){index_es_bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const dist_index_es_Qt=dist_index_es_Qn(()=>new index_es_Fs);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const index_es_me=BigInt(0),index_es_we=BigInt(1),index_es_zs=BigInt(2);function dist_index_es_St(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function index_es_te(t){if(!dist_index_es_St(t))throw new Error("Uint8Array expected")}function dist_index_es_Ct(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}const dist_index_es_Zs=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function dist_index_es_Pt(t){index_es_te(t);let e="";for(let n=0;n<t.length;n++)e+=dist_index_es_Zs[t[n]];return e}function utils_dist_index_es_kt(t){const e=t.toString(16);return e.length&1?"0"+e:e}function dist_index_es_We(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?index_es_me:BigInt("0x"+t)}const index_es_ut={_0:48,_9:57,A:65,F:70,a:97,f:102};function dist_index_es_Cr(t){if(t>=index_es_ut._0&&t<=index_es_ut._9)return t-index_es_ut._0;if(t>=index_es_ut.A&&t<=index_es_ut.F)return t-(index_es_ut.A-10);if(t>=index_es_ut.a&&t<=index_es_ut.f)return t-(index_es_ut.a-10)}function dist_index_es_Vt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const s=dist_index_es_Cr(t.charCodeAt(i)),c=dist_index_es_Cr(t.charCodeAt(i+1));if(s===void 0||c===void 0){const a=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}r[o]=s*16+c}return r}function dist_index_es_Ot(t){return dist_index_es_We(dist_index_es_Pt(t))}function index_es_ee(t){return index_es_te(t),dist_index_es_We(dist_index_es_Pt(Uint8Array.from(t).reverse()))}function dist_index_es_Mt(t,e){return dist_index_es_Vt(t.toString(16).padStart(e*2,"0"))}function dist_index_es_be(t,e){return dist_index_es_Mt(t,e).reverse()}function dist_index_es_Ys(t){return dist_index_es_Vt(utils_dist_index_es_kt(t))}function index_es_et(t,e,n){let r;if(typeof e=="string")try{r=dist_index_es_Vt(e)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(dist_index_es_St(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function dist_index_es_ne(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];index_es_te(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}function dist_index_es_Gs(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function dist_index_es_Ws(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const dist_index_es_Xe=t=>typeof t=="bigint"&&index_es_me<=t;function dist_index_es_Ee(t,e,n){return dist_index_es_Xe(t)&&dist_index_es_Xe(e)&&dist_index_es_Xe(n)&&e<=t&&t<n}function index_es_ft(t,e,n,r){if(!dist_index_es_Ee(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function dist_index_es_Pr(t){let e;for(e=0;t>index_es_me;t>>=index_es_we,e+=1);return e}function dist_index_es_Xs(t,e){return t>>BigInt(e)&index_es_we}function dist_index_es_Js(t,e,n){return t|(n?index_es_we:index_es_me)<<BigInt(e)}const dist_index_es_Je=t=>(index_es_zs<<BigInt(t-1))-index_es_we,dist_index_es_Qe=t=>new Uint8Array(t),dist_index_es_kr=t=>Uint8Array.from(t);function dist_index_es_Vr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=dist_index_es_Qe(t),o=dist_index_es_Qe(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...f)=>n(o,r,...f),a=(f=dist_index_es_Qe())=>{o=c(dist_index_es_kr([0]),f),r=c(),f.length!==0&&(o=c(dist_index_es_kr([1]),f),r=c())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const h=[];for(;f<e;){r=c();const y=r.slice();h.push(y),f+=r.length}return dist_index_es_ne(...h)};return(f,h)=>{s(),a(f);let y;for(;!(y=h(u()));)a();return s(),y}}const dist_index_es_Qs={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||dist_index_es_St(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function index_es_Dt(t,e,n={}){const r=(o,i,s)=>{const c=dist_index_es_Qs[i];if(typeof c!="function")throw new Error("invalid validator function");const a=t[o];if(!(s&&a===void 0)&&!c(a,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+a)};for(const[o,i]of Object.entries(e))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return t}const index_es_tc=()=>{throw new Error("not implemented")};function dist_index_es_tn(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(o!==void 0)return o;const i=t(n,...r);return e.set(n,i),i}}var index_es_ec=Object.freeze({__proto__:null,isBytes:dist_index_es_St,abytes:index_es_te,abool:dist_index_es_Ct,bytesToHex:dist_index_es_Pt,numberToHexUnpadded:utils_dist_index_es_kt,hexToNumber:dist_index_es_We,hexToBytes:dist_index_es_Vt,bytesToNumberBE:dist_index_es_Ot,bytesToNumberLE:index_es_ee,numberToBytesBE:dist_index_es_Mt,numberToBytesLE:dist_index_es_be,numberToVarBytesBE:dist_index_es_Ys,ensureBytes:index_es_et,concatBytes:dist_index_es_ne,equalBytes:dist_index_es_Gs,utf8ToBytes:dist_index_es_Ws,inRange:dist_index_es_Ee,aInRange:index_es_ft,bitLen:dist_index_es_Pr,bitGet:dist_index_es_Xs,bitSet:dist_index_es_Js,bitMask:dist_index_es_Je,createHmacDrbg:dist_index_es_Vr,validateObject:index_es_Dt,notImplemented:index_es_tc,memoized:dist_index_es_tn});const index_es_q=BigInt(0),dist_index_es_H=BigInt(1),dist_index_es_At=BigInt(2),index_es_nc=BigInt(3),dist_index_es_en=BigInt(4),dist_index_es_Mr=BigInt(5),dist_index_es_Dr=BigInt(8);function index_es_X(t,e){const n=t%e;return n>=index_es_q?n:e+n}function dist_index_es_Hr(t,e,n){if(e<index_es_q)throw new Error("invalid exponent, negatives unsupported");if(n<=index_es_q)throw new Error("invalid modulus");if(n===dist_index_es_H)return index_es_q;let r=dist_index_es_H;for(;e>index_es_q;)e&dist_index_es_H&&(r=r*t%n),t=t*t%n,e>>=dist_index_es_H;return r}function index_es_it(t,e,n){let r=t;for(;e-- >index_es_q;)r*=r,r%=n;return r}function dist_index_es_nn(t,e){if(t===index_es_q)throw new Error("invert: expected non-zero number");if(e<=index_es_q)throw new Error("invert: expected positive modulus, got "+e);let n=index_es_X(t,e),r=e,o=index_es_q,i=dist_index_es_H;for(;n!==index_es_q;){const c=r/n,a=r%n,u=o-i*c;r=n,n=a,o=i,i=u}if(r!==dist_index_es_H)throw new Error("invert: does not exist");return index_es_X(o,e)}function index_es_rc(t){const e=(t-dist_index_es_H)/dist_index_es_At;let n,r,o;for(n=t-dist_index_es_H,r=0;n%dist_index_es_At===index_es_q;n/=dist_index_es_At,r++);for(o=dist_index_es_At;o<t&&dist_index_es_Hr(o,e,t)!==t-dist_index_es_H;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const s=(t+dist_index_es_H)/dist_index_es_en;return function(a,u){const l=a.pow(u,s);if(!a.eql(a.sqr(l),u))throw new Error("Cannot find square root");return l}}const i=(n+dist_index_es_H)/dist_index_es_At;return function(c,a){if(c.pow(a,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,l=c.pow(c.mul(c.ONE,o),n),f=c.pow(a,i),h=c.pow(a,n);for(;!c.eql(h,c.ONE);){if(c.eql(h,c.ZERO))return c.ZERO;let y=1;for(let p=c.sqr(h);y<u&&!c.eql(p,c.ONE);y++)p=c.sqr(p);const E=c.pow(l,dist_index_es_H<<BigInt(u-y-1));l=c.sqr(E),f=c.mul(f,E),h=c.mul(h,l),u=y}return f}}function index_es_oc(t){if(t%dist_index_es_en===index_es_nc){const e=(t+dist_index_es_H)/dist_index_es_en;return function(r,o){const i=r.pow(o,e);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%dist_index_es_Dr===dist_index_es_Mr){const e=(t-dist_index_es_Mr)/dist_index_es_Dr;return function(r,o){const i=r.mul(o,dist_index_es_At),s=r.pow(i,e),c=r.mul(o,s),a=r.mul(r.mul(c,dist_index_es_At),s),u=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return index_es_rc(t)}const index_es_ic=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function index_es_sc(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=index_es_ic.reduce((r,o)=>(r[o]="function",r),e);return index_es_Dt(t,n)}function index_es_cc(t,e,n){if(n<index_es_q)throw new Error("invalid exponent, negatives unsupported");if(n===index_es_q)return t.ONE;if(n===dist_index_es_H)return e;let r=t.ONE,o=e;for(;n>index_es_q;)n&dist_index_es_H&&(r=t.mul(r,o)),o=t.sqr(o),n>>=dist_index_es_H;return r}function index_es_ac(t,e){const n=new Array(e.length),r=e.reduce((i,s,c)=>t.is0(s)?i:(n[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return e.reduceRight((i,s,c)=>t.is0(s)?i:(n[c]=t.mul(i,n[c]),t.mul(i,s)),o),n}function dist_index_es_qr(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function dist_index_es_Kr(t,e,n=!1,r={}){if(t<=index_es_q)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=dist_index_es_qr(t,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const c=Object.freeze({ORDER:t,isLE:n,BITS:o,BYTES:i,MASK:dist_index_es_Je(o),ZERO:index_es_q,ONE:dist_index_es_H,create:a=>index_es_X(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return index_es_q<=a&&a<t},is0:a=>a===index_es_q,isOdd:a=>(a&dist_index_es_H)===dist_index_es_H,neg:a=>index_es_X(-a,t),eql:(a,u)=>a===u,sqr:a=>index_es_X(a*a,t),add:(a,u)=>index_es_X(a+u,t),sub:(a,u)=>index_es_X(a-u,t),mul:(a,u)=>index_es_X(a*u,t),pow:(a,u)=>index_es_cc(c,a,u),div:(a,u)=>index_es_X(a*dist_index_es_nn(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>dist_index_es_nn(a,t),sqrt:r.sqrt||(a=>(s||(s=index_es_oc(t)),s(c,a))),invertBatch:a=>index_es_ac(c,a),cmov:(a,u,l)=>l?u:a,toBytes:a=>n?dist_index_es_be(a,i):dist_index_es_Mt(a,i),fromBytes:a=>{if(a.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+a.length);return n?index_es_ee(a):dist_index_es_Ot(a)}});return Object.freeze(c)}function dist_index_es_Fr(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function dist_index_es_zr(t){const e=dist_index_es_Fr(t);return e+Math.ceil(e/2)}function index_es_uc(t,e,n=!1){const r=t.length,o=dist_index_es_Fr(e),i=dist_index_es_zr(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=n?index_es_ee(t):dist_index_es_Ot(t),c=index_es_X(s,e-dist_index_es_H)+dist_index_es_H;return n?dist_index_es_be(c,o):dist_index_es_Mt(c,o)}const dist_index_es_Zr=BigInt(0),index_es_ve=BigInt(1);function dist_index_es_rn(t,e){const n=e.negate();return t?n:e}function dist_index_es_Yr(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function dist_index_es_on(t,e){dist_index_es_Yr(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1);return{windows:n,windowSize:r}}function index_es_fc(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function index_es_lc(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const dist_index_es_sn=new WeakMap,dist_index_es_Gr=new WeakMap;function dist_index_es_cn(t){return dist_index_es_Gr.get(t)||1}function index_es_dc(t,e){return{constTimeNegate:dist_index_es_rn,hasPrecomputes(n){return dist_index_es_cn(n)!==1},unsafeLadder(n,r,o=t.ZERO){let i=n;for(;r>dist_index_es_Zr;)r&index_es_ve&&(o=o.add(i)),i=i.double(),r>>=index_es_ve;return o},precomputeWindow(n,r){const{windows:o,windowSize:i}=dist_index_es_on(r,e),s=[];let c=n,a=c;for(let u=0;u<o;u++){a=c,s.push(a);for(let l=1;l<i;l++)a=a.add(c),s.push(a);c=a.double()}return s},wNAF(n,r,o){const{windows:i,windowSize:s}=dist_index_es_on(n,e);let c=t.ZERO,a=t.BASE;const u=BigInt(2**n-1),l=2**n,f=BigInt(n);for(let h=0;h<i;h++){const y=h*s;let E=Number(o&u);o>>=f,E>s&&(E-=l,o+=index_es_ve);const p=y,d=y+Math.abs(E)-1,v=h%2!==0,m=E<0;E===0?a=a.add(dist_index_es_rn(v,r[p])):c=c.add(dist_index_es_rn(m,r[d]))}return{p:c,f:a}},wNAFUnsafe(n,r,o,i=t.ZERO){const{windows:s,windowSize:c}=dist_index_es_on(n,e),a=BigInt(2**n-1),u=2**n,l=BigInt(n);for(let f=0;f<s;f++){const h=f*c;if(o===dist_index_es_Zr)break;let y=Number(o&a);if(o>>=l,y>c&&(y-=u,o+=index_es_ve),y===0)continue;let E=r[h+Math.abs(y)-1];y<0&&(E=E.negate()),i=i.add(E)}return i},getPrecomputes(n,r,o){let i=dist_index_es_sn.get(r);return i||(i=this.precomputeWindow(r,n),n!==1&&dist_index_es_sn.set(r,o(i))),i},wNAFCached(n,r,o){const i=dist_index_es_cn(n);return this.wNAF(i,this.getPrecomputes(i,n,o),r)},wNAFCachedUnsafe(n,r,o,i){const s=dist_index_es_cn(n);return s===1?this.unsafeLadder(n,r,i):this.wNAFUnsafe(s,this.getPrecomputes(s,n,o),r,i)},setWindowSize(n,r){dist_index_es_Yr(r,e),dist_index_es_Gr.set(n,r),dist_index_es_sn.delete(n)}}}function index_es_hc(t,e,n,r){if(index_es_fc(n,t),index_es_lc(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=dist_index_es_Pr(BigInt(n.length)),s=i>12?i-3:i>4?i-2:i?2:1,c=(1<<s)-1,a=new Array(c+1).fill(o),u=Math.floor((e.BITS-1)/s)*s;let l=o;for(let f=u;f>=0;f-=s){a.fill(o);for(let y=0;y<r.length;y++){const E=r[y],p=Number(E>>BigInt(f)&BigInt(c));a[p]=a[p].add(n[y])}let h=o;for(let y=a.length-1,E=o;y>0;y--)E=E.add(a[y]),h=h.add(E);if(l=l.add(h),f!==0)for(let y=0;y<s;y++)l=l.double()}return l}function dist_index_es_Wr(t){return index_es_sc(t.Fp),index_es_Dt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...dist_index_es_qr(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const dist_index_es_Ht=BigInt(0),dist_index_es_an=BigInt(1);function index_es_pc(t){return index_es_Dt(t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...t})}function index_es_gc(t){const e=index_es_pc(t),{P:n}=e,r=m=>index_es_X(m,n),o=e.montgomeryBits,i=Math.ceil(o/8),s=e.nByteLength,c=e.adjustScalarBytes||(m=>m),a=e.powPminus2||(m=>dist_index_es_Hr(m,n-BigInt(2),n));function u(m,O,N){const $=r(m*(O-N));return O=r(O-$),N=r(N+$),[O,N]}const l=(e.a-BigInt(2))/BigInt(4);function f(m,O){index_es_ft("u",m,dist_index_es_Ht,n),index_es_ft("scalar",O,dist_index_es_Ht,n);const N=O,$=m;let B=dist_index_es_an,A=dist_index_es_Ht,T=m,S=dist_index_es_an,L=dist_index_es_Ht,U;for(let j=BigInt(o-1);j>=dist_index_es_Ht;j--){const g=N>>j&dist_index_es_an;L^=g,U=u(L,B,T),B=U[0],T=U[1],U=u(L,A,S),A=U[0],S=U[1],L=g;const w=B+A,b=r(w*w),I=B-A,R=r(I*I),x=b-R,C=T+S,P=T-S,k=r(P*w),M=r(C*I),D=k+M,z=k-M;T=r(D*D),S=r($*r(z*z)),B=r(b*R),A=r(x*(b+r(l*x)))}U=u(L,B,T),B=U[0],T=U[1],U=u(L,A,S),A=U[0],S=U[1];const _=a(A);return r(B*_)}function h(m){return dist_index_es_be(r(m),i)}function y(m){const O=index_es_et("u coordinate",m,i);return s===32&&(O[31]&=127),index_es_ee(O)}function E(m){const O=index_es_et("scalar",m),N=O.length;if(N!==i&&N!==s){let $=""+i+" or "+s;throw new Error("invalid scalar, expected "+$+" bytes, got "+N)}return index_es_ee(c(O))}function p(m,O){const N=y(O),$=E(m),B=f(N,$);if(B===dist_index_es_Ht)throw new Error("invalid private or public key received");return h(B)}const d=h(e.Gu);function v(m){return p(m,d)}return{scalarMult:p,scalarMultBase:v,getSharedSecret:(m,O)=>p(m,O),getPublicKey:m=>v(m),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:d}}const dist_index_es_un=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const index_es_yc=BigInt(1),dist_index_es_Xr=BigInt(2),index_es_mc=BigInt(3),index_es_wc=BigInt(5);BigInt(8);function index_es_bc(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),i=dist_index_es_un,c=t*t%i*t%i,a=index_es_it(c,dist_index_es_Xr,i)*c%i,u=index_es_it(a,index_es_yc,i)*t%i,l=index_es_it(u,index_es_wc,i)*u%i,f=index_es_it(l,e,i)*l%i,h=index_es_it(f,n,i)*f%i,y=index_es_it(h,r,i)*h%i,E=index_es_it(y,o,i)*y%i,p=index_es_it(E,o,i)*y%i,d=index_es_it(p,e,i)*l%i;return{pow_p_5_8:index_es_it(d,dist_index_es_Xr,i)*t%i,b2:c}}function index_es_Ec(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const dist_index_es_fn=index_es_gc({P:dist_index_es_un,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=dist_index_es_un,{pow_p_5_8:n,b2:r}=index_es_bc(t);return index_es_X(index_es_it(n,index_es_mc,e)*r,e)},adjustScalarBytes:index_es_Ec,randomBytes:dist_index_es_Lt});function dist_index_es_Jr(t){t.lowS!==void 0&&dist_index_es_Ct("lowS",t.lowS),t.prehash!==void 0&&dist_index_es_Ct("prehash",t.prehash)}function index_es_vc(t){const e=dist_index_es_Wr(t);index_es_Dt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:index_es_xc,hexToBytes:index_es_Sc}=index_es_ec;class index_es_Oc extends Error{constructor(e=""){super(e)}}const index_es_lt={Err:index_es_Oc,_tlv:{encode:(t,e)=>{const{Err:n}=index_es_lt;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=utils_dist_index_es_kt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?utils_dist_index_es_kt(o.length/2|128):"";return utils_dist_index_es_kt(t)+i+o+e},decode(t,e){const{Err:n}=index_es_lt;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++],i=!!(o&128);let s=0;if(!i)s=o;else{const a=o&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+a);if(u.length!==a)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const l of u)s=s<<8|l;if(r+=a,s<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+s);if(c.length!==s)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+s)}}},_int:{encode(t){const{Err:e}=index_es_lt;if(t<index_es_dt)throw new e("integer: negative integers are not allowed");let n=utils_dist_index_es_kt(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=index_es_lt;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return index_es_xc(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=index_es_lt,o=typeof t=="string"?index_es_Sc(t):t;index_es_te(o);const{v:i,l:s}=r.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,i),{v:u,l}=r.decode(2,a);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=index_es_lt,r=e.encode(2,n.encode(t.r)),o=e.encode(2,n.encode(t.s)),i=r+o;return e.encode(48,i)}},index_es_dt=BigInt(0),dist_index_es_K=BigInt(1);BigInt(2);const dist_index_es_Qr=BigInt(3);BigInt(4);function index_es_Ac(t){const e=index_es_vc(t),{Fp:n}=e,r=dist_index_es_Kr(e.n,e.nBitLength),o=e.toBytes||((p,d,v)=>{const m=d.toAffine();return dist_index_es_ne(Uint8Array.from([4]),n.toBytes(m.x),n.toBytes(m.y))}),i=e.fromBytes||(p=>{const d=p.subarray(1),v=n.fromBytes(d.subarray(0,n.BYTES)),m=n.fromBytes(d.subarray(n.BYTES,2*n.BYTES));return{x:v,y:m}});function s(p){const{a:d,b:v}=e,m=n.sqr(p),O=n.mul(m,p);return n.add(n.add(O,n.mul(p,d)),v)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return dist_index_es_Ee(p,dist_index_es_K,e.n)}function a(p){const{allowedPrivateKeyLengths:d,nByteLength:v,wrapPrivateKey:m,n:O}=e;if(d&&typeof p!="bigint"){if(dist_index_es_St(p)&&(p=dist_index_es_Pt(p)),typeof p!="string"||!d.includes(p.length))throw new Error("invalid private key");p=p.padStart(v*2,"0")}let N;try{N=typeof p=="bigint"?p:dist_index_es_Ot(index_es_et("private key",p,v))}catch{throw new Error("invalid private key, expected hex or "+v+" bytes, got "+typeof p)}return m&&(N=index_es_X(N,O)),index_es_ft("private key",N,dist_index_es_K,O),N}function u(p){if(!(p instanceof h))throw new Error("ProjectivePoint expected")}const l=dist_index_es_tn((p,d)=>{const{px:v,py:m,pz:O}=p;if(n.eql(O,n.ONE))return{x:v,y:m};const N=p.is0();d==null&&(d=N?n.ONE:n.inv(O));const $=n.mul(v,d),B=n.mul(m,d),A=n.mul(O,d);if(N)return{x:n.ZERO,y:n.ZERO};if(!n.eql(A,n.ONE))throw new Error("invZ was invalid");return{x:$,y:B}}),f=dist_index_es_tn(p=>{if(p.is0()){if(e.allowInfinityPoint&&!n.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:d,y:v}=p.toAffine();if(!n.isValid(d)||!n.isValid(v))throw new Error("bad point: x or y not FE");const m=n.sqr(v),O=s(d);if(!n.eql(m,O))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(d,v,m){if(this.px=d,this.py=v,this.pz=m,d==null||!n.isValid(d))throw new Error("x required");if(v==null||!n.isValid(v))throw new Error("y required");if(m==null||!n.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(d){const{x:v,y:m}=d||{};if(!d||!n.isValid(v)||!n.isValid(m))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const O=N=>n.eql(N,n.ZERO);return O(v)&&O(m)?h.ZERO:new h(v,m,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const v=n.invertBatch(d.map(m=>m.pz));return d.map((m,O)=>m.toAffine(v[O])).map(h.fromAffine)}static fromHex(d){const v=h.fromAffine(i(index_es_et("pointHex",d)));return v.assertValidity(),v}static fromPrivateKey(d){return h.BASE.multiply(a(d))}static msm(d,v){return index_es_hc(h,r,d,v)}_setWindowSize(d){E.setWindowSize(this,d)}assertValidity(){f(this)}hasEvenY(){const{y:d}=this.toAffine();if(n.isOdd)return!n.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){u(d);const{px:v,py:m,pz:O}=this,{px:N,py:$,pz:B}=d,A=n.eql(n.mul(v,B),n.mul(N,O)),T=n.eql(n.mul(m,B),n.mul($,O));return A&&T}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:d,b:v}=e,m=n.mul(v,dist_index_es_Qr),{px:O,py:N,pz:$}=this;let B=n.ZERO,A=n.ZERO,T=n.ZERO,S=n.mul(O,O),L=n.mul(N,N),U=n.mul($,$),_=n.mul(O,N);return _=n.add(_,_),T=n.mul(O,$),T=n.add(T,T),B=n.mul(d,T),A=n.mul(m,U),A=n.add(B,A),B=n.sub(L,A),A=n.add(L,A),A=n.mul(B,A),B=n.mul(_,B),T=n.mul(m,T),U=n.mul(d,U),_=n.sub(S,U),_=n.mul(d,_),_=n.add(_,T),T=n.add(S,S),S=n.add(T,S),S=n.add(S,U),S=n.mul(S,_),A=n.add(A,S),U=n.mul(N,$),U=n.add(U,U),S=n.mul(U,_),B=n.sub(B,S),T=n.mul(U,L),T=n.add(T,T),T=n.add(T,T),new h(B,A,T)}add(d){u(d);const{px:v,py:m,pz:O}=this,{px:N,py:$,pz:B}=d;let A=n.ZERO,T=n.ZERO,S=n.ZERO;const L=e.a,U=n.mul(e.b,dist_index_es_Qr);let _=n.mul(v,N),j=n.mul(m,$),g=n.mul(O,B),w=n.add(v,m),b=n.add(N,$);w=n.mul(w,b),b=n.add(_,j),w=n.sub(w,b),b=n.add(v,O);let I=n.add(N,B);return b=n.mul(b,I),I=n.add(_,g),b=n.sub(b,I),I=n.add(m,O),A=n.add($,B),I=n.mul(I,A),A=n.add(j,g),I=n.sub(I,A),S=n.mul(L,b),A=n.mul(U,g),S=n.add(A,S),A=n.sub(j,S),S=n.add(j,S),T=n.mul(A,S),j=n.add(_,_),j=n.add(j,_),g=n.mul(L,g),b=n.mul(U,b),j=n.add(j,g),g=n.sub(_,g),g=n.mul(L,g),b=n.add(b,g),_=n.mul(j,b),T=n.add(T,_),_=n.mul(I,b),A=n.mul(w,A),A=n.sub(A,_),_=n.mul(w,j),S=n.mul(I,S),S=n.add(S,_),new h(A,T,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return E.wNAFCached(this,d,h.normalizeZ)}multiplyUnsafe(d){const{endo:v,n:m}=e;index_es_ft("scalar",d,index_es_dt,m);const O=h.ZERO;if(d===index_es_dt)return O;if(this.is0()||d===dist_index_es_K)return this;if(!v||E.hasPrecomputes(this))return E.wNAFCachedUnsafe(this,d,h.normalizeZ);let{k1neg:N,k1:$,k2neg:B,k2:A}=v.splitScalar(d),T=O,S=O,L=this;for(;$>index_es_dt||A>index_es_dt;)$&dist_index_es_K&&(T=T.add(L)),A&dist_index_es_K&&(S=S.add(L)),L=L.double(),$>>=dist_index_es_K,A>>=dist_index_es_K;return N&&(T=T.negate()),B&&(S=S.negate()),S=new h(n.mul(S.px,v.beta),S.py,S.pz),T.add(S)}multiply(d){const{endo:v,n:m}=e;index_es_ft("scalar",d,dist_index_es_K,m);let O,N;if(v){const{k1neg:$,k1:B,k2neg:A,k2:T}=v.splitScalar(d);let{p:S,f:L}=this.wNAF(B),{p:U,f:_}=this.wNAF(T);S=E.constTimeNegate($,S),U=E.constTimeNegate(A,U),U=new h(n.mul(U.px,v.beta),U.py,U.pz),O=S.add(U),N=L.add(_)}else{const{p:$,f:B}=this.wNAF(d);O=$,N=B}return h.normalizeZ([O,N])[0]}multiplyAndAddUnsafe(d,v,m){const O=h.BASE,N=(B,A)=>A===index_es_dt||A===dist_index_es_K||!B.equals(O)?B.multiplyUnsafe(A):B.multiply(A),$=N(this,v).add(N(d,m));return $.is0()?void 0:$}toAffine(d){return l(this,d)}isTorsionFree(){const{h:d,isTorsionFree:v}=e;if(d===dist_index_es_K)return!0;if(v)return v(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:v}=e;return d===dist_index_es_K?this:v?v(h,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return dist_index_es_Ct("isCompressed",d),this.assertValidity(),o(h,this,d)}toHex(d=!0){return dist_index_es_Ct("isCompressed",d),dist_index_es_Pt(this.toRawBytes(d))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const y=e.nBitLength,E=index_es_dc(h,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder:c}}function index_es_Bc(t){const e=dist_index_es_Wr(t);return index_es_Dt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function index_es_Ic(t){const e=index_es_Bc(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(g){return index_es_X(g,r)}function c(g){return dist_index_es_nn(g,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:f}=index_es_Ac({...e,toBytes(g,w,b){const I=w.toAffine(),R=n.toBytes(I.x),x=dist_index_es_ne;return dist_index_es_Ct("isCompressed",b),b?x(Uint8Array.from([w.hasEvenY()?2:3]),R):x(Uint8Array.from([4]),R,n.toBytes(I.y))},fromBytes(g){const w=g.length,b=g[0],I=g.subarray(1);if(w===o&&(b===2||b===3)){const R=dist_index_es_Ot(I);if(!dist_index_es_Ee(R,dist_index_es_K,n.ORDER))throw new Error("Point is not on curve");const x=l(R);let C;try{C=n.sqrt(x)}catch(M){const D=M instanceof Error?": "+M.message:"";throw new Error("Point is not on curve"+D)}const P=(C&dist_index_es_K)===dist_index_es_K;return(b&1)===1!==P&&(C=n.neg(C)),{x:R,y:C}}else if(w===i&&b===4){const R=n.fromBytes(I.subarray(0,n.BYTES)),x=n.fromBytes(I.subarray(n.BYTES,2*n.BYTES));return{x:R,y:x}}else{const R=o,x=i;throw new Error("invalid Point, expected length of "+R+", or uncompressed "+x+", got "+w)}}}),h=g=>dist_index_es_Pt(dist_index_es_Mt(g,e.nByteLength));function y(g){const w=r>>dist_index_es_K;return g>w}function E(g){return y(g)?s(-g):g}const p=(g,w,b)=>dist_index_es_Ot(g.slice(w,b));class d{constructor(w,b,I){this.r=w,this.s=b,this.recovery=I,this.assertValidity()}static fromCompact(w){const b=e.nByteLength;return w=index_es_et("compactSignature",w,b*2),new d(p(w,0,b),p(w,b,2*b))}static fromDER(w){const{r:b,s:I}=index_es_lt.toSig(index_es_et("DER",w));return new d(b,I)}assertValidity(){index_es_ft("r",this.r,dist_index_es_K,r),index_es_ft("s",this.s,dist_index_es_K,r)}addRecoveryBit(w){return new d(this.r,this.s,w)}recoverPublicKey(w){const{r:b,s:I,recovery:R}=this,x=B(index_es_et("msgHash",w));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const C=R===2||R===3?b+e.n:b;if(C>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=(R&1)===0?"02":"03",k=a.fromHex(P+h(C)),M=c(C),D=s(-x*M),z=s(I*M),Z=a.BASE.multiplyAndAddUnsafe(k,D,z);if(!Z)throw new Error("point at infinify");return Z.assertValidity(),Z}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return dist_index_es_Vt(this.toDERHex())}toDERHex(){return index_es_lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return dist_index_es_Vt(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const v={isValidPrivateKey(g){try{return u(g),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const g=dist_index_es_zr(e.n);return index_es_uc(e.randomBytes(g),e.n)},precompute(g=8,w=a.BASE){return w._setWindowSize(g),w.multiply(BigInt(3)),w}};function m(g,w=!0){return a.fromPrivateKey(g).toRawBytes(w)}function O(g){const w=dist_index_es_St(g),b=typeof g=="string",I=(w||b)&&g.length;return w?I===o||I===i:b?I===2*o||I===2*i:g instanceof a}function N(g,w,b=!0){if(O(g))throw new Error("first arg must be private key");if(!O(w))throw new Error("second arg must be public key");return a.fromHex(w).multiply(u(g)).toRawBytes(b)}const $=e.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const w=dist_index_es_Ot(g),b=g.length*8-e.nBitLength;return b>0?w>>BigInt(b):w},B=e.bits2int_modN||function(g){return s($(g))},A=dist_index_es_Je(e.nBitLength);function T(g){return index_es_ft("num < 2^"+e.nBitLength,g,index_es_dt,A),dist_index_es_Mt(g,e.nByteLength)}function S(g,w,b=L){if(["recovered","canonical"].some(W=>W in b))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:R}=e;let{lowS:x,prehash:C,extraEntropy:P}=b;x==null&&(x=!0),g=index_es_et("msgHash",g),dist_index_es_Jr(b),C&&(g=index_es_et("prehashed msgHash",I(g)));const k=B(g),M=u(w),D=[T(M),T(k)];if(P!=null&&P!==!1){const W=P===!0?R(n.BYTES):P;D.push(index_es_et("extraEntropy",W))}const z=dist_index_es_ne(...D),Z=k;function st(W){const J=$(W);if(!f(J))return;const Be=c(J),zt=a.BASE.multiply(J).toAffine(),vt=s(zt.x);if(vt===index_es_dt)return;const Zt=s(Be*s(Z+vt*M));if(Zt===index_es_dt)return;let Ut=(zt.x===vt?0:2)|Number(zt.y&dist_index_es_K),vn=Zt;return x&&y(Zt)&&(vn=E(Zt),Ut^=1),new d(vt,vn,Ut)}return{seed:z,k2sig:st}}const L={lowS:e.lowS,prehash:!1},U={lowS:e.lowS,prehash:!1};function _(g,w,b=L){const{seed:I,k2sig:R}=S(g,w,b),x=e;return dist_index_es_Vr(x.hash.outputLen,x.nByteLength,x.hmac)(I,R)}a.BASE._setWindowSize(8);function j(g,w,b,I=U){const R=g;w=index_es_et("msgHash",w),b=index_es_et("publicKey",b);const{lowS:x,prehash:C,format:P}=I;if(dist_index_es_Jr(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(P!==void 0&&P!=="compact"&&P!=="der")throw new Error("format must be compact or der");const k=typeof R=="string"||dist_index_es_St(R),M=!k&&!P&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!k&&!M)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let D,z;try{if(M&&(D=new d(R.r,R.s)),k){try{P!=="compact"&&(D=d.fromDER(R))}catch(Ut){if(!(Ut instanceof index_es_lt.Err))throw Ut}!D&&P!=="der"&&(D=d.fromCompact(R))}z=a.fromHex(b)}catch{return!1}if(!D||x&&D.hasHighS())return!1;C&&(w=e.hash(w));const{r:Z,s:st}=D,W=B(w),J=c(st),Be=s(W*J),zt=s(Z*J),vt=a.BASE.multiplyAndAddUnsafe(z,Be,zt)?.toAffine();return vt?s(vt.x)===Z:!1}return{CURVE:e,getPublicKey:m,getSharedSecret:N,sign:_,verify:j,ProjectivePoint:a,Signature:d,utils:v}}function index_es_Nc(t){return{hash:t,hmac:(e,...n)=>dist_index_es_ye(t,e,dist_index_es_Vi(...n)),randomBytes:dist_index_es_Lt}}function index_es_Uc(t,e){const n=r=>index_es_Ic({...t,...index_es_Nc(r)});return{...n(e),create:n}}const dist_index_es_to=dist_index_es_Kr(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),index_es_Tc=dist_index_es_to.create(BigInt("-3")),index_es_Rc=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),index_es_c=index_es_Uc({a:index_es_Tc,b:index_es_Rc,Fp:dist_index_es_to,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},dist_index_es_Qt),dist_index_es_ln="base10",dist_index_es_G="base16",dist_index_es_qt="base64pad",index_es_xe="base64url",dist_index_es_Kt="utf8",dist_index_es_dn=0,dist_index_es_Ft=1,dist_index_es_re=2,index_es_$c=0,dist_index_es_eo=1,index_es_oe=12,dist_index_es_hn=32;function index_es_Lc(){const t=dist_index_es_fn.utils.randomPrivateKey(),e=dist_index_es_fn.getPublicKey(t);return{privateKey:Q(t,dist_index_es_G),publicKey:Q(e,dist_index_es_G)}}function index_es_jc(){const t=dist_index_es_Lt(dist_index_es_hn);return Q(t,dist_index_es_G)}function index_es_Cc(t,e){const n=dist_index_es_fn.getSharedSecret(rt(t,dist_index_es_G),rt(e,dist_index_es_G)),r=index_es_Vs(dist_index_es_Qt,n,void 0,void 0,dist_index_es_hn);return Q(r,dist_index_es_G)}function index_es_Pc(t){const e=dist_index_es_Qt((0,src/* fromString */.sH)(t,dist_index_es_G));return (0,src/* toString */.dI)(e,dist_index_es_G)}function index_es_kc(t){const e=dist_index_es_Qt((0,src/* fromString */.sH)(t,dist_index_es_Kt));return (0,src/* toString */.dI)(e,dist_index_es_G)}function dist_index_es_pn(t){return rt(`${t}`,dist_index_es_ln)}function dist_index_es_Bt(t){return Number(Q(t,dist_index_es_ln))}function dist_index_es_no(t){return t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function dist_index_es_ro(t){const e=t.replace(/-/g,"+").replace(/_/g,"/"),n=(4-e.length%4)%4;return e+"=".repeat(n)}function index_es_Vc(t){const e=dist_index_es_pn(typeof t.type<"u"?t.type:dist_index_es_dn);if(dist_index_es_Bt(e)===dist_index_es_Ft&&typeof t.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const n=typeof t.senderPublicKey<"u"?rt(t.senderPublicKey,dist_index_es_G):void 0,r=typeof t.iv<"u"?rt(t.iv,dist_index_es_G):dist_index_es_Lt(index_es_oe),o=rt(t.symKey,dist_index_es_G),i=dist_index_es_$r(o,r).encrypt(rt(t.message,dist_index_es_Kt)),s=dist_index_es_gn({type:e,sealed:i,iv:r,senderPublicKey:n});return t.encoding===index_es_xe?dist_index_es_no(s):s}function index_es_Mc(t){const e=rt(t.symKey,dist_index_es_G),{sealed:n,iv:r}=index_es_Se({encoded:t.encoded,encoding:t.encoding}),o=dist_index_es_$r(e,r).decrypt(n);if(o===null)throw new Error("Failed to decrypt");return Q(o,dist_index_es_Kt)}function index_es_Dc(t,e){const n=dist_index_es_pn(dist_index_es_re),r=dist_index_es_Lt(index_es_oe),o=rt(t,dist_index_es_Kt),i=dist_index_es_gn({type:n,sealed:o,iv:r});return e===index_es_xe?dist_index_es_no(i):i}function index_es_Hc(t,e){const{sealed:n}=index_es_Se({encoded:t,encoding:e});return Q(n,dist_index_es_Kt)}function dist_index_es_gn(t){if(dist_index_es_Bt(t.type)===dist_index_es_re)return Q(Gt([t.type,t.sealed]),dist_index_es_qt);if(dist_index_es_Bt(t.type)===dist_index_es_Ft){if(typeof t.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return Q(Gt([t.type,t.senderPublicKey,t.iv,t.sealed]),dist_index_es_qt)}return Q(Gt([t.type,t.iv,t.sealed]),dist_index_es_qt)}function index_es_Se(t){const e=(t.encoding||dist_index_es_qt)===index_es_xe?dist_index_es_ro(t.encoded):t.encoded,n=rt(e,dist_index_es_qt),r=n.slice(index_es_$c,dist_index_es_eo),o=dist_index_es_eo;if(dist_index_es_Bt(r)===dist_index_es_Ft){const a=o+dist_index_es_hn,u=a+index_es_oe,l=n.slice(o,a),f=n.slice(a,u),h=n.slice(u);return{type:r,sealed:h,iv:f,senderPublicKey:l}}if(dist_index_es_Bt(r)===dist_index_es_re){const a=n.slice(o),u=dist_index_es_Lt(index_es_oe);return{type:r,sealed:a,iv:u}}const i=o+index_es_oe,s=n.slice(o,i),c=n.slice(i);return{type:r,sealed:c,iv:s}}function index_es_qc(t,e){const n=index_es_Se({encoded:t,encoding:e?.encoding});return dist_index_es_oo({type:dist_index_es_Bt(n.type),senderPublicKey:typeof n.senderPublicKey<"u"?Q(n.senderPublicKey,dist_index_es_G):void 0,receiverPublicKey:e?.receiverPublicKey})}function dist_index_es_oo(t){const e=t?.type||dist_index_es_dn;if(e===dist_index_es_Ft){if(typeof t?.senderPublicKey>"u")throw new Error("missing sender public key");if(typeof t?.receiverPublicKey>"u")throw new Error("missing receiver public key")}return{type:e,senderPublicKey:t?.senderPublicKey,receiverPublicKey:t?.receiverPublicKey}}function index_es_Kc(t){return t.type===dist_index_es_Ft&&typeof t.senderPublicKey=="string"&&typeof t.receiverPublicKey=="string"}function index_es_Fc(t){return t.type===dist_index_es_re}function dist_index_es_io(t){const e=Buffer.from(t.x,"base64"),n=Buffer.from(t.y,"base64");return Gt([new Uint8Array([4]),e,n])}function index_es_zc(t,e){const[n,r,o]=t.split("."),i=Buffer.from(dist_index_es_ro(o),"base64");if(i.length!==64)throw new Error("Invalid signature length");const s=i.slice(0,32),c=i.slice(32,64),a=`${n}.${r}`,u=dist_index_es_Qt(a),l=dist_index_es_io(e);if(!index_es_c.verify(Gt([s,c]),u,l))throw new Error("Invalid signature");return Mo(t).payload}const dist_index_es_so="irn";function index_es_Zc(t){return t?.relay||{protocol:dist_index_es_so}}function index_es_Yc(t){const e=Do[t];if(typeof e>"u")throw new Error(`Relay Protocol not supported: ${t}`);return e}function dist_index_es_co(t,e="-"){const n={},r="relay"+e;return Object.keys(t).forEach(o=>{if(o.startsWith(r)){const i=o.replace(r,""),s=t[o];n[i]=s}}),n}function index_es_Gc(t){if(!t.includes("wc:")){const u=dist_index_es_je(t);u!=null&&u.includes("wc:")&&(t=u)}t=t.includes("wc://")?t.replace("wc://",""):t,t=t.includes("wc:")?t.replace("wc:",""):t;const e=t.indexOf(":"),n=t.indexOf("?")!==-1?t.indexOf("?"):void 0,r=t.substring(0,e),o=t.substring(e+1,n).split("@"),i=typeof n<"u"?t.substring(n):"",s=new URLSearchParams(i),c={};s.forEach((u,l)=>{c[l]=u});const a=typeof c.methods=="string"?c.methods.split(","):void 0;return{protocol:r,topic:dist_index_es_ao(o[0]),version:parseInt(o[1],10),symKey:c.symKey,relay:dist_index_es_co(c),methods:a,expiryTimestamp:c.expiryTimestamp?parseInt(c.expiryTimestamp,10):void 0}}function dist_index_es_ao(t){return t.startsWith("//")?t.substring(2):t}function dist_index_es_uo(t,e="-"){const n="relay",r={};return Object.keys(t).forEach(o=>{const i=o,s=n+e+i;t[i]&&(r[s]=t[i])}),r}function index_es_Wc(t){const e=new URLSearchParams,n=dist_index_es_uo(t.relay);Object.keys(n).sort().forEach(o=>{e.set(o,n[o])}),e.set("symKey",t.symKey),t.expiryTimestamp&&e.set("expiryTimestamp",t.expiryTimestamp.toString()),t.methods&&e.set("methods",t.methods.join(","));const r=e.toString();return`${t.protocol}:${t.topic}@${t.version}?${r}`}function index_es_Xc(t,e,n){return`${t}?wc_ev=${n}&topic=${e}`}var index_es_Jc=Object.defineProperty,index_es_Qc=Object.defineProperties,index_es_ta=Object.getOwnPropertyDescriptors,dist_index_es_fo=Object.getOwnPropertySymbols,index_es_ea=Object.prototype.hasOwnProperty,index_es_na=Object.prototype.propertyIsEnumerable,dist_index_es_lo=(t,e,n)=>e in t?index_es_Jc(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,index_es_ra=(t,e)=>{for(var n in e||(e={}))index_es_ea.call(e,n)&&dist_index_es_lo(t,n,e[n]);if(dist_index_es_fo)for(var n of dist_index_es_fo(e))index_es_na.call(e,n)&&dist_index_es_lo(t,n,e[n]);return t},index_es_oa=(t,e)=>index_es_Qc(t,index_es_ta(e));function dist_index_es_It(t){const e=[];return t.forEach(n=>{const[r,o]=n.split(":");e.push(`${r}:${o}`)}),e}function dist_index_es_ho(t){const e=[];return Object.values(t).forEach(n=>{e.push(...dist_index_es_It(n.accounts))}),e}function dist_index_es_po(t,e){const n=[];return Object.values(t).forEach(r=>{dist_index_es_It(r.accounts).includes(e)&&n.push(...r.methods)}),n}function dist_index_es_go(t,e){const n=[];return Object.values(t).forEach(r=>{dist_index_es_It(r.accounts).includes(e)&&n.push(...r.events)}),n}function index_es_ia(t,e){const n=dist_index_es_Bo(t,e);if(n)throw new Error(n.message);const r={};for(const[o,i]of Object.entries(t))r[o]={methods:i.methods,events:i.events,chains:i.accounts.map(s=>`${s.split(":")[0]}:${s.split(":")[1]}`)};return r}function index_es_sa(t){const{proposal:{requiredNamespaces:e,optionalNamespaces:n={}},supportedNamespaces:r}=t,o=dist_index_es_ie(e),i=dist_index_es_ie(n),s={};Object.keys(r).forEach(u=>{const l=r[u].chains,f=r[u].methods,h=r[u].events,y=r[u].accounts;l.forEach(E=>{if(!y.some(p=>p.includes(E)))throw new Error(`No accounts provided for chain ${E} in namespace ${u}`)}),s[u]={chains:l,methods:f,events:h,accounts:y}});const c=dist_index_es_No(e,s,"approve()");if(c)throw new Error(c.message);const a={};return!Object.keys(e).length&&!Object.keys(n).length?s:(Object.keys(o).forEach(u=>{const l=r[u].chains.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.chains)==null?void 0:d.includes(E)}),f=r[u].methods.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.methods)==null?void 0:d.includes(E)}),h=r[u].events.filter(E=>{var p,d;return(d=(p=o[u])==null?void 0:p.events)==null?void 0:d.includes(E)}),y=l.map(E=>r[u].accounts.filter(p=>p.includes(`${E}:`))).flat();a[u]={chains:l,methods:f,events:h,accounts:y}}),Object.keys(i).forEach(u=>{var l,f,h,y,E,p;if(!r[u])return;const d=(f=(l=i[u])==null?void 0:l.chains)==null?void 0:f.filter(N=>r[u].chains.includes(N)),v=r[u].methods.filter(N=>{var $,B;return(B=($=i[u])==null?void 0:$.methods)==null?void 0:B.includes(N)}),m=r[u].events.filter(N=>{var $,B;return(B=($=i[u])==null?void 0:$.events)==null?void 0:B.includes(N)}),O=d?.map(N=>r[u].accounts.filter($=>$.includes(`${N}:`))).flat();a[u]={chains:index_es_ot((h=a[u])==null?void 0:h.chains,d),methods:index_es_ot((y=a[u])==null?void 0:y.methods,v),events:index_es_ot((E=a[u])==null?void 0:E.events,m),accounts:index_es_ot((p=a[u])==null?void 0:p.accounts,O)}}),a)}function dist_index_es_yn(t){return t.includes(":")}function dist_index_es_yo(t){return dist_index_es_yn(t)?t.split(":")[0]:t}function dist_index_es_ie(t){var e,n,r;const o={};if(!index_es_Oe(t))return o;for(const[i,s]of Object.entries(t)){const c=dist_index_es_yn(i)?[i]:s.chains,a=s.methods||[],u=s.events||[],l=dist_index_es_yo(i);o[l]=index_es_oa(index_es_ra({},o[l]),{chains:index_es_ot(c,(e=o[l])==null?void 0:e.chains),methods:index_es_ot(a,(n=o[l])==null?void 0:n.methods),events:index_es_ot(u,(r=o[l])==null?void 0:r.events)})}return o}function dist_index_es_mo(t){const e={};return t?.forEach(n=>{var r;const[o,i]=n.split(":");e[o]||(e[o]={accounts:[],chains:[],events:[],methods:[]}),e[o].accounts.push(n),(r=e[o].chains)==null||r.push(`${o}:${i}`)}),e}function index_es_ca(t,e){e=e.map(r=>r.replace("did:pkh:",""));const n=dist_index_es_mo(e);for(const[r,o]of Object.entries(n))o.methods?o.methods=index_es_ot(o.methods,t):o.methods=t,o.events=["chainChanged","accountsChanged"];return n}function index_es_aa(t,e){var n,r,o,i,s,c;const a=dist_index_es_ie(t),u=dist_index_es_ie(e),l={},f=Object.keys(a).concat(Object.keys(u));for(const h of f)l[h]={chains:index_es_ot((n=a[h])==null?void 0:n.chains,(r=u[h])==null?void 0:r.chains),methods:index_es_ot((o=a[h])==null?void 0:o.methods,(i=u[h])==null?void 0:i.methods),events:index_es_ot((s=a[h])==null?void 0:s.events,(c=u[h])==null?void 0:c.events)};return l}const dist_index_es_wo={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},dist_index_es_bo={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function index_es_ht(t,e){const{message:n,code:r}=dist_index_es_bo[t];return{message:e?`${n} ${e}`:n,code:r}}function dist_index_es_Nt(t,e){const{message:n,code:r}=dist_index_es_wo[t];return{message:e?`${n} ${e}`:n,code:r}}function dist_index_es_se(t,e){return Array.isArray(t)?typeof e<"u"&&t.length?t.every(e):!0:!1}function index_es_Oe(t){return Object.getPrototypeOf(t)===Object.prototype&&Object.keys(t).length}function dist_index_es_Et(t){return typeof t>"u"}function index_es_nt(t,e){return e&&dist_index_es_Et(t)?!0:typeof t=="string"&&!!t.trim().length}function index_es_Ae(t,e){return e&&dist_index_es_Et(t)?!0:typeof t=="number"&&!isNaN(t)}function index_es_ua(t,e){const{requiredNamespaces:n}=e,r=Object.keys(t.namespaces),o=Object.keys(n);let i=!0;return index_es_gt(o,r)?(r.forEach(s=>{const{accounts:c,methods:a,events:u}=t.namespaces[s],l=dist_index_es_It(c),f=n[s];(!index_es_gt(dist_index_es_ue(s,f),l)||!index_es_gt(f.methods,a)||!index_es_gt(f.events,u))&&(i=!1)}),i):!1}function index_es_ce(t){return index_es_nt(t,!1)&&t.includes(":")?t.split(":").length===2:!1}function dist_index_es_Eo(t){if(index_es_nt(t,!1)&&t.includes(":")){const e=t.split(":");if(e.length===3){const n=e[0]+":"+e[1];return!!e[2]&&index_es_ce(n)}}return!1}function index_es_fa(t){function e(n){try{return typeof new URL(n)<"u"}catch{return!1}}try{if(index_es_nt(t,!1)){if(e(t))return!0;const n=dist_index_es_je(t);return e(n)}}catch{}return!1}function index_es_la(t){var e;return(e=t?.proposer)==null?void 0:e.publicKey}function index_es_da(t){return t?.topic}function index_es_ha(t,e){let n=null;return index_es_nt(t?.publicKey,!1)||(n=index_es_ht("MISSING_OR_INVALID",`${e} controller public key should be a string`)),n}function dist_index_es_mn(t){let e=!0;return dist_index_es_se(t)?t.length&&(e=t.every(n=>index_es_nt(n,!1))):e=!1,e}function dist_index_es_vo(t,e,n){let r=null;return dist_index_es_se(e)&&e.length?e.forEach(o=>{r||index_es_ce(o)||(r=dist_index_es_Nt("UNSUPPORTED_CHAINS",`${n}, chain ${o} should be a string and conform to "namespace:chainId" format`))}):index_es_ce(t)||(r=dist_index_es_Nt("UNSUPPORTED_CHAINS",`${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),r}function dist_index_es_xo(t,e,n){let r=null;return Object.entries(t).forEach(([o,i])=>{if(r)return;const s=dist_index_es_vo(o,dist_index_es_ue(o,i),`${e} ${n}`);s&&(r=s)}),r}function dist_index_es_So(t,e){let n=null;return dist_index_es_se(t)?t.forEach(r=>{n||dist_index_es_Eo(r)||(n=dist_index_es_Nt("UNSUPPORTED_ACCOUNTS",`${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`))}):n=dist_index_es_Nt("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),n}function dist_index_es_Oo(t,e){let n=null;return Object.values(t).forEach(r=>{if(n)return;const o=dist_index_es_So(r?.accounts,`${e} namespace`);o&&(n=o)}),n}function dist_index_es_Ao(t,e){let n=null;return dist_index_es_mn(t?.methods)?dist_index_es_mn(t?.events)||(n=dist_index_es_Nt("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):n=dist_index_es_Nt("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),n}function dist_index_es_wn(t,e){let n=null;return Object.values(t).forEach(r=>{if(n)return;const o=dist_index_es_Ao(r,`${e}, namespace`);o&&(n=o)}),n}function index_es_pa(t,e,n){let r=null;if(t&&index_es_Oe(t)){const o=dist_index_es_wn(t,e);o&&(r=o);const i=dist_index_es_xo(t,e,n);i&&(r=i)}else r=index_es_ht("MISSING_OR_INVALID",`${e}, ${n} should be an object with data`);return r}function dist_index_es_Bo(t,e){let n=null;if(t&&index_es_Oe(t)){const r=dist_index_es_wn(t,e);r&&(n=r);const o=dist_index_es_Oo(t,e);o&&(n=o)}else n=index_es_ht("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return n}function dist_index_es_Io(t){return index_es_nt(t.protocol,!0)}function index_es_ga(t,e){let n=!1;return e&&!t?n=!0:t&&dist_index_es_se(t)&&t.length&&t.forEach(r=>{n=dist_index_es_Io(r)}),n}function index_es_ya(t){return typeof t=="number"}function index_es_ma(t){return typeof t<"u"&&typeof t!==null}function index_es_wa(t){return!(!t||typeof t!="object"||!t.code||!index_es_Ae(t.code,!1)||!t.message||!index_es_nt(t.message,!1))}function index_es_ba(t){return!(dist_index_es_Et(t)||!index_es_nt(t.method,!1))}function index_es_Ea(t){return!(dist_index_es_Et(t)||dist_index_es_Et(t.result)&&dist_index_es_Et(t.error)||!index_es_Ae(t.id,!1)||!index_es_nt(t.jsonrpc,!1))}function index_es_va(t){return!(dist_index_es_Et(t)||!index_es_nt(t.name,!1))}function index_es_xa(t,e){return!(!index_es_ce(e)||!dist_index_es_ho(t).includes(e))}function index_es_Sa(t,e,n){return index_es_nt(n,!1)?dist_index_es_po(t,e).includes(n):!1}function index_es_Oa(t,e,n){return index_es_nt(n,!1)?dist_index_es_go(t,e).includes(n):!1}function dist_index_es_No(t,e,n){let r=null;const o=index_es_Aa(t),i=index_es_Ba(e),s=Object.keys(o),c=Object.keys(i),a=dist_index_es_Uo(Object.keys(t)),u=dist_index_es_Uo(Object.keys(e)),l=a.filter(f=>!u.includes(f));return l.length&&(r=index_es_ht("NON_CONFORMING_NAMESPACES",`${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)),index_es_gt(s,c)||(r=index_es_ht("NON_CONFORMING_NAMESPACES",`${n} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${c.toString()}`)),Object.keys(e).forEach(f=>{if(!f.includes(":")||r)return;const h=dist_index_es_It(e[f].accounts);h.includes(f)||(r=index_es_ht("NON_CONFORMING_NAMESPACES",`${n} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${h.toString()}`))}),s.forEach(f=>{r||(index_es_gt(o[f].methods,i[f].methods)?index_es_gt(o[f].events,i[f].events)||(r=index_es_ht("NON_CONFORMING_NAMESPACES",`${n} namespaces events don't satisfy namespace events for ${f}`)):r=index_es_ht("NON_CONFORMING_NAMESPACES",`${n} namespaces methods don't satisfy namespace methods for ${f}`))}),r}function index_es_Aa(t){const e={};return Object.keys(t).forEach(n=>{var r;n.includes(":")?e[n]=t[n]:(r=t[n].chains)==null||r.forEach(o=>{e[o]={methods:t[n].methods,events:t[n].events}})}),e}function dist_index_es_Uo(t){return[...new Set(t.map(e=>e.includes(":")?e.split(":")[0]:e))]}function index_es_Ba(t){const e={};return Object.keys(t).forEach(n=>{if(n.includes(":"))e[n]=t[n];else{const r=dist_index_es_It(t[n].accounts);r?.forEach(o=>{e[o]={accounts:t[n].accounts.filter(i=>i.includes(`${o}:`)),methods:t[n].methods,events:t[n].events}})}}),e}function index_es_Ia(t,e){return index_es_Ae(t,!1)&&t<=e.max&&t>=e.min}function index_es_Na(){const t=dist_index_es_xt();return new Promise(e=>{switch(t){case dist_index_es_Y.browser:e(dist_index_es_To());break;case dist_index_es_Y.reactNative:e(dist_index_es_Ro());break;case dist_index_es_Y.node:e(dist_index_es_o());break;default:e(!0)}})}function dist_index_es_To(){return dist_index_es_Tt()&&navigator?.onLine}async function dist_index_es_Ro(){if(index_es_pt()&&typeof global<"u"&&global!=null&&global.NetInfo){const t=await(global==null?void 0:global.NetInfo.fetch());return t?.isConnected}return!0}function dist_index_es_o(){return!0}function index_es_Ua(t){switch(dist_index_es_xt()){case dist_index_es_Y.browser:dist_index_es_$o(t);break;case dist_index_es_Y.reactNative:dist_index_es_Lo(t);break;case dist_index_es_Y.node:break}}function dist_index_es_$o(t){!index_es_pt()&&dist_index_es_Tt()&&(window.addEventListener("online",()=>t(!0)),window.addEventListener("offline",()=>t(!1)))}function dist_index_es_Lo(t){index_es_pt()&&typeof global<"u"&&global!=null&&global.NetInfo&&global?.NetInfo.addEventListener(e=>t(e?.isConnected))}function index_es_Ta(){var t;return dist_index_es_Tt()&&Yt()?((t=Yt())==null?void 0:t.visibilityState)==="visible":!0}const dist_index_es_bn={};class index_es_Ra{static get(e){return dist_index_es_bn[e]}static set(e,n){dist_index_es_bn[e]=n}static delete(e){delete dist_index_es_bn[e]}}
//# sourceMappingURL=index.es.js.map

;// ./node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/sign-client/dist/index.es.js
const dist_index_es_De="wc",sign_client_dist_index_es_Le=2,sign_client_dist_index_es_ke="client",dist_index_es_we=`${dist_index_es_De}@${sign_client_dist_index_es_Le}:${sign_client_dist_index_es_ke}:`,dist_index_es_me={name:sign_client_dist_index_es_ke,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},dist_index_es_ws={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},dist_index_es_ms={database:":memory:"},sign_client_dist_index_es_Me="WALLETCONNECT_DEEPLINK_CHOICE",dist_index_es_s={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},dist_index_es_Es="history",dist_index_es_fs="0.3",dist_index_es_pt="proposal",dist_index_es_Ss=(/* unused pure expression or super */ null && (kt)),dist_index_es_$e="Proposal expired",dist_index_es_ht="session",index_es_J=cjs.SEVEN_DAYS,dist_index_es_dt="engine",N={wc_sessionPropose:{req:{ttl:cjs.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:1104},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:1106},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:cjs.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:cjs.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:1112},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:cjs.ONE_DAY,prompt:!1,tag:1114},res:{ttl:cjs.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:cjs.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:cjs.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:cjs.FIVE_MINUTES,prompt:!1,tag:1119}}},sign_client_dist_index_es_e={min:cjs.FIVE_MINUTES,max:cjs.SEVEN_DAYS},dist_index_es_$={idle:"IDLE",active:"ACTIVE"},sign_client_dist_index_es_Ke={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},dist_index_es_ut="request",dist_index_es_gt=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],dist_index_es_yt="wc",dist_index_es_Rs=1.5,dist_index_es_wt="auth",dist_index_es_mt="authKeys",dist_index_es_t="pairingTopics",sign_client_dist_index_es_Et="requests",dist_index_es_ae=`${dist_index_es_yt}@${1.5}:${dist_index_es_wt}:`,dist_index_es_ce=`${dist_index_es_ae}:PUB_KEY`;var dist_index_es_vs=Object.defineProperty,dist_index_es_Is=Object.defineProperties,dist_index_es_Ts=Object.getOwnPropertyDescriptors,dist_index_es_ft=Object.getOwnPropertySymbols,dist_index_es_qs=Object.prototype.hasOwnProperty,dist_index_es_Ps=Object.prototype.propertyIsEnumerable,sign_client_dist_index_es_Ue=(S,n,e)=>n in S?dist_index_es_vs(S,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[n]=e,dist_index_es_v=(S,n)=>{for(var e in n||(n={}))dist_index_es_qs.call(n,e)&&sign_client_dist_index_es_Ue(S,e,n[e]);if(dist_index_es_ft)for(var e of dist_index_es_ft(n))dist_index_es_Ps.call(n,e)&&sign_client_dist_index_es_Ue(S,e,n[e]);return S},index_es_b=(S,n)=>dist_index_es_Is(S,dist_index_es_Ts(n)),dist_index_es_c=(S,n,e)=>sign_client_dist_index_es_Ue(S,typeof n!="symbol"?n+"":n,e);class dist_index_es_Ns extends V{constructor(n){super(n),dist_index_es_c(this,"name",dist_index_es_dt),dist_index_es_c(this,"events",new (external_events_default())),dist_index_es_c(this,"initialized",!1),dist_index_es_c(this,"requestQueue",{state:dist_index_es_$.idle,queue:[]}),dist_index_es_c(this,"sessionRequestQueue",{state:dist_index_es_$.idle,queue:[]}),dist_index_es_c(this,"requestQueueDelay",cjs.ONE_SECOND),dist_index_es_c(this,"expectedPairingMethodMap",new Map),dist_index_es_c(this,"recentlyDeletedMap",new Map),dist_index_es_c(this,"recentlyDeletedLimit",200),dist_index_es_c(this,"relayMessageCache",[]),dist_index_es_c(this,"pendingSessions",new Map),dist_index_es_c(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(N)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,cjs.toMiliseconds)(this.requestQueueDelay)))}),dist_index_es_c(this,"connect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=index_es_b(dist_index_es_v({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t),t.optionalNamespaces=index_es_aa(t.requiredNamespaces,t.optionalNamespaces),t.requiredNamespaces={};const{pairingTopic:s,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:o,scopedProperties:a,relays:l}=t;let p=s,h,u=!1;try{if(p){const T=this.client.core.pairing.pairings.get(p);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),u=T.active}}catch(T){throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`),T}if(!p||!u){const{topic:T,uri:K}=await this.client.core.pairing.create();p=T,h=K}if(!p){const{message:T}=index_es_ht("NO_MATCHING_KEY",`connect() pairing topic: ${p}`);throw new Error(T)}const d=await this.client.core.crypto.generateKeyPair(),w=N.wc_sessionPropose.req.ttl||cjs.FIVE_MINUTES,m=dist_index_es_Ei(w),f=index_es_b(dist_index_es_v(dist_index_es_v({requiredNamespaces:i,optionalNamespaces:r,relays:l??[{protocol:index_es_xt}],proposer:{publicKey:d,metadata:this.client.metadata},expiryTimestamp:m,pairingTopic:p},o&&{sessionProperties:o}),a&&{scopedProperties:a}),{id:(0,dist_esm.payloadId)()}),_=dist_index_es_xi("session_connect",f.id),{reject:g,resolve:A,done:D}=dist_index_es_gi(w,dist_index_es_$e),I=({id:T})=>{T===f.id&&(this.client.events.off("proposal_expire",I),this.pendingSessions.delete(f.id),this.events.emit(_,{error:{message:dist_index_es_$e,code:0}}))};return this.client.events.on("proposal_expire",I),this.events.once(_,({error:T,session:K})=>{this.client.events.off("proposal_expire",I),T?g(T):K&&A(K)}),await this.sendRequest({topic:p,method:"wc_sessionPropose",params:f,throwOnFailedPublish:!0,clientRpcId:f.id}),await this.setProposal(f.id,f),{uri:h,approval:D}}),dist_index_es_c(this,"pair",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}}),dist_index_es_c(this,"approve",async e=>{var t,s,i;const r=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[index_es_er.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(q){throw r.setError(index_es_tr.no_internet_connection),q}try{await this.isValidProposalId(e?.id)}catch(q){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),r.setError(index_es_tr.proposal_not_found),q}try{await this.isValidApprove(e)}catch(q){throw this.client.logger.error("approve() -> isValidApprove() failed"),r.setError(index_es_tr.session_approve_namespace_validation_failure),q}const{id:o,relayProtocol:a,namespaces:l,sessionProperties:p,scopedProperties:h,sessionConfig:u}=e,d=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:r.eventId});const{pairingTopic:w,proposer:m,requiredNamespaces:f,optionalNamespaces:_}=d;let g=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:w});g||(g=(i=this.client.core.eventClient)==null?void 0:i.createEvent({type:index_es_er.session_approve_started,properties:{topic:w,trace:[index_es_er.session_approve_started,index_es_er.session_namespaces_validation_success]}}));const A=await this.client.core.crypto.generateKeyPair(),D=m.publicKey,I=await this.client.core.crypto.generateSharedKey(A,D),T=dist_index_es_v(dist_index_es_v(dist_index_es_v({relay:{protocol:a??"irn"},namespaces:l,controller:{publicKey:A,metadata:this.client.metadata},expiry:dist_index_es_Ei(index_es_J)},p&&{sessionProperties:p}),h&&{scopedProperties:h}),u&&{sessionConfig:u}),K=index_es_Q.relay;g.addTrace(index_es_er.subscribing_session_topic);try{await this.client.core.relayer.subscribe(I,{transportType:K})}catch(q){throw g.setError(index_es_tr.subscribe_session_topic_failure),q}g.addTrace(index_es_er.subscribe_session_topic_success);const fe=index_es_b(dist_index_es_v({},T),{topic:I,requiredNamespaces:f,optionalNamespaces:_,pairingTopic:w,acknowledged:!1,self:T.controller,peer:{publicKey:m.publicKey,metadata:m.metadata},controller:A,transportType:index_es_Q.relay});await this.client.session.set(I,fe),g.addTrace(index_es_er.store_session);try{g.addTrace(index_es_er.publishing_session_settle),await this.sendRequest({topic:I,method:"wc_sessionSettle",params:T,throwOnFailedPublish:!0}).catch(q=>{throw g?.setError(index_es_tr.session_settle_publish_failure),q}),g.addTrace(index_es_er.session_settle_publish_success),g.addTrace(index_es_er.publishing_session_approve),await this.sendResult({id:o,topic:w,result:{relay:{protocol:a??"irn"},responderPublicKey:A},throwOnFailedPublish:!0}).catch(q=>{throw g?.setError(index_es_tr.session_approve_publish_failure),q}),g.addTrace(index_es_er.session_approve_publish_success)}catch(q){throw this.client.logger.error(q),this.client.session.delete(I,dist_index_es_Nt("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(I),q}return this.client.core.eventClient.deleteEvent({eventId:g.eventId}),await this.client.core.pairing.updateMetadata({topic:w,metadata:m.metadata}),await this.client.proposal.delete(o,dist_index_es_Nt("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:w}),await this.setExpiry(I,dist_index_es_Ei(index_es_J)),{topic:I,acknowledged:()=>Promise.resolve(this.client.session.get(I))}}),dist_index_es_c(this,"reject",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(r){throw this.client.logger.error("reject() -> isValidReject() failed"),r}const{id:t,reason:s}=e;let i;try{i=this.client.proposal.get(t).pairingTopic}catch(r){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),r}i&&(await this.sendError({id:t,topic:i,error:s,rpcOpts:N.wc_sessionPropose.reject}),await this.client.proposal.delete(t,dist_index_es_Nt("USER_DISCONNECTED")))}),dist_index_es_c(this,"update",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(h){throw this.client.logger.error("update() -> isValidUpdate() failed"),h}const{topic:t,namespaces:s}=e,{done:i,resolve:r,reject:o}=dist_index_es_gi(),a=(0,dist_esm.payloadId)(),l=(0,dist_esm.getBigIntRpcId)().toString(),p=this.client.session.get(t).namespaces;return this.events.once(dist_index_es_xi("session_update",a),({error:h})=>{h?o(h):r()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:l}).catch(h=>{this.client.logger.error(h),this.client.session.update(t,{namespaces:p}),o(h)}),{acknowledged:i}}),dist_index_es_c(this,"extend",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:t}=e,s=(0,dist_esm.payloadId)(),{done:i,resolve:r,reject:o}=dist_index_es_gi();return this.events.once(dist_index_es_xi("session_extend",s),({error:a})=>{a?o(a):r()}),await this.setExpiry(t,dist_index_es_Ei(index_es_J)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(a=>{o(a)}),{acknowledged:i}}),dist_index_es_c(this,"request",async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(_){throw this.client.logger.error("request() -> isValidRequest() failed"),_}const{chainId:t,request:s,topic:i,expiry:r=N.wc_sessionRequest.req.ttl}=e,o=this.client.session.get(i);o?.transportType===index_es_Q.relay&&await this.confirmOnlineStateOrThrow();const a=(0,dist_esm.payloadId)(),l=(0,dist_esm.getBigIntRpcId)().toString(),{done:p,resolve:h,reject:u}=dist_index_es_gi(r,"Request expired. Please try again.");this.events.once(dist_index_es_xi("session_request",a),({error:_,result:g})=>{_?u(_):h(g)});const d="wc_sessionRequest",w=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(w)return await this.sendRequest({clientRpcId:a,relayRpcId:l,topic:i,method:d,params:{request:index_es_b(dist_index_es_v({},s),{expiryTimestamp:dist_index_es_Ei(r)}),chainId:t},expiry:r,throwOnFailedPublish:!0,appLink:w}).catch(_=>u(_)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:a}),await p();const m={request:index_es_b(dist_index_es_v({},s),{expiryTimestamp:dist_index_es_Ei(r)}),chainId:t},f=this.shouldSetTVF(d,m);return await Promise.all([new Promise(async _=>{await this.sendRequest(dist_index_es_v({clientRpcId:a,relayRpcId:l,topic:i,method:d,params:m,expiry:r,throwOnFailedPublish:!0},f&&{tvf:this.getTVFParams(a,m)})).catch(g=>u(g)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:a}),_()}),new Promise(async _=>{var g;if(!((g=o.sessionConfig)!=null&&g.disableDeepLink)){const A=await dist_index_es_Oi(this.client.core.storage,sign_client_dist_index_es_Me);await dist_index_es_Si({id:a,topic:i,wcDeepLink:A})}_()}),p()]).then(_=>_[2])}),dist_index_es_c(this,"respond",async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:i}=s,r=this.client.session.get(t);r.transportType===index_es_Q.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(r.peer.metadata,r.transportType);(0,dist_esm.isJsonRpcResult)(s)?await this.sendResult({id:i,topic:t,result:s.result,throwOnFailedPublish:!0,appLink:o}):(0,dist_esm.isJsonRpcError)(s)&&await this.sendError({id:i,topic:t,error:s.error,appLink:o}),this.cleanupAfterResponse(e)}),dist_index_es_c(this,"ping",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=(0,dist_esm.payloadId)(),i=(0,dist_esm.getBigIntRpcId)().toString(),{done:r,resolve:o,reject:a}=dist_index_es_gi();this.events.once(dist_index_es_xi("session_ping",s),({error:l})=>{l?a(l):o()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:i}),r()])}else this.client.core.pairing.pairings.keys.includes(t)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:t}))}),dist_index_es_c(this,"emit",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:i}=e,r=(0,dist_esm.getBigIntRpcId)().toString(),o=(0,dist_esm.payloadId)();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:i},throwOnFailedPublish:!0,relayRpcId:r,clientRpcId:o})}),dist_index_es_c(this,"disconnect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:dist_index_es_Nt("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=index_es_ht("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}}),dist_index_es_c(this,"find",e=>(this.isInitialized(),this.client.session.getAll().filter(t=>index_es_ua(t,e)))),dist_index_es_c(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),dist_index_es_c(this,"authenticate",async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const i=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),r=i?index_es_Q.link_mode:index_es_Q.relay;r===index_es_Q.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:a="",uri:l,domain:p,nonce:h,type:u,exp:d,nbf:w,methods:m=[],expiry:f}=e,_=[...e.resources||[]],{topic:g,uri:A}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:r});this.client.logger.info({message:"Generated new pairing",pairing:{topic:g,uri:A}});const D=await this.client.core.crypto.generateKeyPair(),I=index_es_Pc(D);if(await Promise.all([this.client.auth.authKeys.set(dist_index_es_ce,{responseTopic:I,publicKey:D}),this.client.auth.pairingTopics.set(I,{topic:I,pairingTopic:g})]),await this.client.core.relayer.subscribe(I,{transportType:r}),this.client.logger.info(`sending request to new pairing topic: ${g}`),m.length>0){const{namespace:x}=index_es_Ne(o[0]);let L=index_es_fs(x,"request",m);dist_index_es_pe(_)&&(L=index_es_ls(L,_.pop())),_.push(L)}const T=f&&f>N.wc_sessionAuthenticate.req.ttl?f:N.wc_sessionAuthenticate.req.ttl,K={authPayload:{type:u??"caip122",chains:o,statement:a,aud:l,domain:p,version:"1",nonce:h,iat:new Date().toISOString(),exp:d,nbf:w,resources:_},requester:{publicKey:D,metadata:this.client.metadata},expiryTimestamp:dist_index_es_Ei(T)},fe={eip155:{chains:o,methods:[...new Set(["personal_sign",...m])],events:["chainChanged","accountsChanged"]}},q={requiredNamespaces:{},optionalNamespaces:fe,relays:[{protocol:"irn"}],pairingTopic:g,proposer:{publicKey:D,metadata:this.client.metadata},expiryTimestamp:dist_index_es_Ei(N.wc_sessionPropose.req.ttl),id:(0,dist_esm.payloadId)()},{done:Rt,resolve:je,reject:Se}=dist_index_es_gi(T,"Request expired"),te=(0,dist_esm.payloadId)(),le=dist_index_es_xi("session_connect",q.id),Re=dist_index_es_xi("session_request",te),pe=async({error:x,session:L})=>{this.events.off(Re,ve),x?Se(x):L&&je({session:L})},ve=async x=>{var L,Fe,Qe;if(await this.deletePendingAuthRequest(te,{message:"fulfilled",code:0}),x.error){const ie=dist_index_es_Nt("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return x.error.code===ie.code?void 0:(this.events.off(le,pe),Se(x.error.message))}await this.deleteProposal(q.id),this.events.off(le,pe);const{cacaos:He,responder:Q}=x.result,Te=[],ze=[];for(const ie of He){await index_es_is({cacao:ie,projectId:this.client.core.projectId})||(this.client.logger.error(ie,"Signature verification failed"),Se(dist_index_es_Nt("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:qe}=ie,Pe=dist_index_es_pe(qe.resources),Ye=[dist_index_es_dr(qe.iss)],vt=index_es_De(qe.iss);if(Pe){const Ne=index_es_ds(Pe),It=index_es_hs(Pe);Te.push(...Ne),Ye.push(...It)}for(const Ne of Ye)ze.push(`${Ne}:${vt}`)}const se=await this.client.core.crypto.generateSharedKey(D,Q.publicKey);let he;Te.length>0&&(he={topic:se,acknowledged:!0,self:{publicKey:D,metadata:this.client.metadata},peer:Q,controller:Q.publicKey,expiry:dist_index_es_Ei(index_es_J),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:g,namespaces:index_es_ca([...new Set(Te)],[...new Set(ze)]),transportType:r},await this.client.core.relayer.subscribe(se,{transportType:r}),await this.client.session.set(se,he),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:Q.metadata}),he=this.client.session.get(se)),(L=this.client.metadata.redirect)!=null&&L.linkMode&&(Fe=Q.metadata.redirect)!=null&&Fe.linkMode&&(Qe=Q.metadata.redirect)!=null&&Qe.universal&&t&&(this.client.core.addLinkModeSupportedApp(Q.metadata.redirect.universal),this.client.session.update(se,{transportType:index_es_Q.link_mode})),je({auths:He,session:he})};this.events.once(le,pe),this.events.once(Re,ve);let Ie;try{if(i){const x=(0,dist_esm.formatJsonRpcRequest)("wc_sessionAuthenticate",K,te);this.client.core.history.set(g,x);const L=await this.client.core.crypto.encode("",x,{type:dist_index_es_re,encoding:index_es_xe});Ie=index_es_Xc(t,g,L)}else await Promise.all([this.sendRequest({topic:g,method:"wc_sessionAuthenticate",params:K,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:te}),this.sendRequest({topic:g,method:"wc_sessionPropose",params:q,expiry:N.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:q.id})])}catch(x){throw this.events.off(le,pe),this.events.off(Re,ve),x}return await this.setProposal(q.id,q),await this.setAuthRequest(te,{request:index_es_b(dist_index_es_v({},K),{verifyContext:{}}),pairingTopic:g,transportType:r}),{uri:Ie??A,response:Rt}}),dist_index_es_c(this,"approveSessionAuthenticate",async e=>{const{id:t,auths:s}=e,i=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[index_es_ir.authenticated_session_approve_started]}});try{this.isInitialized()}catch(f){throw i.setError(index_es_sr.no_internet_connection),f}const r=this.getPendingAuthRequest(t);if(!r)throw i.setError(index_es_sr.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const o=r.transportType||index_es_Q.relay;o===index_es_Q.relay&&await this.confirmOnlineStateOrThrow();const a=r.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),p=index_es_Pc(a),h={type:dist_index_es_Ft,receiverPublicKey:a,senderPublicKey:l},u=[],d=[];for(const f of s){if(!await index_es_is({cacao:f,projectId:this.client.core.projectId})){i.setError(index_es_sr.invalid_cacao);const I=dist_index_es_Nt("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:p,error:I,encodeOpts:h}),new Error(I.message)}i.addTrace(index_es_ir.cacaos_verified);const{p:_}=f,g=dist_index_es_pe(_.resources),A=[dist_index_es_dr(_.iss)],D=index_es_De(_.iss);if(g){const I=index_es_ds(g),T=index_es_hs(g);u.push(...I),A.push(...T)}for(const I of A)d.push(`${I}:${D}`)}const w=await this.client.core.crypto.generateSharedKey(l,a);i.addTrace(index_es_ir.create_authenticated_session_topic);let m;if(u?.length>0){m={topic:w,acknowledged:!0,self:{publicKey:l,metadata:this.client.metadata},peer:{publicKey:a,metadata:r.requester.metadata},controller:a,expiry:dist_index_es_Ei(index_es_J),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:r.pairingTopic,namespaces:index_es_ca([...new Set(u)],[...new Set(d)]),transportType:o},i.addTrace(index_es_ir.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(w,{transportType:o})}catch(f){throw i.setError(index_es_sr.subscribe_authenticated_session_topic_failure),f}i.addTrace(index_es_ir.subscribe_authenticated_session_topic_success),await this.client.session.set(w,m),i.addTrace(index_es_ir.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:r.pairingTopic,metadata:r.requester.metadata})}i.addTrace(index_es_ir.publishing_authenticated_session_approve);try{await this.sendResult({topic:p,id:t,result:{cacaos:s,responder:{publicKey:l,metadata:this.client.metadata}},encodeOpts:h,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(r.requester.metadata,o)})}catch(f){throw i.setError(index_es_sr.authenticated_session_approve_publish_failure),f}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:i.eventId}),{session:m}}),dist_index_es_c(this,"rejectSessionAuthenticate",async e=>{this.isInitialized();const{id:t,reason:s}=e,i=this.getPendingAuthRequest(t);if(!i)throw new Error(`Could not find pending auth request with id ${t}`);i.transportType===index_es_Q.relay&&await this.confirmOnlineStateOrThrow();const r=i.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=index_es_Pc(r),l={type:dist_index_es_Ft,receiverPublicKey:r,senderPublicKey:o};await this.sendError({id:t,topic:a,error:s,encodeOpts:l,rpcOpts:N.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(i.requester.metadata,i.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,dist_index_es_Nt("USER_DISCONNECTED"))}),dist_index_es_c(this,"formatAuthMessage",e=>{this.isInitialized();const{request:t,iss:s}=e;return dist_index_es_hr(t,s)}),dist_index_es_c(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)}),dist_index_es_c(this,"cleanupDuplicatePairings",async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(i=>{var r,o;return((r=i.peerMetadata)==null?void 0:r.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}}),dist_index_es_c(this,"deleteSession",async e=>{var t;const{topic:s,expirerHasDeleted:i=!1,emitEvent:r=!0,id:o=0}=e,{self:a}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,dist_index_es_Nt("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),i||this.client.core.expirer.del(s),this.client.core.storage.removeItem(sign_client_dist_index_es_Me).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===s&&this.deletePendingSessionRequest(l.id,dist_index_es_Nt("USER_DISCONNECTED"))}),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=dist_index_es_$.idle),r&&this.client.events.emit("session_delete",{id:o,topic:s})}),dist_index_es_c(this,"deleteProposal",async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),i=this.client.core.eventClient.getEvent({topic:s.pairingTopic});i?.setError(index_es_tr.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,dist_index_es_Nt("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")}),dist_index_es_c(this,"deletePendingSessionRequest",async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==e),s&&(this.sessionRequestQueue.state=dist_index_es_$.idle,this.client.events.emit("session_request_expire",{id:e}))}),dist_index_es_c(this,"deletePendingAuthRequest",async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])}),dist_index_es_c(this,"setExpiry",async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))}),dist_index_es_c(this,"setProposal",async(e,t)=>{this.client.core.expirer.set(e,dist_index_es_Ei(N.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)}),dist_index_es_c(this,"setAuthRequest",async(e,t)=>{const{request:s,pairingTopic:i,transportType:r=index_es_Q.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:i,verifyContext:s.verifyContext,transportType:r})}),dist_index_es_c(this,"setPendingSessionRequest",async e=>{const{id:t,topic:s,params:i,verifyContext:r}=e,o=i.request.expiryTimestamp||dist_index_es_Ei(N.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,o),await this.client.pendingRequest.set(t,{id:t,topic:s,params:i,verifyContext:r})}),dist_index_es_c(this,"sendRequest",async e=>{const{topic:t,method:s,params:i,expiry:r,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:l,appLink:p,tvf:h}=e,u=(0,dist_esm.formatJsonRpcRequest)(s,i,a);let d;const w=!!p;try{const _=w?index_es_xe:dist_index_es_qt;d=await this.client.core.crypto.encode(t,u,{encoding:_})}catch(_){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),_}let m;if(dist_index_es_gt.includes(s)){const _=index_es_kc(JSON.stringify(u)),g=index_es_kc(d);m=await this.client.core.verify.register({id:g,decryptedId:_})}const f=N[s].req;if(f.attestation=m,r&&(f.ttl=r),o&&(f.id=o),this.client.core.history.set(t,u),w){const _=index_es_Xc(p,t,d);await global.Linking.openURL(_,this.client.name)}else{const _=N[s].req;r&&(_.ttl=r),o&&(_.id=o),_.tvf=index_es_b(dist_index_es_v({},h),{correlationId:u.id}),l?(_.internal=index_es_b(dist_index_es_v({},_.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,d,_)):this.client.core.relayer.publish(t,d,_).catch(g=>this.client.logger.error(g))}return u.id}),dist_index_es_c(this,"sendResult",async e=>{const{id:t,topic:s,result:i,throwOnFailedPublish:r,encodeOpts:o,appLink:a}=e,l=(0,dist_esm.formatJsonRpcResult)(t,i);let p;const h=a&&typeof(global==null?void 0:global.Linking)<"u";try{const w=h?index_es_xe:dist_index_es_qt;p=await this.client.core.crypto.encode(s,l,index_es_b(dist_index_es_v({},o||{}),{encoding:w}))}catch(w){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),w}let u,d;try{u=await this.client.core.history.get(s,t);const w=u.request;try{this.shouldSetTVF(w.method,w.params)&&(d=this.getTVFParams(t,w.params,i))}catch(m){this.client.logger.warn("sendResult() -> getTVFParams() failed",m)}}catch(w){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),w}if(h){const w=index_es_Xc(a,s,p);await global.Linking.openURL(w,this.client.name)}else{const w=u.request.method,m=N[w].res;m.tvf=index_es_b(dist_index_es_v({},d),{correlationId:t}),r?(m.internal=index_es_b(dist_index_es_v({},m.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,p,m)):this.client.core.relayer.publish(s,p,m).catch(f=>this.client.logger.error(f))}await this.client.core.history.resolve(l)}),dist_index_es_c(this,"sendError",async e=>{const{id:t,topic:s,error:i,encodeOpts:r,rpcOpts:o,appLink:a}=e,l=(0,dist_esm.formatJsonRpcError)(t,i);let p;const h=a&&typeof(global==null?void 0:global.Linking)<"u";try{const d=h?index_es_xe:dist_index_es_qt;p=await this.client.core.crypto.encode(s,l,index_es_b(dist_index_es_v({},r||{}),{encoding:d}))}catch(d){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),d}let u;try{u=await this.client.core.history.get(s,t)}catch(d){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),d}if(h){const d=index_es_Xc(a,s,p);await global.Linking.openURL(d,this.client.name)}else{const d=u.request.method,w=o||N[d].res;this.client.core.relayer.publish(s,p,w)}await this.client.core.history.resolve(l)}),dist_index_es_c(this,"cleanup",async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let i=!1;dist_index_es_vi(s.expiry)&&(i=!0),this.client.core.crypto.keychain.has(s.topic)||(i=!0),i&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{dist_index_es_vi(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])}),dist_index_es_c(this,"onProviderMessageEvent",async e=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(e):await this.onRelayMessage(e)}),dist_index_es_c(this,"onRelayEventRequest",async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()}),dist_index_es_c(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===dist_index_es_$.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=dist_index_es_$.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=dist_index_es_$.idle}),dist_index_es_c(this,"processRequest",async e=>{const{topic:t,payload:s,attestation:i,transportType:r,encryptedId:o}=e,a=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:a}))switch(a){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:i,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:r});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:r});default:return this.client.logger.info(`Unsupported request method ${a}`)}}),dist_index_es_c(this,"onRelayEventResponse",async e=>{const{topic:t,payload:s,transportType:i}=e,r=(await this.client.core.history.get(t,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,i);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}}),dist_index_es_c(this,"onRelayEventUnknownPayload",e=>{const{topic:t}=e,{message:s}=index_es_ht("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),dist_index_es_c(this,"shouldIgnorePairingRequest",e=>{const{topic:t,requestMethod:s}=e,i=this.expectedPairingMethodMap.get(t);return!i||i.includes(s)?!1:!!(i.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),dist_index_es_c(this,"onSessionProposeRequest",async e=>{const{topic:t,payload:s,attestation:i,encryptedId:r}=e,{params:o,id:a}=s;try{const l=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),l?.setError(index_es_Y.proposal_listener_not_found)),this.isValidConnect(dist_index_es_v({},s.params));const p=o.expiryTimestamp||dist_index_es_Ei(N.wc_sessionPropose.req.ttl),h=dist_index_es_v({id:a,pairingTopic:t,expiryTimestamp:p},o);await this.setProposal(a,h);const u=await this.getVerifyContext({attestationId:i,hash:index_es_kc(JSON.stringify(s)),encryptedId:r,metadata:h.proposer.metadata});l?.addTrace(index_es_G.emit_session_proposal),this.client.events.emit("session_proposal",{id:a,params:h,verifyContext:u})}catch(l){await this.sendError({id:a,topic:t,error:l,rpcOpts:N.wc_sessionPropose.autoReject}),this.client.logger.error(l)}}),dist_index_es_c(this,"onSessionProposeResponse",async(e,t,s)=>{const{id:i}=t;if((0,dist_esm.isJsonRpcResult)(t)){const{result:r}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const o=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const a=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const l=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:l});const p=await this.client.core.crypto.generateSharedKey(a,l);this.pendingSessions.set(i,{sessionTopic:p,pairingTopic:e,proposalId:i,publicKey:a});const h=await this.client.core.relayer.subscribe(p,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else if((0,dist_esm.isJsonRpcError)(t)){await this.client.proposal.delete(i,dist_index_es_Nt("USER_DISCONNECTED"));const r=dist_index_es_xi("session_connect",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(r,{error:t.error})}}),dist_index_es_c(this,"onSessionSettleRequest",async(e,t)=>{const{id:s,params:i}=t;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:l,sessionProperties:p,scopedProperties:h,sessionConfig:u}=t.params,d=[...this.pendingSessions.values()].find(f=>f.sessionTopic===e);if(!d)return this.client.logger.error(`Pending session not found for topic ${e}`);const w=this.client.proposal.get(d.proposalId),m=index_es_b(dist_index_es_v(dist_index_es_v(dist_index_es_v({topic:e,relay:r,expiry:a,namespaces:l,acknowledged:!0,pairingTopic:d.pairingTopic,requiredNamespaces:w.requiredNamespaces,optionalNamespaces:w.optionalNamespaces,controller:o.publicKey,self:{publicKey:d.publicKey,metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},p&&{sessionProperties:p}),h&&{scopedProperties:h}),u&&{sessionConfig:u}),{transportType:index_es_Q.relay});await this.client.session.set(m.topic,m),await this.setExpiry(m.topic,m.expiry),await this.client.core.pairing.updateMetadata({topic:d.pairingTopic,metadata:m.peer.metadata}),this.client.events.emit("session_connect",{session:m}),this.events.emit(dist_index_es_xi("session_connect",d.proposalId),{session:m}),this.pendingSessions.delete(d.proposalId),this.deleteProposal(d.proposalId,!1),this.cleanupDuplicatePairings(m),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),dist_index_es_c(this,"onSessionSettleResponse",async(e,t)=>{const{id:s}=t;(0,dist_esm.isJsonRpcResult)(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(dist_index_es_xi("session_approve",s),{})):(0,dist_esm.isJsonRpcError)(t)&&(await this.client.session.delete(e,dist_index_es_Nt("USER_DISCONNECTED")),this.events.emit(dist_index_es_xi("session_approve",s),{error:t.error}))}),dist_index_es_c(this,"onSessionUpdateRequest",async(e,t)=>{const{params:s,id:i}=t;try{const r=`${e}_session_update`,o=index_es_Ra.get(r);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.warn(`Discarding out of sync request - ${i}`),this.sendError({id:i,topic:e,error:dist_index_es_Nt("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(dist_index_es_v({topic:e},s));try{index_es_Ra.set(r,i),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0})}catch(a){throw index_es_Ra.delete(r),a}this.client.events.emit("session_update",{id:i,topic:e,params:s})}catch(r){await this.sendError({id:i,topic:e,error:r}),this.client.logger.error(r)}}),dist_index_es_c(this,"isRequestOutOfSync",(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3)),dist_index_es_c(this,"onSessionUpdateResponse",(e,t)=>{const{id:s}=t,i=dist_index_es_xi("session_update",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);(0,dist_esm.isJsonRpcResult)(t)?this.events.emit(dist_index_es_xi("session_update",s),{}):(0,dist_esm.isJsonRpcError)(t)&&this.events.emit(dist_index_es_xi("session_update",s),{error:t.error})}),dist_index_es_c(this,"onSessionExtendRequest",async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,dist_index_es_Ei(index_es_J)),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),dist_index_es_c(this,"onSessionExtendResponse",(e,t)=>{const{id:s}=t,i=dist_index_es_xi("session_extend",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);(0,dist_esm.isJsonRpcResult)(t)?this.events.emit(dist_index_es_xi("session_extend",s),{}):(0,dist_esm.isJsonRpcError)(t)&&this.events.emit(dist_index_es_xi("session_extend",s),{error:t.error})}),dist_index_es_c(this,"onSessionPingRequest",async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),dist_index_es_c(this,"onSessionPingResponse",(e,t)=>{const{id:s}=t,i=dist_index_es_xi("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners 2176`);(0,dist_esm.isJsonRpcResult)(t)?this.events.emit(dist_index_es_xi("session_ping",s),{}):(0,dist_esm.isJsonRpcError)(t)&&this.events.emit(dist_index_es_xi("session_ping",s),{error:t.error})},500)}),dist_index_es_c(this,"onSessionDeleteRequest",async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(i=>{this.client.core.relayer.once(index_es_C.publish,async()=>{i(await this.deleteSession({topic:e,id:s}))})}),this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:dist_index_es_Nt("USER_DISCONNECTED")})]).catch(i=>this.client.logger.error(i))}catch(i){this.client.logger.error(i)}}),dist_index_es_c(this,"onSessionRequest",async e=>{var t,s,i;const{topic:r,payload:o,attestation:a,encryptedId:l,transportType:p}=e,{id:h,params:u}=o;try{await this.isValidRequest(dist_index_es_v({topic:r},u));const d=this.client.session.get(r),w=await this.getVerifyContext({attestationId:a,hash:index_es_kc(JSON.stringify((0,dist_esm.formatJsonRpcRequest)("wc_sessionRequest",u,h))),encryptedId:l,metadata:d.peer.metadata,transportType:p}),m={id:h,topic:r,params:u,verifyContext:w};await this.setPendingSessionRequest(m),p===index_es_Q.link_mode&&(t=d.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=d.peer.metadata.redirect)==null?void 0:s.universal),(i=this.client.signConfig)!=null&&i.disableRequestQueue?this.emitSessionRequest(m):(this.addSessionRequestToSessionRequestQueue(m),this.processSessionRequestQueue())}catch(d){await this.sendError({id:h,topic:r,error:d}),this.client.logger.error(d)}}),dist_index_es_c(this,"onSessionRequestResponse",(e,t)=>{const{id:s}=t,i=dist_index_es_xi("session_request",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);(0,dist_esm.isJsonRpcResult)(t)?this.events.emit(dist_index_es_xi("session_request",s),{result:t.result}):(0,dist_esm.isJsonRpcError)(t)&&this.events.emit(dist_index_es_xi("session_request",s),{error:t.error})}),dist_index_es_c(this,"onSessionEventRequest",async(e,t)=>{const{id:s,params:i}=t;try{const r=`${e}_session_event_${i.event.name}`,o=index_es_Ra.get(r);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(dist_index_es_v({topic:e},i)),this.client.events.emit("session_event",{id:s,topic:e,params:i}),index_es_Ra.set(r,s)}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),dist_index_es_c(this,"onSessionAuthenticateResponse",(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),(0,dist_esm.isJsonRpcResult)(t)?this.events.emit(dist_index_es_xi("session_request",s),{result:t.result}):(0,dist_esm.isJsonRpcError)(t)&&this.events.emit(dist_index_es_xi("session_request",s),{error:t.error})}),dist_index_es_c(this,"onSessionAuthenticateRequest",async e=>{var t;const{topic:s,payload:i,attestation:r,encryptedId:o,transportType:a}=e;try{const{requester:l,authPayload:p,expiryTimestamp:h}=i.params,u=await this.getVerifyContext({attestationId:r,hash:index_es_kc(JSON.stringify(i)),encryptedId:o,metadata:l.metadata,transportType:a}),d={requester:l,pairingTopic:s,id:i.id,authPayload:p,verifyContext:u,expiryTimestamp:h};await this.setAuthRequest(i.id,{request:d,pairingTopic:s,transportType:a}),a===index_es_Q.link_mode&&(t=l.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:i.params,id:i.id,verifyContext:u})}catch(l){this.client.logger.error(l);const p=i.params.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),u=this.getAppLinkIfEnabled(i.params.requester.metadata,a),d={type:dist_index_es_Ft,receiverPublicKey:p,senderPublicKey:h};await this.sendError({id:i.id,topic:s,error:l,encodeOpts:d,rpcOpts:N.wc_sessionAuthenticate.autoReject,appLink:u})}}),dist_index_es_c(this,"addSessionRequestToSessionRequestQueue",e=>{this.sessionRequestQueue.queue.push(e)}),dist_index_es_c(this,"cleanupAfterResponse",e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=dist_index_es_$.idle,this.processSessionRequestQueue()},(0,cjs.toMiliseconds)(this.requestQueueDelay))}),dist_index_es_c(this,"cleanupPendingSentRequestsForTopic",({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(i=>i.topic===e&&i.request.method==="wc_sessionRequest").forEach(i=>{const r=i.request.id,o=dist_index_es_xi("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(dist_index_es_xi("session_request",i.request.id),{error:t})})}),dist_index_es_c(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===dist_index_es_$.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=dist_index_es_$.active,this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}}),dist_index_es_c(this,"emitSessionRequest",e=>{this.client.events.emit("session_request",e)}),dist_index_es_c(this,"onPairingCreated",e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:(0,dist_esm.formatJsonRpcRequest)("wc_sessionPropose",index_es_b(dist_index_es_v({},t),{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties,scopedProperties:t.scopedProperties}),t.id)})}),dist_index_es_c(this,"isValidConnect",async e=>{if(!index_es_ma(e)){const{message:l}=index_es_ht("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(l)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:i,sessionProperties:r,scopedProperties:o,relays:a}=e;if(dist_index_es_Et(t)||await this.isValidPairingTopic(t),!index_es_ga(a,!0)){const{message:l}=index_es_ht("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(l)}if(!dist_index_es_Et(s)&&index_es_Oe(s)!==0){const l="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(l):this.client.logger.warn(l),this.validateNamespaces(s,"requiredNamespaces")}if(!dist_index_es_Et(i)&&index_es_Oe(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),dist_index_es_Et(r)||this.validateSessionProps(r,"sessionProperties"),!dist_index_es_Et(o)){this.validateSessionProps(o,"scopedProperties");const l=Object.keys(s||{}).concat(Object.keys(i||{}));if(!Object.keys(o).every(p=>l.includes(p)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(l)}`)}}),dist_index_es_c(this,"validateNamespaces",(e,t)=>{const s=index_es_pa(e,"connect()",t);if(s)throw new Error(s.message)}),dist_index_es_c(this,"isValidApprove",async e=>{if(!index_es_ma(e))throw new Error(index_es_ht("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:i,sessionProperties:r,scopedProperties:o}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const a=this.client.proposal.get(t),l=dist_index_es_Bo(s,"approve()");if(l)throw new Error(l.message);const p=dist_index_es_No(a.requiredNamespaces,s,"approve()");if(p)throw new Error(p.message);if(!index_es_nt(i,!0)){const{message:h}=index_es_ht("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}if(dist_index_es_Et(r)||this.validateSessionProps(r,"sessionProperties"),!dist_index_es_Et(o)){this.validateSessionProps(o,"scopedProperties");const h=new Set(Object.keys(s));if(!Object.keys(o).every(u=>h.has(u)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(h).join(", ")}`)}}),dist_index_es_c(this,"isValidReject",async e=>{if(!index_es_ma(e)){const{message:i}=index_es_ht("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!index_es_wa(s)){const{message:i}=index_es_ht("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(i)}}),dist_index_es_c(this,"isValidSessionSettleRequest",e=>{if(!index_es_ma(e)){const{message:l}=index_es_ht("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:t,controller:s,namespaces:i,expiry:r}=e;if(!dist_index_es_Io(t)){const{message:l}=index_es_ht("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=index_es_ha(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=dist_index_es_Bo(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(dist_index_es_vi(r)){const{message:l}=index_es_ht("EXPIRED","onSessionSettleRequest()");throw new Error(l)}}),dist_index_es_c(this,"isValidUpdate",async e=>{if(!index_es_ma(e)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const i=this.client.session.get(t),r=dist_index_es_Bo(s,"update()");if(r)throw new Error(r.message);const o=dist_index_es_No(i.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),dist_index_es_c(this,"isValidExtend",async e=>{if(!index_es_ma(e)){const{message:s}=index_es_ht("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)}),dist_index_es_c(this,"isValidRequest",async e=>{if(!index_es_ma(e)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:t,request:s,chainId:i,expiry:r}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:o}=this.client.session.get(t);if(!index_es_xa(o,i)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!index_es_ba(s)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(a)}if(!index_es_Sa(o,i,s.method)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(a)}if(r&&!index_es_Ia(r,sign_client_dist_index_es_e)){const{message:a}=index_es_ht("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${sign_client_dist_index_es_e.min} and ${sign_client_dist_index_es_e.max}`);throw new Error(a)}}),dist_index_es_c(this,"isValidRespond",async e=>{var t;if(!index_es_ma(e)){const{message:r}=index_es_ht("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(r)}const{topic:s,response:i}=e;try{await this.isValidSessionTopic(s)}catch(r){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),r}if(!index_es_Ea(i)){const{message:r}=index_es_ht("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(r)}}),dist_index_es_c(this,"isValidPing",async e=>{if(!index_es_ma(e)){const{message:s}=index_es_ht("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),dist_index_es_c(this,"isValidEmit",async e=>{if(!index_es_ma(e)){const{message:o}=index_es_ht("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:t,event:s,chainId:i}=e;await this.isValidSessionTopic(t);const{namespaces:r}=this.client.session.get(t);if(!index_es_xa(r,i)){const{message:o}=index_es_ht("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!index_es_va(s)){const{message:o}=index_es_ht("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!index_es_Oa(r,i,s.name)){const{message:o}=index_es_ht("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),dist_index_es_c(this,"isValidDisconnect",async e=>{if(!index_es_ma(e)){const{message:s}=index_es_ht("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),dist_index_es_c(this,"isValidAuthenticate",e=>{const{chains:t,uri:s,domain:i,nonce:r}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!index_es_nt(s,!1))throw new Error("uri is required parameter");if(!index_es_nt(i,!1))throw new Error("domain is required parameter");if(!index_es_nt(r,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(a=>index_es_Ne(a).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=index_es_Ne(t[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),dist_index_es_c(this,"getVerifyContext",async e=>{const{attestationId:t,hash:s,encryptedId:i,metadata:r,transportType:o}=e,a={verified:{verifyUrl:r.verifyUrl||index_es_ue,validation:"UNKNOWN",origin:r.url||""}};try{if(o===index_es_Q.link_mode){const p=this.getAppLinkIfEnabled(r,o);return a.verified.validation=p&&new URL(p).origin===new URL(r.url).origin?"VALID":"INVALID",a}const l=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:i,verifyUrl:r.verifyUrl});l&&(a.verified.origin=l.origin,a.verified.isScam=l.isScam,a.verified.validation=l.origin===new URL(r.url).origin?"VALID":"INVALID")}catch(l){this.client.logger.warn(l)}return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`),a}),dist_index_es_c(this,"validateSessionProps",(e,t)=>{Object.values(e).forEach((s,i)=>{if(s==null){const{message:r}=index_es_ht("MISSING_OR_INVALID",`${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i]}`);throw new Error(r)}})}),dist_index_es_c(this,"getPendingAuthRequest",e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0}),dist_index_es_c(this,"addToRecentlyDeleted",(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const i=this.recentlyDeletedLimit/2;for(const r of this.recentlyDeletedMap.keys()){if(s++>=i)break;this.recentlyDeletedMap.delete(r)}}}),dist_index_es_c(this,"checkRecentlyDeleted",e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=index_es_ht("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}}),dist_index_es_c(this,"isLinkModeEnabled",(e,t)=>{var s,i,r,o,a,l,p,h,u;return!e||t!==index_es_Q.link_mode?!1:((i=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:i.linkMode)===!0&&((o=(r=this.client.metadata)==null?void 0:r.redirect)==null?void 0:o.universal)!==void 0&&((l=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:l.universal)!==""&&((p=e?.redirect)==null?void 0:p.universal)!==void 0&&((h=e?.redirect)==null?void 0:h.universal)!==""&&((u=e?.redirect)==null?void 0:u.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),dist_index_es_c(this,"getAppLinkIfEnabled",(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e?.redirect)==null?void 0:s.universal:void 0}),dist_index_es_c(this,"handleLinkModeMessage",({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=dist_index_es_Ai(e,"topic")||"",s=decodeURIComponent(dist_index_es_Ai(e,"wc_ev")||""),i=this.client.session.keys.includes(t);i&&this.client.session.update(t,{transportType:index_es_Q.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:i})}),dist_index_es_c(this,"registerLinkModeListeners",async()=>{var e;if(dist_index_es_Ii()||index_es_pt()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),dist_index_es_c(this,"shouldSetTVF",(e,t)=>{if(!t||e!=="wc_sessionRequest")return!1;const{request:s}=t;return Object.keys(sign_client_dist_index_es_Ke).includes(s.method)}),dist_index_es_c(this,"getTVFParams",(e,t,s)=>{var i,r;try{const o=t.request.method,a=this.extractTxHashesFromResult(o,s);return index_es_b(dist_index_es_v({correlationId:e,rpcMethods:[o],chainId:t.chainId},this.isValidContractData(t.request.params)&&{contractAddresses:[(r=(i=t.request.params)==null?void 0:i[0])==null?void 0:r.to]}),{txHashes:a})}catch(o){this.client.logger.warn("Error getting TVF params",o)}return{}}),dist_index_es_c(this,"isValidContractData",e=>{var t;if(!e)return!1;try{const s=e?.data||((t=e?.[0])==null?void 0:t.data);if(!s.startsWith("0x"))return!1;const i=s.slice(2);return/^[0-9a-fA-F]*$/.test(i)?i.length%2===0:!1}catch{}return!1}),dist_index_es_c(this,"extractTxHashesFromResult",(e,t)=>{try{const s=sign_client_dist_index_es_Ke[e];if(typeof t=="string")return[t];const i=t[s.key];if(dist_index_es_se(i))return e==="solana_signAllTransactions"?i.map(r=>index_es_Ji(r)):i;if(typeof i=="string")return[i]}catch(s){this.client.logger.warn("Error extracting tx hashes from result",s)}return[]})}async processPendingMessageEvents(){try{const n=this.client.session.keys,e=this.client.core.relayer.messages.getWithoutAck(n);for(const[t,s]of Object.entries(e))for(const i of s)try{await this.onProviderMessageEvent({topic:t,message:i,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i}`)}}catch(n){this.client.logger.warn("processPendingMessageEvents failed",n)}}isInitialized(){if(!this.initialized){const{message:n}=index_es_ht("NOT_INITIALIZED",this.name);throw new Error(n)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(index_es_C.message,n=>{this.onProviderMessageEvent(n)})}async onRelayMessage(n){const{topic:e,message:t,attestation:s,transportType:i}=n,{publicKey:r}=this.client.auth.authKeys.keys.includes(dist_index_es_ce)?this.client.auth.authKeys.get(dist_index_es_ce):{responseTopic:void 0,publicKey:void 0};try{const o=await this.client.core.crypto.decode(e,t,{receiverPublicKey:r,encoding:i===index_es_Q.link_mode?index_es_xe:dist_index_es_qt});(0,dist_esm.isJsonRpcRequest)(o)?(this.client.core.history.set(e,o),await this.onRelayEventRequest({topic:e,payload:o,attestation:s,transportType:i,encryptedId:index_es_kc(t)})):(0,dist_esm.isJsonRpcResponse)(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:e,payload:o,transportType:i}),this.client.core.history.delete(e,o.id)):await this.onRelayEventUnknownPayload({topic:e,payload:o,transportType:i}),await this.client.core.relayer.messages.ack(e,t)}catch(o){this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(index_es_M.expired,async n=>{const{topic:e,id:t}=dist_index_es_bi(n.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,index_es_ht("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,index_es_ht("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(index_es_re.create,n=>this.onPairingCreated(n)),this.client.core.pairing.events.on(index_es_re.delete,n=>{this.addToRecentlyDeleted(n.topic,"pairing")})}isValidPairingTopic(n){if(!index_es_nt(n,!1)){const{message:e}=index_es_ht("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:e}=index_es_ht("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(e)}if(dist_index_es_vi(this.client.core.pairing.pairings.get(n).expiry)){const{message:e}=index_es_ht("EXPIRED",`pairing topic: ${n}`);throw new Error(e)}}async isValidSessionTopic(n){if(!index_es_nt(n,!1)){const{message:e}=index_es_ht("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(e)}if(this.checkRecentlyDeleted(n),!this.client.session.keys.includes(n)){const{message:e}=index_es_ht("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(e)}if(dist_index_es_vi(this.client.session.get(n).expiry)){await this.deleteSession({topic:n});const{message:e}=index_es_ht("EXPIRED",`session topic: ${n}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(n)){const{message:e}=index_es_ht("MISSING_OR_INVALID",`session topic does not exist in keychain: ${n}`);throw await this.deleteSession({topic:n}),new Error(e)}}async isValidSessionOrPairingTopic(n){if(this.checkRecentlyDeleted(n),this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(index_es_nt(n,!1)){const{message:e}=index_es_ht("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(e)}else{const{message:e}=index_es_ht("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(e)}}async isValidProposalId(n){if(!index_es_ya(n)){const{message:e}=index_es_ht("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(e)}if(!this.client.proposal.keys.includes(n)){const{message:e}=index_es_ht("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(e)}if(dist_index_es_vi(this.client.proposal.get(n).expiryTimestamp)){await this.deleteProposal(n);const{message:e}=index_es_ht("EXPIRED",`proposal id: ${n}`);throw new Error(e)}}}class dist_index_es_Os extends index_es_zi{constructor(n,e){super(n,e,dist_index_es_pt,dist_index_es_we),this.core=n,this.logger=e}}class sign_client_dist_index_es_St extends index_es_zi{constructor(n,e){super(n,e,dist_index_es_ht,dist_index_es_we),this.core=n,this.logger=e}}class dist_index_es_bs extends index_es_zi{constructor(n,e){super(n,e,dist_index_es_ut,dist_index_es_we,t=>t.id),this.core=n,this.logger=e}}class dist_index_es_As extends index_es_zi{constructor(n,e){super(n,e,dist_index_es_mt,dist_index_es_ae,()=>dist_index_es_ce),this.core=n,this.logger=e}}class dist_index_es_xs extends index_es_zi{constructor(n,e){super(n,e,dist_index_es_t,dist_index_es_ae),this.core=n,this.logger=e}}class dist_index_es_Cs extends index_es_zi{constructor(n,e){super(n,e,sign_client_dist_index_es_Et,dist_index_es_ae,t=>t.id),this.core=n,this.logger=e}}var dist_index_es_Vs=Object.defineProperty,dist_index_es_Ds=(S,n,e)=>n in S?dist_index_es_Vs(S,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[n]=e,sign_client_dist_index_es_Ge=(S,n,e)=>dist_index_es_Ds(S,typeof n!="symbol"?n+"":n,e);class dist_index_es_Ls{constructor(n,e){this.core=n,this.logger=e,sign_client_dist_index_es_Ge(this,"authKeys"),sign_client_dist_index_es_Ge(this,"pairingTopics"),sign_client_dist_index_es_Ge(this,"requests"),this.authKeys=new dist_index_es_As(this.core,this.logger),this.pairingTopics=new dist_index_es_xs(this.core,this.logger),this.requests=new dist_index_es_Cs(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var dist_index_es_ks=Object.defineProperty,dist_index_es_Ms=(S,n,e)=>n in S?dist_index_es_ks(S,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[n]=e,dist_index_es_E=(S,n,e)=>dist_index_es_Ms(S,typeof n!="symbol"?n+"":n,e);class sign_client_dist_index_es_Ee extends J{constructor(n){super(n),dist_index_es_E(this,"protocol",dist_index_es_De),dist_index_es_E(this,"version",sign_client_dist_index_es_Le),dist_index_es_E(this,"name",dist_index_es_me.name),dist_index_es_E(this,"metadata"),dist_index_es_E(this,"core"),dist_index_es_E(this,"logger"),dist_index_es_E(this,"events",new external_events_.EventEmitter),dist_index_es_E(this,"engine"),dist_index_es_E(this,"session"),dist_index_es_E(this,"proposal"),dist_index_es_E(this,"pendingRequest"),dist_index_es_E(this,"auth"),dist_index_es_E(this,"signConfig"),dist_index_es_E(this,"on",(t,s)=>this.events.on(t,s)),dist_index_es_E(this,"once",(t,s)=>this.events.once(t,s)),dist_index_es_E(this,"off",(t,s)=>this.events.off(t,s)),dist_index_es_E(this,"removeListener",(t,s)=>this.events.removeListener(t,s)),dist_index_es_E(this,"removeAllListeners",t=>this.events.removeAllListeners(t)),dist_index_es_E(this,"connect",async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"pair",async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"approve",async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"reject",async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"update",async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"extend",async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"request",async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"respond",async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"ping",async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"emit",async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"disconnect",async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"find",t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}}),dist_index_es_E(this,"authenticate",async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(i){throw this.logger.error(i.message),i}}),dist_index_es_E(this,"formatAuthMessage",t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"approveSessionAuthenticate",async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),dist_index_es_E(this,"rejectSessionAuthenticate",async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),this.name=n?.name||dist_index_es_me.name,this.metadata=dist_index_es_oi(n?.metadata),this.signConfig=n?.signConfig;const e=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:(0,logger_dist_index_es/* pino */.h6)((0,logger_dist_index_es/* getDefaultLoggerOptions */.iP)({level:n?.logger||dist_index_es_me.logger}));this.core=n?.core||new index_es_Xo(n),this.logger=(0,logger_dist_index_es/* generateChildLogger */.U5)(e,this.name),this.session=new sign_client_dist_index_es_St(this.core,this.logger),this.proposal=new dist_index_es_Os(this.core,this.logger),this.pendingRequest=new dist_index_es_bs(this.core,this.logger),this.engine=new dist_index_es_Ns(this),this.auth=new dist_index_es_Ls(this.core,this.logger)}static async init(n){const e=new sign_client_dist_index_es_Ee(n);return await e.initialize(),e}get context(){return (0,logger_dist_index_es/* getLoggerContext */.oI)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},(0,cjs.toMiliseconds)(cjs.ONE_SECOND))}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const dist_index_es_$s=(/* unused pure expression or super */ null && (sign_client_dist_index_es_St)),dist_index_es_Ks=(/* unused pure expression or super */ null && (sign_client_dist_index_es_Ee));
//# sourceMappingURL=index.es.js.map

// EXTERNAL MODULE: ./node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var jsonrpc_http_connection_dist_index_es = __webpack_require__(236647);
;// ./node_modules/@walletconnect/universal-provider/dist/index.es.js
const dist_index_es_et="error",universal_provider_dist_index_es_St="wss://relay.walletconnect.org",dist_index_es_Dt="wc",universal_provider_dist_index_es_qt="universal_provider",U=`${dist_index_es_Dt}@2:${universal_provider_dist_index_es_qt}:`,st="https://rpc.walletconnect.org/v1/",index_es_I="generic",universal_provider_dist_index_es_jt=`${st}bundler`,index_es_u={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function universal_provider_dist_index_es_Rt(){}function dist_index_es_k(s){return s==null||typeof s!="object"&&typeof s!="function"}function index_es_W(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function universal_provider_dist_index_es_t(s){if(dist_index_es_k(s))return s;if(Array.isArray(s)||index_es_W(s)||s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer)return s.slice(0);const t=Object.getPrototypeOf(s),e=t.constructor;if(s instanceof Date||s instanceof Map||s instanceof Set)return new e(s);if(s instanceof RegExp){const i=new e(s);return i.lastIndex=s.lastIndex,i}if(s instanceof DataView)return new e(s.buffer.slice(0));if(s instanceof Error){const i=new e(s.message);return i.stack=s.stack,i.name=s.name,i.cause=s.cause,i}if(typeof File<"u"&&s instanceof File)return new e([s],s.name,{type:s.type,lastModified:s.lastModified});if(typeof s=="object"){const i=Object.create(t);return Object.assign(i,s)}return s}function dist_index_es_it(s){return typeof s=="object"&&s!==null}function index_es_rt(s){return Object.getOwnPropertySymbols(s).filter(t=>Object.prototype.propertyIsEnumerable.call(s,t))}function dist_index_es_nt(s){return s==null?s===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(s)}const index_es_Ut="[object RegExp]",dist_index_es_at="[object String]",dist_index_es_ct="[object Number]",dist_index_es_ot="[object Boolean]",universal_provider_dist_index_es_ht="[object Arguments]",universal_provider_dist_index_es_Ft="[object Symbol]",universal_provider_dist_index_es_Lt="[object Date]",universal_provider_dist_index_es_Mt="[object Map]",universal_provider_dist_index_es_xt="[object Set]",universal_provider_dist_index_es_Bt="[object Array]",dist_index_es_Gt="[object ArrayBuffer]",universal_provider_dist_index_es_Jt="[object Object]",index_es_zt="[object DataView]",universal_provider_dist_index_es_kt="[object Uint8Array]",universal_provider_dist_index_es_Wt="[object Uint8ClampedArray]",universal_provider_dist_index_es_Kt="[object Uint16Array]",universal_provider_dist_index_es_Vt="[object Uint32Array]",universal_provider_dist_index_es_Xt="[object Int8Array]",dist_index_es_Yt="[object Int16Array]",universal_provider_dist_index_es_Qt="[object Int32Array]",index_es_Zt="[object Float32Array]",universal_provider_dist_index_es_Tt="[object Float64Array]";function dist_index_es_te(s,t){return universal_provider_dist_index_es_$(s,void 0,s,new Map,t)}function universal_provider_dist_index_es_$(s,t,e,i=new Map,n=void 0){const a=n?.(s,t,e,i);if(a!=null)return a;if(dist_index_es_k(s))return s;if(i.has(s))return i.get(s);if(Array.isArray(s)){const r=new Array(s.length);i.set(s,r);for(let c=0;c<s.length;c++)r[c]=universal_provider_dist_index_es_$(s[c],c,e,i,n);return Object.hasOwn(s,"index")&&(r.index=s.index),Object.hasOwn(s,"input")&&(r.input=s.input),r}if(s instanceof Date)return new Date(s.getTime());if(s instanceof RegExp){const r=new RegExp(s.source,s.flags);return r.lastIndex=s.lastIndex,r}if(s instanceof Map){const r=new Map;i.set(s,r);for(const[c,o]of s)r.set(c,universal_provider_dist_index_es_$(o,c,e,i,n));return r}if(s instanceof Set){const r=new Set;i.set(s,r);for(const c of s)r.add(universal_provider_dist_index_es_$(c,void 0,e,i,n));return r}if(typeof Buffer<"u"&&Buffer.isBuffer(s))return s.subarray();if(index_es_W(s)){const r=new(Object.getPrototypeOf(s)).constructor(s.length);i.set(s,r);for(let c=0;c<s.length;c++)r[c]=universal_provider_dist_index_es_$(s[c],c,e,i,n);return r}if(s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer)return s.slice(0);if(s instanceof DataView){const r=new DataView(s.buffer.slice(0),s.byteOffset,s.byteLength);return i.set(s,r),dist_index_es_y(r,s,e,i,n),r}if(typeof File<"u"&&s instanceof File){const r=new File([s],s.name,{type:s.type});return i.set(s,r),dist_index_es_y(r,s,e,i,n),r}if(s instanceof Blob){const r=new Blob([s],{type:s.type});return i.set(s,r),dist_index_es_y(r,s,e,i,n),r}if(s instanceof Error){const r=new s.constructor;return i.set(s,r),r.message=s.message,r.name=s.name,r.stack=s.stack,r.cause=s.cause,dist_index_es_y(r,s,e,i,n),r}if(typeof s=="object"&&dist_index_es_ee(s)){const r=Object.create(Object.getPrototypeOf(s));return i.set(s,r),dist_index_es_y(r,s,e,i,n),r}return s}function dist_index_es_y(s,t,e=s,i,n){const a=[...Object.keys(t),...index_es_rt(t)];for(let r=0;r<a.length;r++){const c=a[r],o=Object.getOwnPropertyDescriptor(s,c);(o==null||o.writable)&&(s[c]=universal_provider_dist_index_es_$(t[c],c,e,i,n))}}function dist_index_es_ee(s){switch(dist_index_es_nt(s)){case universal_provider_dist_index_es_ht:case universal_provider_dist_index_es_Bt:case dist_index_es_Gt:case index_es_zt:case dist_index_es_ot:case universal_provider_dist_index_es_Lt:case index_es_Zt:case universal_provider_dist_index_es_Tt:case universal_provider_dist_index_es_Xt:case dist_index_es_Yt:case universal_provider_dist_index_es_Qt:case universal_provider_dist_index_es_Mt:case dist_index_es_ct:case universal_provider_dist_index_es_Jt:case index_es_Ut:case universal_provider_dist_index_es_xt:case dist_index_es_at:case universal_provider_dist_index_es_Ft:case universal_provider_dist_index_es_kt:case universal_provider_dist_index_es_Wt:case universal_provider_dist_index_es_Kt:case universal_provider_dist_index_es_Vt:return!0;default:return!1}}function universal_provider_dist_index_es_se(s,t){return dist_index_es_te(s,(e,i,n,a)=>{const r=t?.(e,i,n,a);if(r!=null)return r;if(typeof s=="object")switch(Object.prototype.toString.call(s)){case dist_index_es_ct:case dist_index_es_at:case dist_index_es_ot:{const c=new s.constructor(s?.valueOf());return dist_index_es_y(c,s),c}case universal_provider_dist_index_es_ht:{const c={};return dist_index_es_y(c,s),c.length=s.length,c[Symbol.iterator]=s[Symbol.iterator],c}default:return}})}function universal_provider_dist_index_es_pt(s){return universal_provider_dist_index_es_se(s)}function universal_provider_dist_index_es_dt(s){return s!==null&&typeof s=="object"&&dist_index_es_nt(s)==="[object Arguments]"}function universal_provider_dist_index_es_ie(s){return index_es_W(s)}function universal_provider_dist_index_es_re(s){if(typeof s!="object"||s==null)return!1;if(Object.getPrototypeOf(s)===null)return!0;if(Object.prototype.toString.call(s)!=="[object Object]"){const e=s[Symbol.toStringTag];return e==null||!Object.getOwnPropertyDescriptor(s,Symbol.toStringTag)?.writable?!1:s.toString()===`[object ${e}]`}let t=s;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(s)===t}function universal_provider_dist_index_es_ne(s,...t){const e=t.slice(0,-1),i=t[t.length-1];let n=s;for(let a=0;a<e.length;a++){const r=e[a];n=universal_provider_dist_index_es_F(n,r,i,new Map)}return n}function universal_provider_dist_index_es_F(s,t,e,i){if(dist_index_es_k(s)&&(s=Object(s)),t==null||typeof t!="object")return s;if(i.has(t))return universal_provider_dist_index_es_t(i.get(t));if(i.set(t,s),Array.isArray(t)){t=t.slice();for(let a=0;a<t.length;a++)t[a]=t[a]??void 0}const n=[...Object.keys(t),...index_es_rt(t)];for(let a=0;a<n.length;a++){const r=n[a];let c=t[r],o=s[r];if(universal_provider_dist_index_es_dt(c)&&(c={...c}),universal_provider_dist_index_es_dt(o)&&(o={...o}),typeof Buffer<"u"&&Buffer.isBuffer(c)&&(c=universal_provider_dist_index_es_pt(c)),Array.isArray(c))if(typeof o=="object"&&o!=null){const w=[],v=Reflect.ownKeys(o);for(let P=0;P<v.length;P++){const p=v[P];w[p]=o[p]}o=w}else o=[];const m=e(o,c,r,s,t,i);m!=null?s[r]=m:Array.isArray(c)||dist_index_es_it(o)&&dist_index_es_it(c)?s[r]=universal_provider_dist_index_es_F(o,c,e,i):o==null&&universal_provider_dist_index_es_re(c)?s[r]=universal_provider_dist_index_es_F({},c,e,i):o==null&&universal_provider_dist_index_es_ie(c)?s[r]=universal_provider_dist_index_es_pt(c):(o===void 0||c!==void 0)&&(s[r]=c)}return s}function universal_provider_dist_index_es_ae(s,...t){return universal_provider_dist_index_es_ne(s,...t,universal_provider_dist_index_es_Rt)}var universal_provider_dist_index_es_ce=Object.defineProperty,dist_index_es_oe=Object.defineProperties,universal_provider_dist_index_es_he=Object.getOwnPropertyDescriptors,universal_provider_dist_index_es_ut=Object.getOwnPropertySymbols,universal_provider_dist_index_es_pe=Object.prototype.hasOwnProperty,universal_provider_dist_index_es_de=Object.prototype.propertyIsEnumerable,dist_index_es_lt=(s,t,e)=>t in s?universal_provider_dist_index_es_ce(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,index_es_L=(s,t)=>{for(var e in t||(t={}))universal_provider_dist_index_es_pe.call(t,e)&&dist_index_es_lt(s,e,t[e]);if(universal_provider_dist_index_es_ut)for(var e of universal_provider_dist_index_es_ut(t))universal_provider_dist_index_es_de.call(t,e)&&dist_index_es_lt(s,e,t[e]);return s},universal_provider_dist_index_es_ue=(s,t)=>dist_index_es_oe(s,universal_provider_dist_index_es_he(t));function index_es_d(s,t,e){var i;const n=index_es_Ne(s);return((i=t.rpcMap)==null?void 0:i[n.reference])||`${st}?chainId=${n.namespace}:${n.reference}&projectId=${e}`}function dist_index_es_b(s){return s.includes(":")?s.split(":")[1]:s}function universal_provider_dist_index_es_ft(s){return s.map(t=>`${t.split(":")[0]}:${t.split(":")[1]}`)}function universal_provider_dist_index_es_le(s,t){const e=Object.keys(t.namespaces).filter(n=>n.includes(s));if(!e.length)return[];const i=[];return e.forEach(n=>{const a=t.namespaces[n].accounts;i.push(...a)}),i}function dist_index_es_M(s={},t={}){const e=universal_provider_dist_index_es_mt(s),i=universal_provider_dist_index_es_mt(t);return universal_provider_dist_index_es_ae(e,i)}function universal_provider_dist_index_es_mt(s){var t,e,i,n,a;const r={};if(!index_es_Oe(s))return r;for(const[c,o]of Object.entries(s)){const m=dist_index_es_yn(c)?[c]:o.chains,w=o.methods||[],v=o.events||[],P=o.rpcMap||{},p=dist_index_es_yo(c);r[p]=universal_provider_dist_index_es_ue(index_es_L(index_es_L({},r[p]),o),{chains:index_es_ot(m,(t=r[p])==null?void 0:t.chains),methods:index_es_ot(w,(e=r[p])==null?void 0:e.methods),events:index_es_ot(v,(i=r[p])==null?void 0:i.events)}),(index_es_Oe(P)||index_es_Oe(((n=r[p])==null?void 0:n.rpcMap)||{}))&&(r[p].rpcMap=index_es_L(index_es_L({},P),(a=r[p])==null?void 0:a.rpcMap))}return r}function vt(s){return s.includes(":")?s.split(":")[2]:s}function universal_provider_dist_index_es_gt(s){const t={};for(const[e,i]of Object.entries(s)){const n=i.methods||[],a=i.events||[],r=i.accounts||[],c=dist_index_es_yn(e)?[e]:i.chains?i.chains:universal_provider_dist_index_es_ft(i.accounts);t[e]={chains:c,methods:n,events:a,accounts:r}}return t}function universal_provider_dist_index_es_K(s){return typeof s=="number"?s:s.includes("0x")?parseInt(s,16):(s=s.includes(":")?s.split(":")[1]:s,isNaN(Number(s))?s:Number(s))}const universal_provider_dist_index_es_Pt={},index_es_h=s=>universal_provider_dist_index_es_Pt[s],universal_provider_dist_index_es_V=(s,t)=>{universal_provider_dist_index_es_Pt[s]=t};var dist_index_es_fe=Object.defineProperty,universal_provider_dist_index_es_me=(s,t,e)=>t in s?dist_index_es_fe(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,dist_index_es_O=(s,t,e)=>universal_provider_dist_index_es_me(s,typeof t!="symbol"?t+"":t,e);class dist_index_es_ve{constructor(t){dist_index_es_O(this,"name","polkadot"),dist_index_es_O(this,"client"),dist_index_es_O(this,"httpProviders"),dist_index_es_O(this,"events"),dist_index_es_O(this,"namespace"),dist_index_es_O(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_ge=Object.defineProperty,dist_index_es_Pe=Object.defineProperties,universal_provider_dist_index_es_we=Object.getOwnPropertyDescriptors,universal_provider_dist_index_es_wt=Object.getOwnPropertySymbols,universal_provider_dist_index_es_ye=Object.prototype.hasOwnProperty,universal_provider_dist_index_es_be=Object.prototype.propertyIsEnumerable,dist_index_es_X=(s,t,e)=>t in s?universal_provider_dist_index_es_ge(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,universal_provider_dist_index_es_yt=(s,t)=>{for(var e in t||(t={}))universal_provider_dist_index_es_ye.call(t,e)&&dist_index_es_X(s,e,t[e]);if(universal_provider_dist_index_es_wt)for(var e of universal_provider_dist_index_es_wt(t))universal_provider_dist_index_es_be.call(t,e)&&dist_index_es_X(s,e,t[e]);return s},dist_index_es_bt=(s,t)=>dist_index_es_Pe(s,universal_provider_dist_index_es_we(t)),index_es_A=(s,t,e)=>dist_index_es_X(s,typeof t!="symbol"?t+"":t,e);class index_es_Ie{constructor(t){index_es_A(this,"name","eip155"),index_es_A(this,"client"),index_es_A(this,"chainId"),index_es_A(this,"namespace"),index_es_A(this,"httpProviders"),index_es_A(this,"events"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(t){switch(t.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(t);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(t);case"wallet_getCallsStatus":return await this.getCallStatus(t)}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(parseInt(t),e),this.chainId=parseInt(t),this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}createHttpProvider(t,e){const i=e||index_es_d(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* HttpConnection */.V(i,index_es_h("disableProviderPing")))}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=parseInt(dist_index_es_b(e));t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}getHttpProvider(){const t=this.chainId,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}async handleSwitchChain(t){var e,i;let n=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:"0x0";n=n.startsWith("0x")?n:`0x${n}`;const a=parseInt(n,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:t.topic,request:{method:t.request.method,params:[{chainId:n}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(t){return this.namespace.chains.includes(`${this.name}:${t}`)}async getCapabilities(t){var e,i,n,a,r;const c=(i=(e=t.request)==null?void 0:e.params)==null?void 0:i[0],o=((a=(n=t.request)==null?void 0:n.params)==null?void 0:a[1])||[],m=`${c}${o.join(",")}`;if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const w=this.client.session.get(t.topic),v=((r=w?.sessionProperties)==null?void 0:r.capabilities)||{};if(v!=null&&v[m])return v?.[m];const P=await this.client.request(t);try{await this.client.session.update(t.topic,{sessionProperties:dist_index_es_bt(universal_provider_dist_index_es_yt({},w.sessionProperties||{}),{capabilities:dist_index_es_bt(universal_provider_dist_index_es_yt({},v||{}),{[m]:P})})})}catch(p){console.warn("Failed to update session with capabilities",p)}return P}async getCallStatus(t){var e,i;const n=this.client.session.get(t.topic),a=(e=n.sessionProperties)==null?void 0:e.bundler_name;if(a){const c=this.getBundlerUrl(t.chainId,a);try{return await this.getUserOperationReceipt(c,t)}catch(o){console.warn("Failed to fetch call status from bundler",o,c)}}const r=(i=n.sessionProperties)==null?void 0:i.bundler_url;if(r)try{return await this.getUserOperationReceipt(r,t)}catch(c){console.warn("Failed to fetch call status from custom bundler",c,r)}if(this.namespace.methods.includes(t.request.method))return await this.client.request(t);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(t,e){var i;const n=new URL(t),a=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify((0,dist_esm.formatJsonRpcRequest)("eth_getUserOperationReceipt",[(i=e.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(t,e){return`${universal_provider_dist_index_es_jt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`}}var universal_provider_dist_index_es_$e=Object.defineProperty,dist_index_es_Oe=(s,t,e)=>t in s?universal_provider_dist_index_es_$e(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,dist_index_es_C=(s,t,e)=>dist_index_es_Oe(s,typeof t!="symbol"?t+"":t,e);class dist_index_es_Ae{constructor(t){dist_index_es_C(this,"name","solana"),dist_index_es_C(this,"client"),dist_index_es_C(this,"httpProviders"),dist_index_es_C(this,"events"),dist_index_es_C(this,"namespace"),dist_index_es_C(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_Ce=Object.defineProperty,universal_provider_dist_index_es_He=(s,t,e)=>t in s?universal_provider_dist_index_es_Ce(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,universal_provider_dist_index_es_H=(s,t,e)=>universal_provider_dist_index_es_He(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_Ee{constructor(t){universal_provider_dist_index_es_H(this,"name","cosmos"),universal_provider_dist_index_es_H(this,"client"),universal_provider_dist_index_es_H(this,"httpProviders"),universal_provider_dist_index_es_H(this,"events"),universal_provider_dist_index_es_H(this,"namespace"),universal_provider_dist_index_es_H(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var dist_index_es_Ne=Object.defineProperty,dist_index_es_Se=(s,t,e)=>t in s?dist_index_es_Ne(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,universal_provider_dist_index_es_E=(s,t,e)=>dist_index_es_Se(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_De{constructor(t){universal_provider_dist_index_es_E(this,"name","algorand"),universal_provider_dist_index_es_E(this,"client"),universal_provider_dist_index_es_E(this,"httpProviders"),universal_provider_dist_index_es_E(this,"events"),universal_provider_dist_index_es_E(this,"namespace"),universal_provider_dist_index_es_E(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(!this.httpProviders[t]){const i=e||index_es_d(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;t[e]=this.createHttpProvider(e,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);return typeof i>"u"?void 0:new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_qe=Object.defineProperty,universal_provider_dist_index_es_je=(s,t,e)=>t in s?universal_provider_dist_index_es_qe(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,index_es_N=(s,t,e)=>universal_provider_dist_index_es_je(s,typeof t!="symbol"?t+"":t,e);class dist_index_es_Re{constructor(t){index_es_N(this,"name","cip34"),index_es_N(this,"client"),index_es_N(this,"httpProviders"),index_es_N(this,"events"),index_es_N(this,"namespace"),index_es_N(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{const i=this.getCardanoRPCUrl(e),n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,i)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}getCardanoRPCUrl(t){const e=this.namespace.rpcMap;if(e)return e[t]}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||this.getCardanoRPCUrl(t);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_e=Object.defineProperty,universal_provider_dist_index_es_Ue=(s,t,e)=>t in s?universal_provider_dist_index_es_e(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,dist_index_es_S=(s,t,e)=>universal_provider_dist_index_es_Ue(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_Fe{constructor(t){dist_index_es_S(this,"name","elrond"),dist_index_es_S(this,"client"),dist_index_es_S(this,"httpProviders"),dist_index_es_S(this,"events"),dist_index_es_S(this,"namespace"),dist_index_es_S(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_Le=Object.defineProperty,universal_provider_dist_index_es_Me=(s,t,e)=>t in s?universal_provider_dist_index_es_Le(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,D=(s,t,e)=>universal_provider_dist_index_es_Me(s,typeof t!="symbol"?t+"":t,e);class dist_index_es_xe{constructor(t){D(this,"name","multiversx"),D(this,"client"),D(this,"httpProviders"),D(this,"events"),D(this,"namespace"),D(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const n=dist_index_es_b(e);t[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var index_es_Be=Object.defineProperty,universal_provider_dist_index_es_Ge=(s,t,e)=>t in s?index_es_Be(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,dist_index_es_q=(s,t,e)=>universal_provider_dist_index_es_Ge(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_Je{constructor(t){dist_index_es_q(this,"name","near"),dist_index_es_q(this,"client"),dist_index_es_q(this,"httpProviders"),dist_index_es_q(this,"events"),dist_index_es_q(this,"namespace"),dist_index_es_q(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||index_es_d(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;t[e]=this.createHttpProvider(e,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace);return typeof i>"u"?void 0:new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_ze=Object.defineProperty,universal_provider_dist_index_es_ke=(s,t,e)=>t in s?universal_provider_dist_index_es_ze(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,index_es_j=(s,t,e)=>universal_provider_dist_index_es_ke(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_We{constructor(t){index_es_j(this,"name","tezos"),index_es_j(this,"client"),index_es_j(this,"httpProviders"),index_es_j(this,"events"),index_es_j(this,"namespace"),index_es_j(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||index_es_d(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace);return typeof i>"u"?void 0:new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i))}}var universal_provider_dist_index_es_Ke=Object.defineProperty,universal_provider_dist_index_es_Ve=(s,t,e)=>t in s?universal_provider_dist_index_es_Ke(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,index_es_R=(s,t,e)=>universal_provider_dist_index_es_Ve(s,typeof t!="symbol"?t+"":t,e);class universal_provider_dist_index_es_Xe{constructor(t){index_es_R(this,"name",index_es_I),index_es_R(this,"client"),index_es_R(this,"httpProviders"),index_es_R(this,"events"),index_es_R(this,"namespace"),index_es_R(this,"chainId"),this.namespace=t.namespace,this.events=index_es_h("events"),this.client=index_es_h("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(t.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(t.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(t.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(t.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider(t.chainId).request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(index_es_u.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){var t,e;const i={};return(e=(t=this.namespace)==null?void 0:t.accounts)==null||e.forEach(n=>{const a=index_es_Ne(n);i[`${a.namespace}:${a.reference}`]=this.createHttpProvider(n)}),i}getHttpProvider(t){const e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||index_es_d(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new jsonrpc_provider_dist_index_es/* JsonRpcProvider */.F(new jsonrpc_http_connection_dist_index_es/* default */.A(i,index_es_h("disableProviderPing")))}}var universal_provider_dist_index_es_Ye=Object.defineProperty,universal_provider_dist_index_es_Qe=Object.defineProperties,universal_provider_dist_index_es_Ze=Object.getOwnPropertyDescriptors,universal_provider_dist_index_es_It=Object.getOwnPropertySymbols,universal_provider_dist_index_es_Te=Object.prototype.hasOwnProperty,dist_index_es_ts=Object.prototype.propertyIsEnumerable,universal_provider_dist_index_es_Y=(s,t,e)=>t in s?universal_provider_dist_index_es_Ye(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,index_es_x=(s,t)=>{for(var e in t||(t={}))universal_provider_dist_index_es_Te.call(t,e)&&universal_provider_dist_index_es_Y(s,e,t[e]);if(universal_provider_dist_index_es_It)for(var e of universal_provider_dist_index_es_It(t))dist_index_es_ts.call(t,e)&&universal_provider_dist_index_es_Y(s,e,t[e]);return s},dist_index_es_Q=(s,t)=>universal_provider_dist_index_es_Qe(s,universal_provider_dist_index_es_Ze(t)),l=(s,t,e)=>universal_provider_dist_index_es_Y(s,typeof t!="symbol"?t+"":t,e);class index_es_B{constructor(t){l(this,"client"),l(this,"namespaces"),l(this,"optionalNamespaces"),l(this,"sessionProperties"),l(this,"scopedProperties"),l(this,"events",new (external_events_default())),l(this,"rpcProviders",{}),l(this,"session"),l(this,"providerOpts"),l(this,"logger"),l(this,"uri"),l(this,"disableProviderPing",!1),this.providerOpts=t,this.logger=typeof t?.logger<"u"&&typeof t?.logger!="string"?t.logger:(0,logger_dist_index_es/* pino */.h6)((0,logger_dist_index_es/* getDefaultLoggerOptions */.iP)({level:t?.logger||dist_index_es_et})),this.disableProviderPing=t?.disableProviderPing||!1}static async init(t){const e=new index_es_B(t);return await e.initialize(),e}async request(t,e,i){const[n,a]=this.validateChain(e);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(n).request({request:index_es_x({},t),chainId:`${n}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(t,e,i,n){const a=new Date().getTime();this.request(t,i,n).then(r=>e(null,(0,dist_esm.formatJsonRpcResult)(a,r))).catch(r=>e(r,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:dist_index_es_Nt("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,e){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:i,response:n}=await this.client.authenticate(t,e);i&&(this.uri=i,this.events.emit("display_uri",i));const a=await n();if(this.session=a.session,this.session){const r=universal_provider_dist_index_es_gt(this.session.namespaces);this.namespaces=dist_index_es_M(this.namespaces,r),await this.persist("namespaces",this.namespaces),this.onConnect()}return a}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){const{uri:e,approval:i}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});e&&(this.uri=e,this.events.emit("display_uri",e));const n=await i();this.session=n;const a=universal_provider_dist_index_es_gt(n.namespaces);return this.namespaces=dist_index_es_M(this.namespaces,a),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(t,e){try{if(!this.session)return;const[i,n]=this.validateChain(t),a=this.getProvider(i);a.name===index_es_I?a.setDefaultChain(`${i}:${n}`,e):a.setDefaultChain(n,e)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll();if(dist_index_es_se(e)){for(const i of e)t.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var t,e;if(this.client=this.providerOpts.client||await sign_client_dist_index_es_Ee.init({core:this.providerOpts.core,logger:this.providerOpts.logger||dist_index_es_et,relayUrl:this.providerOpts.relayUrl||universal_provider_dist_index_es_St,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error("Failed to get session",i),new Error(`The provided session: ${(e=(t=this.providerOpts)==null?void 0:t.session)==null?void 0:e.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const t=[...new Set(Object.keys(this.session.namespaces).map(e=>dist_index_es_yo(e)))];universal_provider_dist_index_es_V("client",this.client),universal_provider_dist_index_es_V("events",this.events),universal_provider_dist_index_es_V("disableProviderPing",this.disableProviderPing),t.forEach(e=>{if(!this.session)return;const i=universal_provider_dist_index_es_le(e,this.session),n=universal_provider_dist_index_es_ft(i),a=dist_index_es_M(this.namespaces,this.optionalNamespaces),r=dist_index_es_Q(index_es_x({},a[e]),{accounts:i,chains:n});switch(e){case"eip155":this.rpcProviders[e]=new index_es_Ie({namespace:r});break;case"algorand":this.rpcProviders[e]=new universal_provider_dist_index_es_De({namespace:r});break;case"solana":this.rpcProviders[e]=new dist_index_es_Ae({namespace:r});break;case"cosmos":this.rpcProviders[e]=new universal_provider_dist_index_es_Ee({namespace:r});break;case"polkadot":this.rpcProviders[e]=new dist_index_es_ve({namespace:r});break;case"cip34":this.rpcProviders[e]=new dist_index_es_Re({namespace:r});break;case"elrond":this.rpcProviders[e]=new universal_provider_dist_index_es_Fe({namespace:r});break;case"multiversx":this.rpcProviders[e]=new dist_index_es_xe({namespace:r});break;case"near":this.rpcProviders[e]=new universal_provider_dist_index_es_Je({namespace:r});break;case"tezos":this.rpcProviders[e]=new universal_provider_dist_index_es_We({namespace:r});break;default:this.rpcProviders[index_es_I]?this.rpcProviders[index_es_I].updateNamespace(r):this.rpcProviders[index_es_I]=new universal_provider_dist_index_es_Xe({namespace:r})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{var e;const{topic:i}=t;i===((e=this.session)==null?void 0:e.topic)&&this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{var e;const{params:i,topic:n}=t;if(n!==((e=this.session)==null?void 0:e.topic))return;const{event:a}=i;if(a.name==="accountsChanged"){const r=a.data;r&&dist_index_es_se(r)&&this.events.emit("accountsChanged",r.map(vt))}else if(a.name==="chainChanged"){const r=i.chainId,c=i.event.data,o=dist_index_es_yo(r),m=universal_provider_dist_index_es_K(r)!==universal_provider_dist_index_es_K(c)?`${o}:${universal_provider_dist_index_es_K(c)}`:r;this.onChainChanged(m)}else this.events.emit(a.name,a.data);this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:e})=>{var i,n;if(t!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=e,r=(n=this.client)==null?void 0:n.session.get(t);this.session=dist_index_es_Q(index_es_x({},r),{namespaces:a}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})}),this.client.on("session_delete",async t=>{var e;t.topic===((e=this.session)==null?void 0:e.topic)&&(await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",dist_index_es_Q(index_es_x({},dist_index_es_Nt("USER_DISCONNECTED")),{data:t.topic})))}),this.on(index_es_u.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[index_es_I]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){const{namespaces:e={},optionalNamespaces:i={},sessionProperties:n,scopedProperties:a}=t;this.optionalNamespaces=dist_index_es_M(e,i),this.sessionProperties=n,this.scopedProperties=a}validateChain(t){const[e,i]=t?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[e,i];if(e&&!Object.keys(this.namespaces||{}).map(r=>dist_index_es_yo(r)).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);if(e&&i)return[e,i];const n=dist_index_es_yo(Object.keys(this.namespaces)[0]),a=this.rpcProviders[n].getDefaultChain();return[n,a]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}async onChainChanged(t,e=!1){if(!this.namespaces)return;const[i,n]=this.validateChain(t);if(!n)return;this.updateNamespaceChain(i,n),this.events.emit("chainChanged",n);const a=this.getProvider(i).getDefaultChain();e||this.getProvider(i).setDefaultChain(n),this.emitAccountsChangedOnChainChange({namespace:i,previousChainId:a,newChainId:t}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:t,previousChainId:e,newChainId:i}){var n,a;try{if(e===i)return;const r=(a=(n=this.session)==null?void 0:n.namespaces[t])==null?void 0:a.accounts;if(!r)return;const c=r.filter(o=>o.includes(`${i}:`)).map(vt);if(!dist_index_es_se(c))return;this.events.emit("accountsChanged",c)}catch(r){this.logger.warn("Failed to emit accountsChanged on chain change",r)}}updateNamespaceChain(t,e){if(!this.namespaces)return;const i=this.namespaces[t]?t:`${t}:${e}`,n={chains:[],methods:[],events:[],defaultChain:e};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=e):this.namespaces[i]=n}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(t,e){var i;const n=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${U}/${t}${n}`,e)}async getFromStore(t){var e;const i=((e=this.session)==null?void 0:e.topic)||"";return await this.client.core.storage.getItem(`${U}/${t}${i}`)}async deleteFromStore(t){var e;const i=((e=this.session)==null?void 0:e.topic)||"";await this.client.core.storage.removeItem(`${U}/${t}${i}`)}async cleanupStorage(){var t;try{if(((t=this.client)==null?void 0:t.session.length)>0)return;const e=await this.client.core.storage.getKeys();for(const i of e)i.startsWith(U)&&await this.client.core.storage.removeItem(i)}catch(e){this.logger.warn("Failed to cleanup storage",e)}}}const universal_provider_dist_index_es_es=(/* unused pure expression or super */ null && (index_es_B));
//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ 163612:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ UiHelperUtil)
/* harmony export */ });
const UiHelperUtil = {
    getSpacingStyles(spacing, index) {
        if (Array.isArray(spacing)) {
            return spacing[index] ? `var(--wui-spacing-${spacing[index]})` : undefined;
        }
        else if (typeof spacing === 'string') {
            return `var(--wui-spacing-${spacing})`;
        }
        return undefined;
    },
    getFormattedDate(date) {
        return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' }).format(date);
    },
    getHostName(url) {
        try {
            const newUrl = new URL(url);
            return newUrl.hostname;
        }
        catch (error) {
            return '';
        }
    },
    getTruncateString({ string, charsStart, charsEnd, truncate }) {
        if (string.length <= charsStart + charsEnd) {
            return string;
        }
        if (truncate === 'end') {
            return `${string.substring(0, charsStart)}...`;
        }
        else if (truncate === 'start') {
            return `...${string.substring(string.length - charsEnd)}`;
        }
        return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
    },
    generateAvatarColors(address) {
        const hash = address
            .toLowerCase()
            .replace(/^0x/iu, '')
            .replace(/[^a-f0-9]/gu, '');
        const baseColor = hash.substring(0, 6).padEnd(6, '0');
        const rgbColor = this.hexToRgb(baseColor);
        const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue('--w3m-border-radius-master');
        const radius = Number(masterBorderRadius?.replace('px', ''));
        const edge = 100 - 3 * radius;
        const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
        const colors = [];
        for (let i = 0; i < 5; i += 1) {
            const tintedColor = this.tintColor(rgbColor, 0.15 * i);
            colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
        }
        return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
    },
    hexToRgb(hex) {
        const bigint = parseInt(hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    },
    tintColor(rgb, tint) {
        const [r, g, b] = rgb;
        const tintedR = Math.round(r + (255 - r) * tint);
        const tintedG = Math.round(g + (255 - g) * tint);
        const tintedB = Math.round(b + (255 - b) * tint);
        return [tintedR, tintedG, tintedB];
    },
    isNumber(character) {
        const regex = {
            number: /^[0-9]+$/u
        };
        return regex.number.test(character);
    },
    getColorTheme(theme) {
        if (theme) {
            return theme;
        }
        else if (typeof window !== 'undefined' && window.matchMedia) {
            if (window.matchMedia('(prefers-color-scheme: dark)')?.matches) {
                return 'dark';
            }
            return 'light';
        }
        return 'dark';
    },
    splitBalance(input) {
        const parts = input.split('.');
        if (parts.length === 2) {
            return [parts[0], parts[1]];
        }
        return ['0', '00'];
    },
    roundNumber(number, threshold, fixed) {
        const roundedNumber = number.toString().length >= threshold ? Number(number).toFixed(fixed) : number;
        return roundedNumber;
    },
    formatNumberToLocalString(value, decimals = 2) {
        if (value === undefined) {
            return '0.00';
        }
        if (typeof value === 'number') {
            return value.toLocaleString('en-US', {
                maximumFractionDigits: decimals,
                minimumFractionDigits: decimals
            });
        }
        return parseFloat(value).toLocaleString('en-US', {
            maximumFractionDigits: decimals,
            minimumFractionDigits: decimals
        });
    }
};
//# sourceMappingURL=UiHelperUtil.js.map

/***/ }),

/***/ 173495:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ NetworkUtil)
/* harmony export */ });
/* harmony import */ var _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(824376);

const NetworkUtil = {
    caipNetworkIdToNumber(caipnetworkId) {
        return caipnetworkId ? Number(caipnetworkId.split(':')[1]) : undefined;
    },
    parseEvmChainId(chainId) {
        return typeof chainId === 'string'
            ? this.caipNetworkIdToNumber(chainId)
            : chainId;
    },
    getNetworksByNamespace(networks, namespace) {
        return networks?.filter(network => network.chainNamespace === namespace) || [];
    },
    getFirstNetworkByNamespace(networks, namespace) {
        return this.getNetworksByNamespace(networks, namespace)[0];
    },
    getNetworkNameByCaipNetworkId(caipNetworks, caipNetworkId) {
        if (!caipNetworkId) {
            return undefined;
        }
        const caipNetwork = caipNetworks.find(network => network.caipNetworkId === caipNetworkId);
        if (caipNetwork) {
            return caipNetwork.name;
        }
        const [namespace] = caipNetworkId.split(':');
        return _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .o.CHAIN_NAME_MAP?.[namespace] || undefined;
    }
};
//# sourceMappingURL=NetworkUtil.js.map

/***/ }),

/***/ 188249:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ ApiController)
/* harmony export */ });
/* unused harmony export api */
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(204707);
/* harmony import */ var _utils_AssetUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(527601);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226742);
/* harmony import */ var _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25905);
/* harmony import */ var _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(725574);
/* harmony import */ var _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(127508);
/* harmony import */ var _AssetController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(773337);
/* harmony import */ var _ChainController_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(806056);
/* harmony import */ var _ConnectorController_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(236010);
/* harmony import */ var _EventsController_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(390184);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(500026);












// -- Helpers ------------------------------------------- //
const baseUrl = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.getApiUrl();
const api = new _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_1__/* .FetchUtil */ .Z({
    baseUrl,
    clientId: null
});
const entries = 40;
const recommendedEntries = 4;
const imageCountToFetch = 20;
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__/* .proxy */ .BX)({
    promises: {},
    page: 1,
    count: 0,
    featured: [],
    allFeatured: [],
    recommended: [],
    allRecommended: [],
    wallets: [],
    filteredWallets: [],
    search: [],
    isAnalyticsEnabled: false,
    excludedWallets: [],
    isFetchingRecommendedWallets: false
});
// -- Controller ---------------------------------------- //
const ApiController = {
    state,
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_3__/* .subscribeKey */ .u$)(state, key, callback);
    },
    _getSdkProperties() {
        const { projectId, sdkType, sdkVersion } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state;
        return {
            projectId,
            st: sdkType || 'appkit',
            sv: sdkVersion || 'html-wagmi-4.2.2'
        };
    },
    _filterOutExtensions(wallets) {
        if (_OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state.isUniversalProvider) {
            return wallets.filter(w => Boolean(w.mobile_link || w.desktop_link || w.webapp_link));
        }
        return wallets;
    },
    async _fetchWalletImage(imageId) {
        const imageUrl = `${api.baseUrl}/getWalletImage/${imageId}`;
        const blob = await api.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        _AssetController_js__WEBPACK_IMPORTED_MODULE_5__/* .AssetController */ .j.setWalletImage(imageId, URL.createObjectURL(blob));
    },
    async _fetchNetworkImage(imageId) {
        const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
        const blob = await api.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        _AssetController_js__WEBPACK_IMPORTED_MODULE_5__/* .AssetController */ .j.setNetworkImage(imageId, URL.createObjectURL(blob));
    },
    async _fetchConnectorImage(imageId) {
        const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
        const blob = await api.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        _AssetController_js__WEBPACK_IMPORTED_MODULE_5__/* .AssetController */ .j.setConnectorImage(imageId, URL.createObjectURL(blob));
    },
    async _fetchCurrencyImage(countryCode) {
        const imageUrl = `${api.baseUrl}/public/getCurrencyImage/${countryCode}`;
        const blob = await api.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        _AssetController_js__WEBPACK_IMPORTED_MODULE_5__/* .AssetController */ .j.setCurrencyImage(countryCode, URL.createObjectURL(blob));
    },
    async _fetchTokenImage(symbol) {
        const imageUrl = `${api.baseUrl}/public/getTokenImage/${symbol}`;
        const blob = await api.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        _AssetController_js__WEBPACK_IMPORTED_MODULE_5__/* .AssetController */ .j.setTokenImage(symbol, URL.createObjectURL(blob));
    },
    _filterWalletsByPlatform(wallets) {
        const filteredWallets = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.isMobile()
            ? wallets?.filter(w => {
                if (w.mobile_link) {
                    return true;
                }
                if (w.id === _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_6__/* .CUSTOM_DEEPLINK_WALLETS */ .O.COINBASE.id) {
                    return true;
                }
                const isSolana = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.state.activeChain === 'solana';
                return (isSolana &&
                    (w.id === _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_6__/* .CUSTOM_DEEPLINK_WALLETS */ .O.SOLFLARE.id ||
                        w.id === _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_6__/* .CUSTOM_DEEPLINK_WALLETS */ .O.PHANTOM.id));
            })
            : wallets;
        return filteredWallets;
    },
    async fetchProjectConfig() {
        const response = await api.get({
            path: '/appkit/v1/config',
            params: ApiController._getSdkProperties()
        });
        return response.features;
    },
    async fetchAllowedOrigins() {
        try {
            const { allowedOrigins } = await api.get({
                path: '/projects/v1/origins',
                params: ApiController._getSdkProperties()
            });
            return allowedOrigins;
        }
        catch (error) {
            return [];
        }
    },
    async fetchNetworkImages() {
        const requestedCaipNetworks = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getAllRequestedCaipNetworks();
        const ids = requestedCaipNetworks
            ?.map(({ assets }) => assets?.imageId)
            .filter(Boolean)
            .filter(imageId => !_utils_AssetUtil_js__WEBPACK_IMPORTED_MODULE_8__/* .AssetUtil */ .$.getNetworkImageById(imageId));
        if (ids) {
            await Promise.allSettled(ids.map(id => ApiController._fetchNetworkImage(id)));
        }
    },
    async fetchConnectorImages() {
        const { connectors } = _ConnectorController_js__WEBPACK_IMPORTED_MODULE_9__/* .ConnectorController */ .a.state;
        const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
        await Promise.allSettled(ids.map(id => ApiController._fetchConnectorImage(id)));
    },
    async fetchCurrencyImages(currencies = []) {
        await Promise.allSettled(currencies.map(currency => ApiController._fetchCurrencyImage(currency)));
    },
    async fetchTokenImages(tokens = []) {
        await Promise.allSettled(tokens.map(token => ApiController._fetchTokenImage(token)));
    },
    async fetchWallets(params) {
        const exclude = params.exclude ?? [];
        const sdkProperties = ApiController._getSdkProperties();
        if (sdkProperties.sv.startsWith('html-core-')) {
            exclude.push(...Object.values(_utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_6__/* .CUSTOM_DEEPLINK_WALLETS */ .O).map(w => w.id));
        }
        const wallets = await api.get({
            path: '/getWallets',
            params: {
                ...ApiController._getSdkProperties(),
                ...params,
                page: String(params.page),
                entries: String(params.entries),
                include: params.include?.join(','),
                exclude: exclude.join(',')
            }
        });
        const filteredWallets = ApiController._filterWalletsByPlatform(wallets?.data);
        return {
            data: filteredWallets || [],
            // Keep original count for display on main page
            count: wallets?.count
        };
    },
    async fetchFeaturedWallets() {
        const { featuredWalletIds } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state;
        if (featuredWalletIds?.length) {
            const params = {
                ...ApiController._getSdkProperties(),
                page: 1,
                entries: featuredWalletIds?.length ?? recommendedEntries,
                include: featuredWalletIds
            };
            const { data } = await ApiController.fetchWallets(params);
            const sortedData = [...data].sort((a, b) => featuredWalletIds.indexOf(a.id) - featuredWalletIds.indexOf(b.id));
            const images = sortedData.map(d => d.image_id).filter(Boolean);
            await Promise.allSettled(images.map(id => ApiController._fetchWalletImage(id)));
            state.featured = sortedData;
            state.allFeatured = sortedData;
        }
    },
    async fetchRecommendedWallets() {
        try {
            state.isFetchingRecommendedWallets = true;
            const { includeWalletIds, excludeWalletIds, featuredWalletIds } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state;
            const exclude = [...(excludeWalletIds ?? []), ...(featuredWalletIds ?? [])].filter(Boolean);
            const chains = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getRequestedCaipNetworkIds().join(',');
            const params = {
                page: 1,
                entries: recommendedEntries,
                include: includeWalletIds,
                exclude,
                chains
            };
            const { data, count } = await ApiController.fetchWallets(params);
            const recent = _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_10__/* .StorageUtil */ .i.getRecentWallets();
            const recommendedImages = data.map(d => d.image_id).filter(Boolean);
            const recentImages = recent.map(r => r.image_id).filter(Boolean);
            await Promise.allSettled([...recommendedImages, ...recentImages].map(id => ApiController._fetchWalletImage(id)));
            state.recommended = data;
            state.allRecommended = data;
            state.count = count ?? 0;
        }
        catch {
            // Catch silently
        }
        finally {
            state.isFetchingRecommendedWallets = false;
        }
    },
    async fetchWalletsByPage({ page }) {
        const { includeWalletIds, excludeWalletIds, featuredWalletIds } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state;
        const chains = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getRequestedCaipNetworkIds().join(',');
        const exclude = [
            ...state.recommended.map(({ id }) => id),
            ...(excludeWalletIds ?? []),
            ...(featuredWalletIds ?? [])
        ].filter(Boolean);
        const params = {
            page,
            entries,
            include: includeWalletIds,
            exclude,
            chains
        };
        const { data, count } = await ApiController.fetchWallets(params);
        const images = data
            .slice(0, imageCountToFetch)
            .map(w => w.image_id)
            .filter(Boolean);
        await Promise.allSettled(images.map(id => ApiController._fetchWalletImage(id)));
        state.wallets = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.uniqueBy([...state.wallets, ...ApiController._filterOutExtensions(data)], 'id').filter(w => w.chains?.some(chain => chains.includes(chain)));
        state.count = count > state.count ? count : state.count;
        state.page = page;
    },
    async initializeExcludedWallets({ ids }) {
        const params = {
            page: 1,
            entries: ids.length,
            include: ids
        };
        const { data } = await ApiController.fetchWallets(params);
        if (data) {
            data.forEach(wallet => {
                state.excludedWallets.push({ rdns: wallet.rdns, name: wallet.name });
            });
        }
    },
    async searchWallet({ search, badge }) {
        const { includeWalletIds, excludeWalletIds } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state;
        const chains = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getRequestedCaipNetworkIds().join(',');
        state.search = [];
        const params = {
            page: 1,
            entries: 100,
            search: search?.trim(),
            badge_type: badge,
            include: includeWalletIds,
            exclude: excludeWalletIds,
            chains
        };
        const { data } = await ApiController.fetchWallets(params);
        _EventsController_js__WEBPACK_IMPORTED_MODULE_11__/* .EventsController */ .E.sendEvent({
            type: 'track',
            event: 'SEARCH_WALLET',
            properties: { badge: badge ?? '', search: search ?? '' }
        });
        const images = data.map(w => w.image_id).filter(Boolean);
        await Promise.allSettled([
            ...images.map(id => ApiController._fetchWalletImage(id)),
            _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.wait(300)
        ]);
        state.search = ApiController._filterOutExtensions(data);
    },
    initPromise(key, fetchFn) {
        const existingPromise = state.promises[key];
        if (existingPromise) {
            return existingPromise;
        }
        return (state.promises[key] = fetchFn());
    },
    prefetch({ fetchConnectorImages = true, fetchFeaturedWallets = true, fetchRecommendedWallets = true, fetchNetworkImages = true } = {}) {
        const promises = [
            fetchConnectorImages &&
                ApiController.initPromise('connectorImages', ApiController.fetchConnectorImages),
            fetchFeaturedWallets &&
                ApiController.initPromise('featuredWallets', ApiController.fetchFeaturedWallets),
            fetchRecommendedWallets &&
                ApiController.initPromise('recommendedWallets', ApiController.fetchRecommendedWallets),
            fetchNetworkImages &&
                ApiController.initPromise('networkImages', ApiController.fetchNetworkImages)
        ].filter(Boolean);
        return Promise.allSettled(promises);
    },
    prefetchAnalyticsConfig() {
        if (_OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.state.features?.analytics) {
            ApiController.fetchAnalyticsConfig();
        }
    },
    async fetchAnalyticsConfig() {
        try {
            const { isAnalyticsEnabled } = await api.get({
                path: '/getAnalyticsConfig',
                params: ApiController._getSdkProperties()
            });
            _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.setFeatures({ analytics: isAnalyticsEnabled });
        }
        catch (error) {
            _OptionsController_js__WEBPACK_IMPORTED_MODULE_4__/* .OptionsController */ .H.setFeatures({ analytics: false });
        }
    },
    filterByNamespaces(namespaces) {
        if (!namespaces?.length) {
            state.featured = state.allFeatured;
            state.recommended = state.allRecommended;
            return;
        }
        const caipNetworkIds = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getRequestedCaipNetworkIds().join(',');
        state.featured = state.allFeatured.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
        state.recommended = state.allRecommended.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
        state.filteredWallets = state.wallets.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
    },
    clearFilterByNamespaces() {
        state.filteredWallets = [];
    },
    setFilterByNamespace(namespace) {
        if (!namespace) {
            state.featured = state.allFeatured;
            state.recommended = state.allRecommended;
            return;
        }
        const caipNetworkIds = _ChainController_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainController */ .W.getRequestedCaipNetworkIds().join(',');
        state.featured = state.allFeatured.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
        state.recommended = state.allRecommended.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
        state.filteredWallets = state.wallets.filter(wallet => wallet.chains?.some(chain => caipNetworkIds.includes(chain)));
    }
};
//# sourceMappingURL=ApiController.js.map

/***/ }),

/***/ 197199:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  WF: () => (/* reexport */ i),
  AH: () => (/* reexport */ reactive_element/* css */.AH),
  qy: () => (/* reexport */ lit_html/* html */.qy),
  JW: () => (/* reexport */ lit_html/* svg */.JW),
  iz: () => (/* reexport */ reactive_element/* unsafeCSS */.iz)
});

// UNUSED EXPORTS: CSSResult, ReactiveElement, _$LE, _$LH, adoptStyles, defaultConverter, getCompatibleStyle, isServer, mathml, noChange, notEqual, nothing, render, supportsAdoptingStyleSheets

// EXTERNAL MODULE: ./node_modules/@lit/reactive-element/node/reactive-element.js + 4 modules
var reactive_element = __webpack_require__(740512);
// EXTERNAL MODULE: ./node_modules/lit-html/node/lit-html.js
var lit_html = __webpack_require__(240173);
;// ./node_modules/lit-element/lit-element.js

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const s=globalThis;class i extends reactive_element/* ReactiveElement */.mN{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const r=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=(0,lit_html/* render */.XX)(r,this.renderRoot,this.renderOptions)}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0)}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1)}render(){return lit_html/* noChange */.c0}}i._$litElement$=!0,i["finalized"]=!0,s.litElementHydrateSupport?.({LitElement:i});const o=s.litElementPolyfillSupport;o?.({LitElement:i});const n={_$AK:(t,e,r)=>{t._$AK(e,r)},_$AL:t=>t._$AL};(s.litElementVersions??=[]).push("4.2.0");
//# sourceMappingURL=lit-element.js.map

;// ./node_modules/lit/index.js

//# sourceMappingURL=index.js.map


/***/ }),

/***/ 204707:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u$: () => (/* binding */ subscribeKey),
/* harmony export */   zC: () => (/* binding */ proxyMap)
/* harmony export */ });
/* unused harmony exports addComputed, devtools, proxySet, proxyWithComputed, proxyWithHistory, watch */
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);




function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}

let currentCleanups;
function watch(callback, options) {
  let alive = true;
  const cleanups = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new Map();
  const cleanup = () => {
    if (alive) {
      alive = false;
      cleanups.forEach((clean) => clean());
      cleanups.clear();
      subscriptions.forEach((unsubscribe) => unsubscribe());
      subscriptions.clear();
    }
  };
  const revalidate = async () => {
    if (!alive) {
      return;
    }
    cleanups.forEach((clean) => clean());
    cleanups.clear();
    const proxiesToSubscribe = /* @__PURE__ */ new Set();
    const parent = currentCleanups;
    currentCleanups = cleanups;
    try {
      const promiseOrPossibleCleanup = callback((proxyObject) => {
        proxiesToSubscribe.add(proxyObject);
        if (alive && !subscriptions.has(proxyObject)) {
          const unsubscribe = subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);
          subscriptions.set(proxyObject, unsubscribe);
        }
        return proxyObject;
      });
      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;
      if (couldBeCleanup) {
        if (alive) {
          cleanups.add(couldBeCleanup);
        } else {
          cleanup();
        }
      }
    } finally {
      currentCleanups = parent;
    }
    subscriptions.forEach((unsubscribe, proxyObject) => {
      if (!proxiesToSubscribe.has(proxyObject)) {
        subscriptions.delete(proxyObject);
        unsubscribe();
      }
    });
  };
  if (currentCleanups) {
    currentCleanups.add(cleanup);
  }
  revalidate();
  return cleanup;
}

const DEVTOOLS = Symbol();
function devtools(proxyObject, options) {
  if (typeof options === "string") {
    console.warn(
      "string name option is deprecated, use { name }. https://github.com/pmndrs/valtio/pull/400"
    );
    options = { name: options };
  }
  const { enabled, name = "", ...rest } = options || {};
  let extension;
  try {
    extension = (enabled != null ? enabled : ( false ? 0 : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extension) {
    if (( false ? 0 : void 0) !== "production" && enabled) {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({ name, ...rest });
  const unsub1 = subscribe(proxyObject, (ops) => {
    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(".")}`).join(", ");
    if (!action) {
      return;
    }
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));
      delete snapWithoutDevtools[DEVTOOLS];
      devtools2.send(
        {
          type: action,
          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()
        },
        snapWithoutDevtools
      );
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c, _d, _e, _f;
    if (message.type === "ACTION" && message.payload) {
      try {
        Object.assign(proxyObject, JSON.parse(message.payload));
      } catch (e) {
        console.error(
          "please dispatch a serializable value that JSON.parse() and proxy() support\n",
          e
        );
      }
    }
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
        const state = JSON.parse(message.state);
        Object.assign(proxyObject, state);
      }
      proxyObject[DEVTOOLS] = message;
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({ state }, index) => {
        const action = actions[index] || "No action found";
        Object.assign(proxyObject, state);
        if (index === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2 == null ? void 0 : unsub2();
  };
}

function addComputed_DEPRECATED(proxyObject, computedFns_FAKE, targetObject = proxyObject) {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "addComputed is deprecated. Please consider using `derive`. Falling back to emulation with derive. https://github.com/pmndrs/valtio/pull/201"
    );
  }
  const derivedFns = {};
  Object.keys(computedFns_FAKE).forEach((key) => {
    derivedFns[key] = (get) => computedFns_FAKE[key](get(proxyObject));
  });
  return derive(derivedFns, { proxy: targetObject });
}

function proxyWithComputed_DEPRECATED(initialObject, computedFns) {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      'proxyWithComputed is deprecated. Please follow "Computed Properties" guide in docs.'
    );
  }
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set) {
      desc.set = (newValue) => set(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

const isObject = (x) => typeof x === "object" && x !== null;
let refSet;
const deepClone = (obj) => {
  if (!refSet) {
    refSet = unstable_buildProxyFunction()[2];
  }
  if (!isObject(obj) || refSet.has(obj)) {
    return obj;
  }
  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  Reflect.ownKeys(obj).forEach((key) => {
    baseObject[key] = deepClone(obj[key]);
  });
  return baseObject;
};
function proxyWithHistory_DEPRECATED(initialValue, skipSubscribe = false) {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      'proxyWithHistory is deprecated. Please use the "valtio-history" package; refer to the docs'
    );
  }
  const proxyObject = proxy({
    value: initialValue,
    history: ref({
      wip: void 0,
      // to avoid infinite loop
      snapshots: [],
      index: -1
    }),
    clone: deepClone,
    canUndo: () => proxyObject.history.index > 0,
    undo: () => {
      if (proxyObject.canUndo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.clone(
          proxyObject.history.snapshots[--proxyObject.history.index]
        );
      }
    },
    canRedo: () => proxyObject.history.index < proxyObject.history.snapshots.length - 1,
    redo: () => {
      if (proxyObject.canRedo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.clone(
          proxyObject.history.snapshots[++proxyObject.history.index]
        );
      }
    },
    saveHistory: () => {
      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);
      proxyObject.history.snapshots.push(snapshot(proxyObject).value);
      ++proxyObject.history.index;
    },
    subscribe: () => subscribe(proxyObject, (ops) => {
      if (ops.every(
        (op) => op[1][0] === "value" && (op[0] !== "set" || op[2] !== proxyObject.history.wip)
      )) {
        proxyObject.saveHistory();
      }
    })
  });
  proxyObject.saveHistory();
  if (!skipSubscribe) {
    proxyObject.subscribe();
  }
  return proxyObject;
}

function proxySet(initialValues) {
  const set = proxy({
    data: Array.from(new Set(initialValues)),
    has(value) {
      return this.data.indexOf(value) !== -1;
    },
    add(value) {
      let hasProxy = false;
      if (typeof value === "object" && value !== null) {
        hasProxy = this.data.indexOf(proxy(value)) !== -1;
      }
      if (this.data.indexOf(value) === -1 && !hasProxy) {
        this.data.push(value);
      }
      return this;
    },
    delete(value) {
      const index = this.data.indexOf(value);
      if (index === -1) {
        return false;
      }
      this.data.splice(index, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    forEach(cb) {
      this.data.forEach((value) => {
        cb(value, value, this);
      });
    },
    get [Symbol.toStringTag]() {
      return "Set";
    },
    toJSON() {
      return new Set(this.data);
    },
    [Symbol.iterator]() {
      return this.data[Symbol.iterator]();
    },
    values() {
      return this.data.values();
    },
    keys() {
      return this.data.values();
    },
    entries() {
      return new Set(this.data).entries();
    }
  });
  Object.defineProperties(set, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(set);
  return set;
}

function proxyMap(entries) {
  const map = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    data: Array.from(entries || []),
    has(key) {
      return this.data.some((p) => p[0] === key);
    },
    set(key, value) {
      const record = this.data.find((p) => p[0] === key);
      if (record) {
        record[1] = value;
      } else {
        this.data.push([key, value]);
      }
      return this;
    },
    get(key) {
      var _a;
      return (_a = this.data.find((p) => p[0] === key)) == null ? void 0 : _a[1];
    },
    delete(key) {
      const index = this.data.findIndex((p) => p[0] === key);
      if (index === -1) {
        return false;
      }
      this.data.splice(index, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(cb) {
      this.data.forEach((p) => {
        cb(p[1], p[0], this);
      });
    },
    keys() {
      return this.data.map((p) => p[0]).values();
    },
    values() {
      return this.data.map((p) => p[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  });
  Object.defineProperties(map, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(map);
  return map;
}




/***/ }),

/***/ 226742:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ CoreHelperUtil)
/* harmony export */ });
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(824376);
/* harmony import */ var _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(562944);
/* harmony import */ var _StorageUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127508);



const CoreHelperUtil = {
    isMobile() {
        if (this.isClient()) {
            return Boolean((typeof window?.matchMedia === 'function' &&
                window?.matchMedia('(pointer:coarse)')?.matches) ||
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
        }
        return false;
    },
    checkCaipNetwork(network, networkName = '') {
        return network?.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());
    },
    isAndroid() {
        if (!this.isMobile()) {
            return false;
        }
        const ua = window?.navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && ua.includes('android');
    },
    isIos() {
        if (!this.isMobile()) {
            return false;
        }
        const ua = window?.navigator.userAgent.toLowerCase();
        return ua.includes('iphone') || ua.includes('ipad');
    },
    isSafari() {
        if (!this.isClient()) {
            return false;
        }
        const ua = window?.navigator.userAgent.toLowerCase();
        return ua.includes('safari');
    },
    isClient() {
        return typeof window !== 'undefined';
    },
    isPairingExpired(expiry) {
        return expiry ? expiry - Date.now() <= _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .oU.TEN_SEC_MS : true;
    },
    isAllowedRetry(lastRetry, differenceMs = _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .oU.ONE_SEC_MS) {
        return Date.now() - lastRetry >= differenceMs;
    },
    copyToClopboard(text) {
        navigator.clipboard.writeText(text);
    },
    isIframe() {
        try {
            return window?.self !== window?.top;
        }
        catch (e) {
            return false;
        }
    },
    isSafeApp() {
        if (CoreHelperUtil.isClient() && window.self !== window.top) {
            try {
                const ancestor = window?.location?.ancestorOrigins?.[0];
                const safeAppUrl = 'https://app.safe.global';
                if (ancestor) {
                    const ancestorUrl = new URL(ancestor);
                    const safeUrl = new URL(safeAppUrl);
                    return ancestorUrl.hostname === safeUrl.hostname;
                }
            }
            catch {
                return false;
            }
        }
        return false;
    },
    getPairingExpiry() {
        return Date.now() + _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .oU.FOUR_MINUTES_MS;
    },
    getNetworkId(caipAddress) {
        return caipAddress?.split(':')[1];
    },
    getPlainAddress(caipAddress) {
        return caipAddress?.split(':')[2];
    },
    async wait(milliseconds) {
        return new Promise(resolve => {
            setTimeout(resolve, milliseconds);
        });
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    debounce(func, timeout = 500) {
        let timer = undefined;
        return (...args) => {
            function next() {
                func(...args);
            }
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(next, timeout);
        };
    },
    isHttpUrl(url) {
        return url.startsWith('http://') || url.startsWith('https://');
    },
    formatNativeUrl(appUrl, wcUri, universalLink = null) {
        if (CoreHelperUtil.isHttpUrl(appUrl)) {
            return this.formatUniversalUrl(appUrl, wcUri);
        }
        let safeAppUrl = appUrl;
        let safeUniversalLink = universalLink;
        if (!safeAppUrl.includes('://')) {
            safeAppUrl = appUrl.replaceAll('/', '').replaceAll(':', '');
            safeAppUrl = `${safeAppUrl}://`;
        }
        if (!safeAppUrl.endsWith('/')) {
            safeAppUrl = `${safeAppUrl}/`;
        }
        if (safeUniversalLink && !safeUniversalLink?.endsWith('/')) {
            safeUniversalLink = `${safeUniversalLink}/`;
        }
        // Android deeplinks in tg context require the uri to be encoded twice
        if (this.isTelegram() && this.isAndroid()) {
            // eslint-disable-next-line no-param-reassign
            wcUri = encodeURIComponent(wcUri);
        }
        const encodedWcUrl = encodeURIComponent(wcUri);
        return {
            redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
            redirectUniversalLink: safeUniversalLink
                ? `${safeUniversalLink}wc?uri=${encodedWcUrl}`
                : undefined,
            href: safeAppUrl
        };
    },
    formatUniversalUrl(appUrl, wcUri) {
        if (!CoreHelperUtil.isHttpUrl(appUrl)) {
            return this.formatNativeUrl(appUrl, wcUri);
        }
        let safeAppUrl = appUrl;
        if (!safeAppUrl.endsWith('/')) {
            safeAppUrl = `${safeAppUrl}/`;
        }
        const encodedWcUrl = encodeURIComponent(wcUri);
        return {
            redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
            href: safeAppUrl
        };
    },
    getOpenTargetForPlatform(target) {
        if (target === 'popupWindow') {
            return target;
        }
        // Only '_blank' deeplinks work in Telegram context
        if (this.isTelegram()) {
            // But for social login, we need to load the page in the same context
            if (_StorageUtil_js__WEBPACK_IMPORTED_MODULE_1__/* .StorageUtil */ .i.getTelegramSocialProvider()) {
                return '_top';
            }
            return '_blank';
        }
        return target;
    },
    openHref(href, target, features) {
        window?.open(href, this.getOpenTargetForPlatform(target), features || 'noreferrer noopener');
    },
    returnOpenHref(href, target, features) {
        return window?.open(href, this.getOpenTargetForPlatform(target), features || 'noreferrer noopener');
    },
    isTelegram() {
        return (typeof window !== 'undefined' &&
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (Boolean(window.TelegramWebviewProxy) ||
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                Boolean(window.Telegram) ||
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                Boolean(window.TelegramWebviewProxyProto)));
    },
    isPWA() {
        if (typeof window === 'undefined') {
            return false;
        }
        const isStandaloneDisplayMode = window.matchMedia?.('(display-mode: standalone)')?.matches;
        const isIOSStandalone = window?.navigator?.standalone;
        return Boolean(isStandaloneDisplayMode || isIOSStandalone);
    },
    async preloadImage(src) {
        const imagePromise = new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = resolve;
            image.onerror = reject;
            image.crossOrigin = 'anonymous';
            image.src = src;
        });
        return Promise.race([imagePromise, CoreHelperUtil.wait(2000)]);
    },
    formatBalance(balance, symbol) {
        let formattedBalance = '0.000';
        if (typeof balance === 'string') {
            const number = Number(balance);
            if (number) {
                const formattedValue = Math.floor(number * 1000) / 1000;
                if (formattedValue) {
                    formattedBalance = formattedValue.toString();
                }
            }
        }
        return `${formattedBalance}${symbol ? ` ${symbol}` : ''}`;
    },
    formatBalance2(balance, symbol) {
        let formattedBalance = undefined;
        if (balance === '0') {
            formattedBalance = '0';
        }
        else if (typeof balance === 'string') {
            const number = Number(balance);
            if (number) {
                formattedBalance = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
            }
        }
        return {
            value: formattedBalance ?? '0',
            rest: formattedBalance === '0' ? '000' : '',
            symbol
        };
    },
    getApiUrl() {
        return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .ConstantsUtil */ .o.W3M_API_URL;
    },
    getBlockchainApiUrl() {
        return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .ConstantsUtil */ .o.BLOCKCHAIN_API_RPC_URL;
    },
    getAnalyticsUrl() {
        return _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .ConstantsUtil */ .o.PULSE_API_URL;
    },
    getUUID() {
        if (crypto?.randomUUID) {
            return crypto.randomUUID();
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, c => {
            const r = (Math.random() * 16) | 0;
            const v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    parseError(error) {
        if (typeof error === 'string') {
            return error;
        }
        else if (typeof error?.issues?.[0]?.message === 'string') {
            return error.issues[0].message;
        }
        else if (error instanceof Error) {
            return error.message;
        }
        return 'Unknown error';
    },
    sortRequestedNetworks(approvedIds, requestedNetworks = []) {
        const approvedIndexMap = {};
        if (requestedNetworks && approvedIds) {
            approvedIds.forEach((id, index) => {
                approvedIndexMap[id] = index;
            });
            requestedNetworks.sort((a, b) => {
                const indexA = approvedIndexMap[a.id];
                const indexB = approvedIndexMap[b.id];
                if (indexA !== undefined && indexB !== undefined) {
                    return indexA - indexB;
                }
                else if (indexA !== undefined) {
                    return -1;
                }
                else if (indexB !== undefined) {
                    return 1;
                }
                return 0;
            });
        }
        return requestedNetworks;
    },
    calculateBalance(array) {
        let sum = 0;
        for (const item of array) {
            sum += item.value ?? 0;
        }
        return sum;
    },
    formatTokenBalance(number) {
        const roundedNumber = number.toFixed(2);
        const [dollars, pennies] = roundedNumber.split('.');
        return { dollars, pennies };
    },
    isAddress(address, chain = 'eip155') {
        switch (chain) {
            case 'eip155':
                if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
                    return false;
                }
                else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) ||
                    /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
                    return true;
                }
                return false;
            case 'solana':
                return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
            default:
                return false;
        }
    },
    uniqueBy(arr, key) {
        const set = new Set();
        return arr.filter(item => {
            const keyValue = item[key];
            if (set.has(keyValue)) {
                return false;
            }
            set.add(keyValue);
            return true;
        });
    },
    generateSdkVersion(adapters, platform, version) {
        const hasNoAdapters = adapters.length === 0;
        const adapterNames = (hasNoAdapters
            ? _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .oU.ADAPTER_TYPES.UNIVERSAL
            : adapters.map(adapter => adapter.adapterType).join(','));
        return `${platform}-${adapterNames}-${version}`;
    },
    // eslint-disable-next-line max-params
    createAccount(namespace, address, type, publicKey, path) {
        return {
            namespace,
            address,
            type,
            publicKey,
            path
        };
    },
    isCaipAddress(address) {
        if (typeof address !== 'string') {
            return false;
        }
        const sections = address.split(':');
        const namespace = sections[0];
        return (sections.filter(Boolean).length === 3 &&
            namespace in _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .ConstantsUtil */ .o.CHAIN_NAME_MAP);
    },
    isMac() {
        const ua = window?.navigator.userAgent.toLowerCase();
        return ua.includes('macintosh') && !ua.includes('safari');
    },
    formatTelegramSocialLoginUrl(url) {
        const valueToInject = `--${encodeURIComponent(window?.location.href)}`;
        const paramToInject = 'state=';
        const parsedUrl = new URL(url);
        if (parsedUrl.host === 'auth.magic.link') {
            const providerParam = 'provider_authorization_url=';
            const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);
            const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);
            return url.replace(providerUrl, encodeURIComponent(resultUrl));
        }
        return this.injectIntoUrl(url, paramToInject, valueToInject);
    },
    injectIntoUrl(url, key, appendString) {
        // Find the position of "key" e.g. "state=" in the URL
        const keyIndex = url.indexOf(key);
        if (keyIndex === -1) {
            throw new Error(`${key} parameter not found in the URL: ${url}`);
        }
        // Find the position of the next "&" after "key"
        const keyEndIndex = url.indexOf('&', keyIndex);
        const keyLength = key.length;
        // If there is no "&" after key, it means "key" is the last parameter
        // eslint-disable-next-line no-negated-condition
        const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;
        // Extract the part of the URL before the key value
        const beforeKeyValue = url.substring(0, keyIndex + keyLength);
        // Extract the current key value
        const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);
        // Extract the part of the URL after the key value
        const afterKeyValue = url.substring(keyEndIndex);
        // Append the new string to the key value
        const newKeyValue = currentKeyValue + appendString;
        // Reconstruct the URL with the appended key value
        const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;
        return newUrl;
    }
};
//# sourceMappingURL=CoreHelperUtil.js.map

/***/ }),

/***/ 236010:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ ConnectorController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(824376);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(323096);
/* harmony import */ var _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(725574);
/* harmony import */ var _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127508);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(923082);
/* harmony import */ var _ApiController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188249);
/* harmony import */ var _ChainController_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(806056);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(500026);
/* harmony import */ var _RouterController_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(778508);
/* harmony import */ var _ThemeController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(568996);











const defaultActiveConnectors = {
    eip155: undefined,
    solana: undefined,
    polkadot: undefined,
    bip122: undefined,
    cosmos: undefined
};
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    allConnectors: [],
    connectors: [],
    activeConnector: undefined,
    filterByNamespace: undefined,
    activeConnectorIds: { ...defaultActiveConnectors },
    filterByNamespaceMap: {
        eip155: true,
        solana: true,
        polkadot: true,
        bip122: true,
        cosmos: true
    }
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state, () => {
            callback(state);
        });
    },
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    initialize(namespaces) {
        namespaces.forEach(namespace => {
            const connectorId = _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.getConnectedConnectorId(namespace);
            if (connectorId) {
                ConnectorController.setConnectorId(connectorId, namespace);
            }
        });
    },
    setActiveConnector(connector) {
        if (connector) {
            state.activeConnector = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(connector);
        }
    },
    setConnectors(connectors) {
        const newConnectors = connectors.filter(newConnector => !state.allConnectors.some(existingConnector => existingConnector.id === newConnector.id &&
            ConnectorController.getConnectorName(existingConnector.name) ===
                ConnectorController.getConnectorName(newConnector.name) &&
            existingConnector.chain === newConnector.chain));
        /**
         * We are reassigning the state of the proxy to a new array of new objects, ConnectorController can cause issues. So it is better to use ref in ConnectorController case.
         * Check more about proxy on https://valtio.dev/docs/api/basic/proxy#Gotchas
         * Check more about ref on https://valtio.dev/docs/api/basic/ref
         */
        newConnectors.forEach(connector => {
            if (connector.type !== 'MULTI_CHAIN') {
                state.allConnectors.push((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(connector));
            }
        });
        const enabledNamespaces = ConnectorController.getEnabledNamespaces();
        const connectorsFilteredByNamespaces = ConnectorController.getEnabledConnectors(enabledNamespaces);
        state.connectors = ConnectorController.mergeMultiChainConnectors(connectorsFilteredByNamespaces);
    },
    filterByNamespaces(enabledNamespaces) {
        Object.keys(state.filterByNamespaceMap).forEach(namespace => {
            state.filterByNamespaceMap[namespace] = false;
        });
        enabledNamespaces.forEach(namespace => {
            state.filterByNamespaceMap[namespace] = true;
        });
        ConnectorController.updateConnectorsForEnabledNamespaces();
    },
    filterByNamespace(namespace, enabled) {
        state.filterByNamespaceMap[namespace] = enabled;
        ConnectorController.updateConnectorsForEnabledNamespaces();
    },
    updateConnectorsForEnabledNamespaces() {
        const enabledNamespaces = ConnectorController.getEnabledNamespaces();
        const enabledConnectors = ConnectorController.getEnabledConnectors(enabledNamespaces);
        const areAllNamespacesEnabled = ConnectorController.areAllNamespacesEnabled();
        state.connectors = ConnectorController.mergeMultiChainConnectors(enabledConnectors);
        if (areAllNamespacesEnabled) {
            _ApiController_js__WEBPACK_IMPORTED_MODULE_3__/* .ApiController */ .N.clearFilterByNamespaces();
        }
        else {
            _ApiController_js__WEBPACK_IMPORTED_MODULE_3__/* .ApiController */ .N.filterByNamespaces(enabledNamespaces);
        }
    },
    getEnabledNamespaces() {
        return Object.entries(state.filterByNamespaceMap)
            .filter(([_, enabled]) => enabled)
            .map(([namespace]) => namespace);
    },
    getEnabledConnectors(enabledNamespaces) {
        return state.allConnectors.filter(connector => enabledNamespaces.includes(connector.chain));
    },
    areAllNamespacesEnabled() {
        return Object.values(state.filterByNamespaceMap).every(enabled => enabled);
    },
    mergeMultiChainConnectors(connectors) {
        const connectorsByNameMap = ConnectorController.generateConnectorMapByName(connectors);
        const mergedConnectors = [];
        connectorsByNameMap.forEach(keyConnectors => {
            const firstItem = keyConnectors[0];
            const isAuthConnector = firstItem?.id === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_4__/* .ConstantsUtil */ .o.CONNECTOR_ID.AUTH;
            if (keyConnectors.length > 1 && firstItem) {
                mergedConnectors.push({
                    name: firstItem.name,
                    imageUrl: firstItem.imageUrl,
                    imageId: firstItem.imageId,
                    connectors: [...keyConnectors],
                    type: isAuthConnector ? 'AUTH' : 'MULTI_CHAIN',
                    // These values are just placeholders, we don't use them in multi-chain connector select screen
                    chain: 'eip155',
                    id: firstItem?.id || ''
                });
            }
            else if (firstItem) {
                mergedConnectors.push(firstItem);
            }
        });
        return mergedConnectors;
    },
    generateConnectorMapByName(connectors) {
        const connectorsByNameMap = new Map();
        connectors.forEach(connector => {
            const { name } = connector;
            const connectorName = ConnectorController.getConnectorName(name);
            if (!connectorName) {
                return;
            }
            const connectorsByName = connectorsByNameMap.get(connectorName) || [];
            const haveSameConnector = connectorsByName.find(c => c.chain === connector.chain);
            if (!haveSameConnector) {
                connectorsByName.push(connector);
            }
            connectorsByNameMap.set(connectorName, connectorsByName);
        });
        return connectorsByNameMap;
    },
    getConnectorName(name) {
        if (!name) {
            return name;
        }
        const nameOverrideMap = {
            'Trust Wallet': 'Trust'
        };
        return nameOverrideMap[name] || name;
    },
    getUniqueConnectorsByName(connectors) {
        const uniqueConnectors = [];
        connectors.forEach(c => {
            if (!uniqueConnectors.find(uc => uc.chain === c.chain)) {
                uniqueConnectors.push(c);
            }
        });
        return uniqueConnectors;
    },
    addConnector(connector) {
        if (connector.id === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_4__/* .ConstantsUtil */ .o.CONNECTOR_ID.AUTH) {
            const authConnector = connector;
            const optionsState = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .snapshot */ .P9)(_OptionsController_js__WEBPACK_IMPORTED_MODULE_5__/* .OptionsController */ .H.state);
            const themeMode = _ThemeController_js__WEBPACK_IMPORTED_MODULE_6__/* .ThemeController */ .W.getSnapshot().themeMode;
            const themeVariables = _ThemeController_js__WEBPACK_IMPORTED_MODULE_6__/* .ThemeController */ .W.getSnapshot().themeVariables;
            authConnector?.provider?.syncDappData?.({
                metadata: optionsState.metadata,
                sdkVersion: optionsState.sdkVersion,
                projectId: optionsState.projectId,
                sdkType: optionsState.sdkType
            });
            authConnector?.provider?.syncTheme({
                themeMode,
                themeVariables,
                w3mThemeVariables: (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_7__/* .getW3mThemeVariables */ .o)(themeVariables, themeMode)
            });
            ConnectorController.setConnectors([connector]);
        }
        else {
            ConnectorController.setConnectors([connector]);
        }
    },
    getAuthConnector(chainNamespace) {
        const activeNamespace = chainNamespace || _ChainController_js__WEBPACK_IMPORTED_MODULE_8__/* .ChainController */ .W.state.activeChain;
        const authConnector = state.connectors.find(c => c.id === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_4__/* .ConstantsUtil */ .o.CONNECTOR_ID.AUTH);
        if (!authConnector) {
            return undefined;
        }
        if (authConnector?.connectors?.length) {
            const connector = authConnector.connectors.find(c => c.chain === activeNamespace);
            return connector;
        }
        return authConnector;
    },
    getAnnouncedConnectorRdns() {
        return state.connectors.filter(c => c.type === 'ANNOUNCED').map(c => c.info?.rdns);
    },
    getConnectorById(id) {
        return state.allConnectors.find(c => c.id === id);
    },
    getConnector(id, rdns) {
        const connectorsByNamespace = state.allConnectors.filter(c => c.chain === _ChainController_js__WEBPACK_IMPORTED_MODULE_8__/* .ChainController */ .W.state.activeChain);
        return connectorsByNamespace.find(c => c.explorerId === id || c.info?.rdns === rdns);
    },
    syncIfAuthConnector(connector) {
        if (connector.id !== 'ID_AUTH') {
            return;
        }
        const authConnector = connector;
        const optionsState = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .snapshot */ .P9)(_OptionsController_js__WEBPACK_IMPORTED_MODULE_5__/* .OptionsController */ .H.state);
        const themeMode = _ThemeController_js__WEBPACK_IMPORTED_MODULE_6__/* .ThemeController */ .W.getSnapshot().themeMode;
        const themeVariables = _ThemeController_js__WEBPACK_IMPORTED_MODULE_6__/* .ThemeController */ .W.getSnapshot().themeVariables;
        authConnector?.provider?.syncDappData?.({
            metadata: optionsState.metadata,
            sdkVersion: optionsState.sdkVersion,
            sdkType: optionsState.sdkType,
            projectId: optionsState.projectId
        });
        authConnector.provider.syncTheme({
            themeMode,
            themeVariables,
            w3mThemeVariables: (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_7__/* .getW3mThemeVariables */ .o)(themeVariables, themeMode)
        });
    },
    /**
     * Returns the connectors filtered by namespace.
     * @param namespace - The namespace to filter the connectors by.
     * @returns ConnectorWithProviders[].
     */
    getConnectorsByNamespace(namespace) {
        const namespaceConnectors = state.allConnectors.filter(connector => connector.chain === namespace);
        return ConnectorController.mergeMultiChainConnectors(namespaceConnectors);
    },
    selectWalletConnector(wallet) {
        const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
        const namespace = _ChainController_js__WEBPACK_IMPORTED_MODULE_8__/* .ChainController */ .W.state.activeChain;
        _utils_MobileWallet_js__WEBPACK_IMPORTED_MODULE_9__/* .MobileWalletUtil */ .W.handleMobileDeeplinkRedirect(connector?.explorerId || wallet.id, namespace);
        if (connector) {
            _RouterController_js__WEBPACK_IMPORTED_MODULE_10__/* .RouterController */ .I.push('ConnectingExternal', { connector });
        }
        else {
            _RouterController_js__WEBPACK_IMPORTED_MODULE_10__/* .RouterController */ .I.push('ConnectingWalletConnect', { wallet });
        }
    },
    /**
     * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
     * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
     * @returns ConnectorWithProviders[].
     */
    getConnectors(namespace) {
        if (namespace) {
            return ConnectorController.getConnectorsByNamespace(namespace);
        }
        return ConnectorController.mergeMultiChainConnectors(state.allConnectors);
    },
    /**
     * Sets the filter by namespace and updates the connectors.
     * @param namespace - The namespace to filter the connectors by.
     */
    setFilterByNamespace(namespace) {
        state.filterByNamespace = namespace;
        state.connectors = ConnectorController.getConnectors(namespace);
        _ApiController_js__WEBPACK_IMPORTED_MODULE_3__/* .ApiController */ .N.setFilterByNamespace(namespace);
    },
    setConnectorId(connectorId, namespace) {
        if (connectorId) {
            state.activeConnectorIds = {
                ...state.activeConnectorIds,
                [namespace]: connectorId
            };
            _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.setConnectedConnectorId(namespace, connectorId);
        }
    },
    removeConnectorId(namespace) {
        state.activeConnectorIds = {
            ...state.activeConnectorIds,
            [namespace]: undefined
        };
        _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.deleteConnectedConnectorId(namespace);
    },
    getConnectorId(namespace) {
        if (!namespace) {
            return undefined;
        }
        return state.activeConnectorIds[namespace];
    },
    isConnected(namespace) {
        if (!namespace) {
            return Object.values(state.activeConnectorIds).some(id => Boolean(id));
        }
        return Boolean(state.activeConnectorIds[namespace]);
    },
    resetConnectorIds() {
        state.activeConnectorIds = { ...defaultActiveConnectors };
    }
};
// Export the controller wrapped with our error boundary
const ConnectorController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_11__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=ConnectorController.js.map

/***/ }),

/***/ 240173:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JW: () => (/* binding */ T),
/* harmony export */   XX: () => (/* binding */ j),
/* harmony export */   c0: () => (/* binding */ w),
/* harmony export */   ge: () => (/* binding */ W),
/* harmony export */   qy: () => (/* binding */ x),
/* harmony export */   s6: () => (/* binding */ E)
/* harmony export */ });
/* unused harmony export mathml */
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t=globalThis,i=t.trustedTypes,s=i?i.createPolicy("lit-html",{createHTML:t=>t}):void 0,e="$lit$",h=`lit$${Math.random().toFixed(9).slice(2)}$`,o="?"+h,n=`<${o}>`,r=void 0===t.document?{createTreeWalker:()=>({})}:document,l=()=>r.createComment(""),c=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=>a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),T=y(2),b=y(3),w=Symbol.for("lit-noChange"),E=Symbol.for("lit-nothing"),A=new WeakMap,C=r.createTreeWalker(r,129);function P(t,i){if(!a(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s?s.createHTML(i):i}const V=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":3===i?"<math>":"",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f?s+n:d>=0?(o.push(a),s.slice(0,d)+e+s.slice(d)+h+x):s+h+(-2===d?i:x)}return[P(t,l+(t[s]||"<?>")+(2===i?"</svg>":3===i?"</math>":"")),o]};class N{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=V(t,s);if(this.el=N.createElement(f,n),C.currentNode=this.el.content,2===s||3===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes)}for(;null!==(r=C.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e)){const i=v[a++],s=r.getAttribute(t).split(h),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?H:"?"===e[1]?I:"@"===e[1]?L:R}),r.removeAttribute(t)}else t.startsWith(h)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h),s=t.length-1;if(s>0){r.textContent=i?i.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l()),C.nextNode(),d.push({type:2,index:++c});r.append(t[s],l())}}}else if(8===r.nodeType)if(r.data===o)d.push({type:2,index:c});else{let t=-1;for(;-1!==(t=r.data.indexOf(h,t+1));)d.push({type:7,index:c}),t+=h.length-1}c++}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function S(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=S(t,h._$AS(t,i.values),h,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r).importNode(i,!0);C.currentNode=e;let h=C.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new k(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new z(h,this,t)),this._$AV.push(i),l=s[++n]}o!==l?.index&&(h=C.nextNode(),o++)}return C.currentNode=r,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class k{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=E,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S(this,t,i),c(t)?t===E||null==t||""===t?(this._$AH!==E&&this._$AR(),this._$AH=E):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u(t)?this.k(t):this._(t)}O(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.O(t))}_(t){this._$AH!==E&&c(this._$AH)?this._$AA.nextSibling.data=t:this.T(r.createTextNode(t)),this._$AH=t}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=N.createElement(P(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else{const t=new M(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new N(t)),i}k(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new k(this.O(l()),this.O(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t))}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=E,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=E}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=S(this,t,i,0),o=!c(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else{const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=S(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c(r)||r!==this._$AH[n],r===E?t=E:t!==E&&(t+=(r??"")+h[n+1]),this._$AH[n]=r}o&&!e&&this.j(t)}j(t){t===E?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"")}}class H extends R{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===E?void 0:t}}class I extends R{constructor(){super(...arguments),this.type=4}j(t){this.element.toggleAttribute(this.name,!!t&&t!==E)}}class L extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5}_$AI(t,i=this){if((t=S(this,t,i,0)??E)===w)return;const s=this._$AH,e=t===E&&s!==E||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==E&&(s===E||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t)}}class z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){S(this,t)}}const W={M:e,P:h,A:o,C:1,L:V,R:M,D:u,V:S,I:k,H:R,N:I,U:L,B:H,F:z},Z=t.litHtmlPolyfillSupport;Z?.(N,k),(t.litHtmlVersions??=[]).push("3.3.0");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new k(i.insertBefore(l(),t),t,void 0,s??{})}return h._$AI(t),h};
//# sourceMappingURL=lit-html.js.map


/***/ }),

/***/ 243494:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ customElement)
/* harmony export */ });
function standardCustomElement(tagName, descriptor) {
    const { kind, elements } = descriptor;
    return {
        kind,
        elements,
        finisher(clazz) {
            if (!customElements.get(tagName)) {
                customElements.define(tagName, clazz);
            }
        }
    };
}
function legacyCustomElement(tagName, clazz) {
    if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
    }
    return clazz;
}
function customElement(tagName) {
    return function create(classOrDescriptor) {
        return typeof classOrDescriptor === 'function'
            ? legacyCustomElement(tagName, classOrDescriptor)
            : standardCustomElement(tagName, classOrDescriptor);
    };
}
//# sourceMappingURL=WebComponentsUtil.js.map

/***/ }),

/***/ 323096:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ getW3mThemeVariables)
/* harmony export */ });
function getW3mThemeVariables(themeVariables, themeType) {
    if (themeType === 'light') {
        return {
            '--w3m-accent': themeVariables?.['--w3m-accent'] || 'hsla(231, 100%, 70%, 1)',
            '--w3m-background': '#fff'
        };
    }
    return {
        '--w3m-accent': themeVariables?.['--w3m-accent'] || 'hsla(230, 100%, 67%, 1)',
        '--w3m-background': '#121313'
    };
}
//# sourceMappingURL=ThemeUtil.js.map

/***/ }),

/***/ 335306:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ HelpersUtil)
/* harmony export */ });
/* harmony import */ var _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(669510);

const HelpersUtil = {
    getCaipTokens(tokens) {
        if (!tokens) {
            return undefined;
        }
        const caipTokens = {};
        Object.entries(tokens).forEach(([id, token]) => {
            caipTokens[`${_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .o.EIP155}:${id}`] = token;
        });
        return caipTokens;
    },
    isLowerCaseMatch(str1, str2) {
        return str1?.toLowerCase() === str2?.toLowerCase();
    }
};
//# sourceMappingURL=HelpersUtil.js.map

/***/ }),

/***/ 390184:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ EventsController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(682419);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(824376);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(46036);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226742);
/* harmony import */ var _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25905);
/* harmony import */ var _AccountController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(863450);
/* harmony import */ var _AlertController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(471655);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(500026);







// -- Helpers ------------------------------------------- //
const baseUrl = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.getAnalyticsUrl();
const api = new _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_1__/* .FetchUtil */ .Z({ baseUrl, clientId: null });
const excluded = ['MODAL_CREATED'];
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__/* .proxy */ .BX)({
    timestamp: Date.now(),
    reportedErrors: {},
    data: {
        type: 'track',
        event: 'MODAL_CREATED'
    }
});
// -- Controller ---------------------------------------- //
const EventsController = {
    state,
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__/* .subscribe */ .B1)(state, () => callback(state));
    },
    getSdkProperties() {
        const { projectId, sdkType, sdkVersion } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state;
        return {
            projectId,
            st: sdkType,
            sv: sdkVersion || 'html-wagmi-4.2.2'
        };
    },
    async _sendAnalyticsEvent(payload) {
        try {
            const address = _AccountController_js__WEBPACK_IMPORTED_MODULE_4__/* .AccountController */ .U.state.address;
            if (excluded.includes(payload.data.event) || typeof window === 'undefined') {
                return;
            }
            await api.post({
                path: '/e',
                params: EventsController.getSdkProperties(),
                body: {
                    eventId: _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.getUUID(),
                    url: window.location.href,
                    domain: window.location.hostname,
                    timestamp: payload.timestamp,
                    props: { ...payload.data, address }
                }
            });
            state.reportedErrors['FORBIDDEN'] = false;
        }
        catch (err) {
            const isForbiddenError = err instanceof Error &&
                err.cause instanceof Response &&
                err.cause.status === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_5__/* .ConstantsUtil */ .o.HTTP_STATUS_CODES.FORBIDDEN &&
                !state.reportedErrors['FORBIDDEN'];
            if (isForbiddenError) {
                _AlertController_js__WEBPACK_IMPORTED_MODULE_6__/* .AlertController */ .h.open({
                    shortMessage: 'Invalid App Configuration',
                    longMessage: `Origin ${(0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_7__/* .isSafe */ .IP)() ? window.origin : 'uknown'} not found on Allowlist - update configuration on cloud.reown.com`
                }, 'error');
                state.reportedErrors['FORBIDDEN'] = true;
            }
        }
    },
    sendEvent(data) {
        state.timestamp = Date.now();
        state.data = data;
        if (_OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.features?.analytics) {
            EventsController._sendAnalyticsEvent(state);
        }
    }
};
//# sourceMappingURL=EventsController.js.map

/***/ }),

/***/ 441454:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Zv: () => (/* reexport */ UiHelperUtil/* UiHelperUtil */.Z),
  EM: () => (/* reexport */ WebComponentsUtil/* customElement */.E),
  RF: () => (/* reexport */ ThemeUtil/* initializeTheming */.RF),
  JX: () => (/* reexport */ ThemeUtil/* setColorTheme */.JX),
  ds: () => (/* reexport */ ThemeUtil/* setThemeVariables */.ds)
});

// UNUSED EXPORTS: MathUtil, TransactionUtil

;// ./node_modules/@reown/appkit-ui/dist/esm/src/utils/MathUtil.js
const MathUtil = {
    interpolate(inputRange, outputRange, value) {
        if (inputRange.length !== 2 || outputRange.length !== 2) {
            throw new Error('inputRange and outputRange must be an array of length 2');
        }
        const originalRangeMin = inputRange[0] || 0;
        const originalRangeMax = inputRange[1] || 0;
        const newRangeMin = outputRange[0] || 0;
        const newRangeMax = outputRange[1] || 0;
        if (value < originalRangeMin) {
            return newRangeMin;
        }
        if (value > originalRangeMax) {
            return newRangeMax;
        }
        return (((newRangeMax - newRangeMin) / (originalRangeMax - originalRangeMin)) *
            (value - originalRangeMin) +
            newRangeMin);
    }
};
//# sourceMappingURL=MathUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js
var ThemeUtil = __webpack_require__(926109);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js
var UiHelperUtil = __webpack_require__(163612);
// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js
var dayjs_min = __webpack_require__(974353);
// EXTERNAL MODULE: ./node_modules/dayjs/locale/en.js
var en = __webpack_require__(765826);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/relativeTime.js
var relativeTime = __webpack_require__(606279);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/updateLocale.js
var updateLocale = __webpack_require__(853581);
;// ./node_modules/@reown/appkit-common/dist/esm/src/utils/DateUtil.js




dayjs_min.extend(relativeTime);
dayjs_min.extend(updateLocale);
const localeObject = {
    ...en,
    name: 'en-web3-modal',
    relativeTime: {
        future: 'in %s',
        past: '%s ago',
        s: '%d sec',
        m: '1 min',
        mm: '%d min',
        h: '1 hr',
        hh: '%d hrs',
        d: '1 d',
        dd: '%d d',
        M: '1 mo',
        MM: '%d mo',
        y: '1 yr',
        yy: '%d yr'
    }
};
const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
];
dayjs_min.locale('en-web3-modal', localeObject);
const DateUtil = {
    getMonthNameByIndex(monthIndex) {
        return MONTH_NAMES[monthIndex];
    },
    getYear(date = new Date().toISOString()) {
        return dayjs_min(date).year();
    },
    getRelativeDateFromNow(date) {
        return dayjs_min(date).locale('en-web3-modal').fromNow(true);
    },
    formatDate(date, format = 'DD MMM') {
        return dayjs_min(date).format(format);
    }
};
//# sourceMappingURL=DateUtil.js.map
;// ./node_modules/@reown/appkit-ui/dist/esm/src/utils/TransactionUtil.js


const FLOAT_FIXED_VALUE = 3;
const plusTypes = ['receive', 'deposit', 'borrow', 'claim'];
const minusTypes = ['withdraw', 'repay', 'burn'];
const TransactionUtil = {
    getTransactionGroupTitle(year, month) {
        const currentYear = DateUtil.getYear();
        const monthName = DateUtil.getMonthNameByIndex(month);
        const isCurrentYear = year === currentYear;
        const groupTitle = isCurrentYear ? monthName : `${monthName} ${year}`;
        return groupTitle;
    },
    getTransactionImages(transfers) {
        const [transfer, secondTransfer] = transfers;
        const isAllNFT = Boolean(transfer) && transfers?.every(item => Boolean(item.nft_info));
        const haveMultipleTransfers = transfers?.length > 1;
        const haveTwoTransfers = transfers?.length === 2;
        if (haveTwoTransfers && !isAllNFT) {
            return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
        }
        if (haveMultipleTransfers) {
            return transfers.map(item => this.getTransactionImage(item));
        }
        return [this.getTransactionImage(transfer)];
    },
    getTransactionImage(transfer) {
        return {
            type: TransactionUtil.getTransactionTransferTokenType(transfer),
            url: TransactionUtil.getTransactionImageURL(transfer)
        };
    },
    getTransactionImageURL(transfer) {
        let imageURL = undefined;
        const isNFT = Boolean(transfer?.nft_info);
        const isFungible = Boolean(transfer?.fungible_info);
        if (transfer && isNFT) {
            imageURL = transfer?.nft_info?.content?.preview?.url;
        }
        else if (transfer && isFungible) {
            imageURL = transfer?.fungible_info?.icon?.url;
        }
        return imageURL;
    },
    getTransactionTransferTokenType(transfer) {
        if (transfer?.fungible_info) {
            return 'FUNGIBLE';
        }
        else if (transfer?.nft_info) {
            return 'NFT';
        }
        return undefined;
    },
    getTransactionDescriptions(transaction) {
        const type = transaction?.metadata?.operationType;
        const transfers = transaction?.transfers;
        const haveTransfer = transaction?.transfers?.length > 0;
        const haveMultipleTransfers = transaction?.transfers?.length > 1;
        const isFungible = haveTransfer && transfers?.every(transfer => Boolean(transfer?.fungible_info));
        const [firstTransfer, secondTransfer] = transfers;
        let firstDescription = this.getTransferDescription(firstTransfer);
        let secondDescription = this.getTransferDescription(secondTransfer);
        if (!haveTransfer) {
            const isSendOrReceive = type === 'send' || type === 'receive';
            if (isSendOrReceive && isFungible) {
                firstDescription = UiHelperUtil/* UiHelperUtil */.Z.getTruncateString({
                    string: transaction?.metadata.sentFrom,
                    charsStart: 4,
                    charsEnd: 6,
                    truncate: 'middle'
                });
                secondDescription = UiHelperUtil/* UiHelperUtil */.Z.getTruncateString({
                    string: transaction?.metadata.sentTo,
                    charsStart: 4,
                    charsEnd: 6,
                    truncate: 'middle'
                });
                return [firstDescription, secondDescription];
            }
            return [transaction.metadata.status];
        }
        if (haveMultipleTransfers) {
            return transfers.map(item => this.getTransferDescription(item));
        }
        let prefix = '';
        if (plusTypes.includes(type)) {
            prefix = '+';
        }
        else if (minusTypes.includes(type)) {
            prefix = '-';
        }
        firstDescription = prefix.concat(firstDescription);
        return [firstDescription];
    },
    getTransferDescription(transfer) {
        let description = '';
        if (!transfer) {
            return description;
        }
        if (transfer?.nft_info) {
            description = transfer?.nft_info?.name || '-';
        }
        else if (transfer?.fungible_info) {
            description = this.getFungibleTransferDescription(transfer) || '-';
        }
        return description;
    },
    getFungibleTransferDescription(transfer) {
        if (!transfer) {
            return null;
        }
        const quantity = this.getQuantityFixedValue(transfer?.quantity.numeric);
        const description = [quantity, transfer?.fungible_info?.symbol].join(' ').trim();
        return description;
    },
    getQuantityFixedValue(value) {
        if (!value) {
            return null;
        }
        const parsedValue = parseFloat(value);
        return parsedValue.toFixed(FLOAT_FIXED_VALUE);
    }
};
//# sourceMappingURL=TransactionUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js
var WebComponentsUtil = __webpack_require__(243494);
;// ./node_modules/@reown/appkit-ui/dist/esm/exports/index.js





//# sourceMappingURL=index.js.map

/***/ }),

/***/ 471655:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ AlertController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(923082);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(500026);




// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    message: '',
    variant: 'info',
    open: false
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    open(message, variant) {
        const { debug } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_2__/* .OptionsController */ .H.state;
        const { shortMessage, longMessage } = message;
        if (debug) {
            state.message = shortMessage;
            state.variant = variant;
            state.open = true;
        }
        if (longMessage) {
            // eslint-disable-next-line no-console
            console.error(typeof longMessage === 'function' ? longMessage() : longMessage);
        }
    },
    close() {
        state.open = false;
        state.message = '';
        state.variant = 'info';
    }
};
// Export the controller wrapped with our error boundary
const AlertController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_3__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=AlertController.js.map

/***/ }),

/***/ 500026:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ OptionsController)
});

// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = __webpack_require__(562944);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/OptionsUtil.js


const OptionsUtil = {
    getFeatureValue(key, features) {
        const optionValue = features?.[key];
        if (optionValue === undefined) {
            return ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_FEATURES[key];
        }
        return optionValue;
    },
    filterSocialsByPlatform(socials) {
        if (!socials || !socials.length) {
            return socials;
        }
        if (CoreHelperUtil/* CoreHelperUtil */.w.isTelegram()) {
            if (CoreHelperUtil/* CoreHelperUtil */.w.isIos()) {
                return socials.filter(s => s !== 'google');
            }
            if (CoreHelperUtil/* CoreHelperUtil */.w.isMac()) {
                return socials.filter(s => s !== 'x');
            }
            if (CoreHelperUtil/* CoreHelperUtil */.w.isAndroid()) {
                return socials.filter(s => !['facebook', 'x'].includes(s));
            }
        }
        return socials;
    }
};
//# sourceMappingURL=OptionsUtil.js.map
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js




// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    features: ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_FEATURES,
    projectId: '',
    sdkType: 'appkit',
    sdkVersion: 'html-wagmi-undefined',
    defaultAccountTypes: ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_ACCOUNT_TYPES,
    enableNetworkSwitch: true,
    experimental_preferUniversalLinks: false,
    remoteFeatures: {}
});
// -- Controller ---------------------------------------- //
const OptionsController = {
    state,
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(state, key, callback);
    },
    setOptions(options) {
        Object.assign(state, options);
    },
    setRemoteFeatures(remoteFeatures) {
        if (!remoteFeatures) {
            return;
        }
        const newRemoteFeatures = { ...state.remoteFeatures, ...remoteFeatures };
        state.remoteFeatures = newRemoteFeatures;
        if (state.remoteFeatures?.socials) {
            state.remoteFeatures.socials = OptionsUtil.filterSocialsByPlatform(state.remoteFeatures.socials);
        }
    },
    setFeatures(features) {
        if (!features) {
            return;
        }
        if (!state.features) {
            state.features = ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_FEATURES;
        }
        const newFeatures = { ...state.features, ...features };
        state.features = newFeatures;
    },
    setProjectId(projectId) {
        state.projectId = projectId;
    },
    setCustomRpcUrls(customRpcUrls) {
        state.customRpcUrls = customRpcUrls;
    },
    setAllWallets(allWallets) {
        state.allWallets = allWallets;
    },
    setIncludeWalletIds(includeWalletIds) {
        state.includeWalletIds = includeWalletIds;
    },
    setExcludeWalletIds(excludeWalletIds) {
        state.excludeWalletIds = excludeWalletIds;
    },
    setFeaturedWalletIds(featuredWalletIds) {
        state.featuredWalletIds = featuredWalletIds;
    },
    setTokens(tokens) {
        state.tokens = tokens;
    },
    setTermsConditionsUrl(termsConditionsUrl) {
        state.termsConditionsUrl = termsConditionsUrl;
    },
    setPrivacyPolicyUrl(privacyPolicyUrl) {
        state.privacyPolicyUrl = privacyPolicyUrl;
    },
    setCustomWallets(customWallets) {
        state.customWallets = customWallets;
    },
    setIsSiweEnabled(isSiweEnabled) {
        state.isSiweEnabled = isSiweEnabled;
    },
    setIsUniversalProvider(isUniversalProvider) {
        state.isUniversalProvider = isUniversalProvider;
    },
    setSdkVersion(sdkVersion) {
        state.sdkVersion = sdkVersion;
    },
    setMetadata(metadata) {
        state.metadata = metadata;
    },
    setDisableAppend(disableAppend) {
        state.disableAppend = disableAppend;
    },
    setEIP6963Enabled(enableEIP6963) {
        state.enableEIP6963 = enableEIP6963;
    },
    setDebug(debug) {
        state.debug = debug;
    },
    setEnableWalletConnect(enableWalletConnect) {
        state.enableWalletConnect = enableWalletConnect;
    },
    setEnableWalletGuide(enableWalletGuide) {
        state.enableWalletGuide = enableWalletGuide;
    },
    setEnableAuthLogger(enableAuthLogger) {
        state.enableAuthLogger = enableAuthLogger;
    },
    setEnableWallets(enableWallets) {
        state.enableWallets = enableWallets;
    },
    setPreferUniversalLinks(preferUniversalLinks) {
        state.experimental_preferUniversalLinks = preferUniversalLinks;
    },
    setHasMultipleAddresses(hasMultipleAddresses) {
        state.hasMultipleAddresses = hasMultipleAddresses;
    },
    setSIWX(siwx) {
        state.siwx = siwx;
    },
    setConnectMethodsOrder(connectMethodsOrder) {
        state.features = {
            ...state.features,
            connectMethodsOrder
        };
    },
    setWalletFeaturesOrder(walletFeaturesOrder) {
        state.features = {
            ...state.features,
            walletFeaturesOrder
        };
    },
    setSocialsOrder(socialsOrder) {
        state.remoteFeatures = {
            ...state.remoteFeatures,
            socials: socialsOrder
        };
    },
    setCollapseWallets(collapseWallets) {
        state.features = {
            ...state.features,
            collapseWallets
        };
    },
    setEnableEmbedded(enableEmbedded) {
        state.enableEmbedded = enableEmbedded;
    },
    setAllowUnsupportedChain(allowUnsupportedChain) {
        state.allowUnsupportedChain = allowUnsupportedChain;
    },
    setManualWCControl(manualWCControl) {
        state.manualWCControl = manualWCControl;
    },
    setEnableNetworkSwitch(enableNetworkSwitch) {
        state.enableNetworkSwitch = enableNetworkSwitch;
    },
    setDefaultAccountTypes(defaultAccountType = {}) {
        Object.entries(defaultAccountType).forEach(([namespace, accountType]) => {
            if (accountType) {
                // @ts-expect-error - Keys are validated by the param type
                state.defaultAccountTypes[namespace] = accountType;
            }
        });
    },
    setUniversalProviderConfigOverride(universalProviderConfigOverride) {
        state.universalProviderConfigOverride = universalProviderConfigOverride;
    },
    getUniversalProviderConfigOverride() {
        return state.universalProviderConfigOverride;
    },
    getSnapshot() {
        return (0,vanilla/* snapshot */.P9)(state);
    }
};
//# sourceMappingURL=OptionsController.js.map

/***/ }),

/***/ 527601:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ AssetUtil)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var _controllers_ApiController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188249);
/* harmony import */ var _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(773337);



const namespaceImageIds = {
    // Ethereum
    eip155: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
    // Solana
    solana: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
    // Polkadot
    polkadot: '',
    // Bitcoin
    bip122: '0b4838db-0161-4ffe-022d-532bf03dba00',
    // Cosmos
    cosmos: ''
};
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    networkImagePromises: {}
});
// -- Util ---------------------------------------- //
const AssetUtil = {
    async fetchWalletImage(imageId) {
        if (!imageId) {
            return undefined;
        }
        await _controllers_ApiController_js__WEBPACK_IMPORTED_MODULE_1__/* .ApiController */ .N._fetchWalletImage(imageId);
        return this.getWalletImageById(imageId);
    },
    async fetchNetworkImage(imageId) {
        if (!imageId) {
            return undefined;
        }
        const existingImage = this.getNetworkImageById(imageId);
        // Check if the image already exists
        if (existingImage) {
            return existingImage;
        }
        // Check if the promise is already created
        if (!state.networkImagePromises[imageId]) {
            state.networkImagePromises[imageId] = _controllers_ApiController_js__WEBPACK_IMPORTED_MODULE_1__/* .ApiController */ .N._fetchNetworkImage(imageId);
        }
        await state.networkImagePromises[imageId];
        return this.getNetworkImageById(imageId);
    },
    getWalletImageById(imageId) {
        if (!imageId) {
            return undefined;
        }
        return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.walletImages[imageId];
    },
    getWalletImage(wallet) {
        if (wallet?.image_url) {
            return wallet?.image_url;
        }
        if (wallet?.image_id) {
            return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.walletImages[wallet.image_id];
        }
        return undefined;
    },
    getNetworkImage(network) {
        if (network?.assets?.imageUrl) {
            return network?.assets?.imageUrl;
        }
        if (network?.assets?.imageId) {
            return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.networkImages[network.assets.imageId];
        }
        return undefined;
    },
    getNetworkImageById(imageId) {
        if (!imageId) {
            return undefined;
        }
        return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.networkImages[imageId];
    },
    getConnectorImage(connector) {
        if (connector?.imageUrl) {
            return connector.imageUrl;
        }
        if (connector?.imageId) {
            return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.connectorImages[connector.imageId];
        }
        return undefined;
    },
    getChainImage(chain) {
        return _controllers_AssetController_js__WEBPACK_IMPORTED_MODULE_2__/* .AssetController */ .j.state.networkImages[namespaceImageIds[chain]];
    }
};
//# sourceMappingURL=AssetUtil.js.map

/***/ }),

/***/ 562944:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Db: () => (/* binding */ MELD_PUBLIC_KEY),
/* harmony export */   oU: () => (/* binding */ ConstantsUtil),
/* harmony export */   tM: () => (/* binding */ ONRAMP_PROVIDERS)
/* harmony export */ });

const SECURE_SITE = 
// eslint-disable-next-line @typescript-eslint/prefer-optional-chain
(typeof process !== 'undefined' && typeof process.env !== 'undefined'
    ? process.env['NEXT_PUBLIC_SECURE_SITE_ORIGIN']
    : undefined) || 'https://secure.walletconnect.org';
const ONRAMP_PROVIDERS = [
    {
        label: 'Coinbase',
        name: 'coinbase',
        feeRange: '1-2%',
        url: '',
        supportedChains: ['eip155']
    },
    {
        label: 'Meld.io',
        name: 'meld',
        feeRange: '1-2%',
        url: 'https://meldcrypto.com',
        supportedChains: ['eip155', 'solana']
    }
];
const MELD_PUBLIC_KEY = 'WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU';
const ConstantsUtil = {
    FOUR_MINUTES_MS: 240_000,
    TEN_SEC_MS: 10_000,
    FIVE_SEC_MS: 5_000,
    THREE_SEC_MS: 3_000,
    ONE_SEC_MS: 1_000,
    SECURE_SITE,
    SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
    SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
    RESTRICTED_TIMEZONES: [
        'ASIA/SHANGHAI',
        'ASIA/URUMQI',
        'ASIA/CHONGQING',
        'ASIA/HARBIN',
        'ASIA/KASHGAR',
        'ASIA/MACAU',
        'ASIA/HONG_KONG',
        'ASIA/MACAO',
        'ASIA/BEIJING',
        'ASIA/HARBIN'
    ],
    /**
     * Network name to Coinbase Pay SDK chain name map object
     * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
     */
    WC_COINBASE_PAY_SDK_CHAINS: [
        'ethereum',
        'arbitrum',
        'polygon',
        'berachain',
        'avalanche-c-chain',
        'optimism',
        'celo',
        'base'
    ],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: 'ethereum',
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
        Ethereum: 'ethereum',
        'Arbitrum One': 'arbitrum',
        Polygon: 'polygon',
        Berachain: 'berachain',
        Avalanche: 'avalanche-c-chain',
        'OP Mainnet': 'optimism',
        Celo: 'celo',
        Base: 'base'
    },
    WC_COINBASE_ONRAMP_APP_ID: 'bf18c88d-495a-463b-b249-0b9d3656cf5e',
    SWAP_SUGGESTED_TOKENS: [
        'ETH',
        'UNI',
        '1INCH',
        'AAVE',
        'SOL',
        'ADA',
        'AVAX',
        'DOT',
        'LINK',
        'NITRO',
        'GAIA',
        'MILK',
        'TRX',
        'NEAR',
        'GNO',
        'WBTC',
        'DAI',
        'WETH',
        'USDC',
        'USDT',
        'ARB',
        'BAL',
        'BICO',
        'CRV',
        'ENS',
        'MATIC',
        'OP'
    ],
    SWAP_POPULAR_TOKENS: [
        'ETH',
        'UNI',
        '1INCH',
        'AAVE',
        'SOL',
        'ADA',
        'AVAX',
        'DOT',
        'LINK',
        'NITRO',
        'GAIA',
        'MILK',
        'TRX',
        'NEAR',
        'GNO',
        'WBTC',
        'DAI',
        'WETH',
        'USDC',
        'USDT',
        'ARB',
        'BAL',
        'BICO',
        'CRV',
        'ENS',
        'MATIC',
        'OP',
        'METAL',
        'DAI',
        'CHAMP',
        'WOLF',
        'SALE',
        'BAL',
        'BUSD',
        'MUST',
        'BTCpx',
        'ROUTE',
        'HEX',
        'WELT',
        'amDAI',
        'VSQ',
        'VISION',
        'AURUM',
        'pSP',
        'SNX',
        'VC',
        'LINK',
        'CHP',
        'amUSDT',
        'SPHERE',
        'FOX',
        'GIDDY',
        'GFC',
        'OMEN',
        'OX_OLD',
        'DE',
        'WNT'
    ],
    BALANCE_SUPPORTED_CHAINS: ['eip155', 'solana'],
    SWAP_SUPPORTED_NETWORKS: [
        // Ethereum'
        'eip155:1',
        // Arbitrum One'
        'eip155:42161',
        // Optimism'
        'eip155:10',
        // ZKSync Era'
        'eip155:324',
        // Base'
        'eip155:8453',
        // BNB Smart Chain'
        'eip155:56',
        // Polygon'
        'eip155:137',
        // Gnosis'
        'eip155:100',
        // Avalanche'
        'eip155:43114',
        // Fantom'
        'eip155:250',
        // Klaytn'
        'eip155:8217',
        // Aurora
        'eip155:1313161554'
    ],
    NAMES_SUPPORTED_CHAIN_NAMESPACES: ['eip155'],
    ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ['eip155', 'solana'],
    ACTIVITY_ENABLED_CHAIN_NAMESPACES: ['eip155'],
    NATIVE_TOKEN_ADDRESS: {
        eip155: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
        solana: 'So11111111111111111111111111111111111111111',
        polkadot: '0x',
        bip122: '0x',
        cosmos: '0x'
    },
    CONVERT_SLIPPAGE_TOLERANCE: 1,
    CONNECT_LABELS: {
        MOBILE: 'Open and continue in the wallet app',
        WEB: 'Open and continue in the wallet app'
    },
    SEND_SUPPORTED_NAMESPACES: ['eip155', 'solana'],
    DEFAULT_REMOTE_FEATURES: {
        swaps: ['1inch'],
        onramp: ['coinbase', 'meld'],
        email: true,
        socials: [
            'google',
            'x',
            'discord',
            'farcaster',
            'github',
            'apple',
            'facebook'
        ],
        activity: true,
        reownBranding: true
    },
    DEFAULT_REMOTE_FEATURES_DISABLED: {
        email: false,
        socials: false,
        swaps: false,
        onramp: false,
        activity: false,
        reownBranding: false
    },
    DEFAULT_FEATURES: {
        receive: true,
        send: true,
        emailShowWallets: true,
        connectorTypeOrder: [
            'walletConnect',
            'recent',
            'injected',
            'featured',
            'custom',
            'external',
            'recommended'
        ],
        analytics: true,
        allWallets: true,
        legalCheckbox: false,
        smartSessions: false,
        collapseWallets: false,
        walletFeaturesOrder: ['onramp', 'swaps', 'receive', 'send'],
        connectMethodsOrder: undefined,
        pay: false
    },
    DEFAULT_SOCIALS: [
        'google',
        'x',
        'farcaster',
        'discord',
        'apple',
        'github',
        'facebook'
    ],
    DEFAULT_ACCOUNT_TYPES: {
        bip122: 'payment',
        eip155: 'smartAccount',
        polkadot: 'eoa',
        solana: 'eoa'
    },
    ADAPTER_TYPES: {
        UNIVERSAL: 'universal',
        SOLANA: 'solana',
        WAGMI: 'wagmi',
        ETHERS: 'ethers',
        ETHERS5: 'ethers5',
        BITCOIN: 'bitcoin'
    }
};
//# sourceMappingURL=ConstantsUtil.js.map

/***/ }),

/***/ 568996:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ThemeController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(323096);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(923082);
/* harmony import */ var _ConnectorController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(236010);




// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    themeMode: 'dark',
    themeVariables: {},
    w3mThemeVariables: undefined
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state, () => callback(state));
    },
    setThemeMode(themeMode) {
        state.themeMode = themeMode;
        try {
            const authConnector = _ConnectorController_js__WEBPACK_IMPORTED_MODULE_1__/* .ConnectorController */ .a.getAuthConnector();
            if (authConnector) {
                const themeVariables = controller.getSnapshot().themeVariables;
                authConnector.provider.syncTheme({
                    themeMode,
                    themeVariables,
                    w3mThemeVariables: (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .getW3mThemeVariables */ .o)(themeVariables, themeMode)
                });
            }
        }
        catch {
            // eslint-disable-next-line no-console
            console.info('Unable to sync theme to auth connector');
        }
    },
    setThemeVariables(themeVariables) {
        state.themeVariables = { ...state.themeVariables, ...themeVariables };
        try {
            const authConnector = _ConnectorController_js__WEBPACK_IMPORTED_MODULE_1__/* .ConnectorController */ .a.getAuthConnector();
            if (authConnector) {
                const themeVariablesSnapshot = controller.getSnapshot().themeVariables;
                authConnector.provider.syncTheme({
                    themeVariables: themeVariablesSnapshot,
                    w3mThemeVariables: (0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_2__/* .getW3mThemeVariables */ .o)(state.themeVariables, state.themeMode)
                });
            }
        }
        catch {
            // eslint-disable-next-line no-console
            console.info('Unable to sync theme to auth connector');
        }
    },
    getSnapshot() {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .snapshot */ .P9)(state);
    }
};
// Export the controller wrapped with our error boundary
const ThemeController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_3__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=ThemeController.js.map

/***/ }),

/***/ 606279:
/***/ (function(module) {

!function(r,e){ true?module.exports=e():0}(this,(function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));

/***/ }),

/***/ 627987:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  x: () => (/* binding */ ConnectionController)
});

// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js
var StorageUtil = __webpack_require__(127508);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js + 1 modules
var withErrorBoundary = __webpack_require__(923082);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var AccountController = __webpack_require__(863450);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var ChainController = __webpack_require__(806056);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var ConnectorController = __webpack_require__(236010);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var EventsController = __webpack_require__(390184);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js + 1 modules
var ModalController = __webpack_require__(91111);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var RouterController = __webpack_require__(778508);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js
var W3mFrameConstants = __webpack_require__(110152);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var BlockchainApiController = __webpack_require__(775595);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js + 1 modules
var OptionsController = __webpack_require__(500026);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var SnackController = __webpack_require__(121871);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js









// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    transactions: [],
    coinbaseTransactions: {},
    transactionsByYear: {},
    lastNetworkInView: undefined,
    loading: false,
    empty: false,
    next: undefined
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(state, () => callback(state));
    },
    setLastNetworkInView(lastNetworkInView) {
        state.lastNetworkInView = lastNetworkInView;
    },
    async fetchTransactions(accountAddress, onramp) {
        if (!accountAddress) {
            throw new Error("Transactions can't be fetched without an accountAddress");
        }
        state.loading = true;
        try {
            const response = await BlockchainApiController/* BlockchainApiController */.T.fetchTransactions({
                account: accountAddress,
                cursor: state.next,
                onramp,
                // Coinbase transaction history state updates require the latest data
                cache: onramp === 'coinbase' ? 'no-cache' : undefined,
                chainId: ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId
            });
            const nonSpamTransactions = TransactionsController.filterSpamTransactions(response.data);
            const sameChainTransactions = TransactionsController.filterByConnectedChain(nonSpamTransactions);
            const filteredTransactions = [...state.transactions, ...sameChainTransactions];
            state.loading = false;
            if (onramp === 'coinbase') {
                state.coinbaseTransactions = TransactionsController.groupTransactionsByYearAndMonth(state.coinbaseTransactions, response.data);
            }
            else {
                state.transactions = filteredTransactions;
                state.transactionsByYear = TransactionsController.groupTransactionsByYearAndMonth(state.transactionsByYear, sameChainTransactions);
            }
            state.empty = filteredTransactions.length === 0;
            state.next = response.next ? response.next : undefined;
        }
        catch (error) {
            const activeChainNamespace = ChainController/* ChainController */.W.state.activeChain;
            EventsController/* EventsController */.E.sendEvent({
                type: 'track',
                event: 'ERROR_FETCH_TRANSACTIONS',
                properties: {
                    address: accountAddress,
                    projectId: OptionsController/* OptionsController */.H.state.projectId,
                    cursor: state.next,
                    isSmartAccount: AccountController/* AccountController */.U.state.preferredAccountTypes?.[activeChainNamespace] ===
                        W3mFrameConstants/* W3mFrameRpcConstants */.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
                }
            });
            SnackController/* SnackController */.P.showError('Failed to fetch transactions');
            state.loading = false;
            state.empty = true;
            state.next = undefined;
        }
    },
    groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
        const grouped = transactionsMap;
        transactions.forEach(transaction => {
            const year = new Date(transaction.metadata.minedAt).getFullYear();
            const month = new Date(transaction.metadata.minedAt).getMonth();
            const yearTransactions = grouped[year] ?? {};
            const monthTransactions = yearTransactions[month] ?? [];
            // If there's a transaction with the same id, remove the old one
            const newMonthTransactions = monthTransactions.filter(tx => tx.id !== transaction.id);
            grouped[year] = {
                ...yearTransactions,
                [month]: [...newMonthTransactions, transaction].sort((a, b) => new Date(b.metadata.minedAt).getTime() - new Date(a.metadata.minedAt).getTime())
            };
        });
        return grouped;
    },
    filterSpamTransactions(transactions) {
        return transactions.filter(transaction => {
            const isAllSpam = transaction.transfers.every(transfer => transfer.nft_info?.flags.is_spam === true);
            return !isAllSpam;
        });
    },
    filterByConnectedChain(transactions) {
        const chainId = ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId;
        const filteredTransactions = transactions.filter(transaction => transaction.metadata.chain === chainId);
        return filteredTransactions;
    },
    clearCursor() {
        state.next = undefined;
    },
    resetTransactions() {
        state.transactions = [];
        state.transactionsByYear = {};
        state.lastNetworkInView = undefined;
        state.loading = false;
        state.empty = false;
        state.next = undefined;
    }
};
// Export the controller wrapped with our error boundary
const TransactionsController = (0,withErrorBoundary/* withErrorBoundary */.X)(controller, 'API_ERROR');
//# sourceMappingURL=TransactionsController.js.map
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js
/* eslint-disable no-console */













// -- State --------------------------------------------- //
const ConnectionController_state = (0,vanilla/* proxy */.BX)({
    connections: new Map(),
    wcError: false,
    buffering: false,
    status: 'disconnected'
});
// eslint-disable-next-line init-declarations
let wcConnectionPromise;
// -- Controller ---------------------------------------- //
const ConnectionController_controller = {
    state: ConnectionController_state,
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(ConnectionController_state, key, callback);
    },
    _getClient() {
        return ConnectionController_state._client;
    },
    setClient(client) {
        ConnectionController_state._client = (0,vanilla/* ref */.KR)(client);
    },
    async connectWalletConnect() {
        if (CoreHelperUtil/* CoreHelperUtil */.w.isTelegram() || (CoreHelperUtil/* CoreHelperUtil */.w.isSafari() && CoreHelperUtil/* CoreHelperUtil */.w.isIos())) {
            if (wcConnectionPromise) {
                await wcConnectionPromise;
                wcConnectionPromise = undefined;
                return;
            }
            if (!CoreHelperUtil/* CoreHelperUtil */.w.isPairingExpired(ConnectionController_state?.wcPairingExpiry)) {
                const link = ConnectionController_state.wcUri;
                ConnectionController_state.wcUri = link;
                return;
            }
            wcConnectionPromise = ConnectionController._getClient()
                ?.connectWalletConnect?.()
                .catch(() => undefined);
            ConnectionController.state.status = 'connecting';
            await wcConnectionPromise;
            wcConnectionPromise = undefined;
            ConnectionController_state.wcPairingExpiry = undefined;
            ConnectionController.state.status = 'connected';
        }
        else {
            await ConnectionController._getClient()?.connectWalletConnect?.();
        }
    },
    async connectExternal(options, chain, setChain = true) {
        await ConnectionController._getClient()?.connectExternal?.(options);
        if (setChain) {
            ChainController/* ChainController */.W.setActiveNamespace(chain);
        }
    },
    async reconnectExternal(options) {
        await ConnectionController._getClient()?.reconnectExternal?.(options);
        const namespace = options.chain || ChainController/* ChainController */.W.state.activeChain;
        if (namespace) {
            ConnectorController/* ConnectorController */.a.setConnectorId(options.id, namespace);
        }
    },
    async setPreferredAccountType(accountType, namespace) {
        ModalController/* ModalController */.W.setLoading(true, ChainController/* ChainController */.W.state.activeChain);
        const authConnector = ConnectorController/* ConnectorController */.a.getAuthConnector();
        if (!authConnector) {
            return;
        }
        AccountController/* AccountController */.U.setPreferredAccountType(accountType, namespace);
        await authConnector.provider.setPreferredAccount(accountType);
        StorageUtil/* StorageUtil */.i.setPreferredAccountTypes(AccountController/* AccountController */.U.state.preferredAccountTypes ?? { [namespace]: accountType });
        await ConnectionController.reconnectExternal(authConnector);
        ModalController/* ModalController */.W.setLoading(false, ChainController/* ChainController */.W.state.activeChain);
        EventsController/* EventsController */.E.sendEvent({
            type: 'track',
            event: 'SET_PREFERRED_ACCOUNT_TYPE',
            properties: {
                accountType,
                network: ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId || ''
            }
        });
    },
    async signMessage(message) {
        return ConnectionController._getClient()?.signMessage(message);
    },
    parseUnits(value, decimals) {
        return ConnectionController._getClient()?.parseUnits(value, decimals);
    },
    formatUnits(value, decimals) {
        return ConnectionController._getClient()?.formatUnits(value, decimals);
    },
    async sendTransaction(args) {
        return ConnectionController._getClient()?.sendTransaction(args);
    },
    async getCapabilities(params) {
        return ConnectionController._getClient()?.getCapabilities(params);
    },
    async grantPermissions(params) {
        return ConnectionController._getClient()?.grantPermissions(params);
    },
    async walletGetAssets(params) {
        return ConnectionController._getClient()?.walletGetAssets(params) ?? {};
    },
    async estimateGas(args) {
        return ConnectionController._getClient()?.estimateGas(args);
    },
    async writeContract(args) {
        return ConnectionController._getClient()?.writeContract(args);
    },
    async getEnsAddress(value) {
        return ConnectionController._getClient()?.getEnsAddress(value);
    },
    async getEnsAvatar(value) {
        return ConnectionController._getClient()?.getEnsAvatar(value);
    },
    checkInstalled(ids) {
        return ConnectionController._getClient()?.checkInstalled?.(ids) || false;
    },
    resetWcConnection() {
        ConnectionController_state.wcUri = undefined;
        ConnectionController_state.wcPairingExpiry = undefined;
        ConnectionController_state.wcLinking = undefined;
        ConnectionController_state.recentWallet = undefined;
        ConnectionController_state.status = 'disconnected';
        TransactionsController.resetTransactions();
        StorageUtil/* StorageUtil */.i.deleteWalletConnectDeepLink();
    },
    resetUri() {
        ConnectionController_state.wcUri = undefined;
        ConnectionController_state.wcPairingExpiry = undefined;
        wcConnectionPromise = undefined;
    },
    finalizeWcConnection() {
        const { wcLinking, recentWallet } = ConnectionController.state;
        if (wcLinking) {
            StorageUtil/* StorageUtil */.i.setWalletConnectDeepLink(wcLinking);
        }
        if (recentWallet) {
            StorageUtil/* StorageUtil */.i.setAppKitRecent(recentWallet);
        }
        EventsController/* EventsController */.E.sendEvent({
            type: 'track',
            event: 'CONNECT_SUCCESS',
            properties: {
                method: wcLinking ? 'mobile' : 'qrcode',
                name: RouterController/* RouterController */.I.state.data?.wallet?.name || 'Unknown'
            }
        });
    },
    setWcBasic(wcBasic) {
        ConnectionController_state.wcBasic = wcBasic;
    },
    setUri(uri) {
        ConnectionController_state.wcUri = uri;
        ConnectionController_state.wcPairingExpiry = CoreHelperUtil/* CoreHelperUtil */.w.getPairingExpiry();
    },
    setWcLinking(wcLinking) {
        ConnectionController_state.wcLinking = wcLinking;
    },
    setWcError(wcError) {
        ConnectionController_state.wcError = wcError;
        ConnectionController_state.buffering = false;
    },
    setRecentWallet(wallet) {
        ConnectionController_state.recentWallet = wallet;
    },
    setBuffering(buffering) {
        ConnectionController_state.buffering = buffering;
    },
    setStatus(status) {
        ConnectionController_state.status = status;
    },
    async disconnect(namespace) {
        try {
            await ConnectionController._getClient()?.disconnect(namespace);
        }
        catch (error) {
            throw new withErrorBoundary/* AppKitError */.A('Failed to disconnect', 'INTERNAL_SDK_ERROR', error);
        }
    },
    setConnections(connections, chainNamespace) {
        ConnectionController_state.connections.set(chainNamespace, connections);
    },
    switchAccount({ connection, address, namespace }) {
        const connectedConnectorId = ConnectorController/* ConnectorController */.a.state.activeConnectorIds[namespace];
        const isConnectorConnected = connectedConnectorId === connection.connectorId;
        if (isConnectorConnected) {
            const currentNetwork = ChainController/* ChainController */.W.state.activeCaipNetwork;
            if (currentNetwork) {
                const caipAddress = `${namespace}:${currentNetwork.id}:${address}`;
                AccountController/* AccountController */.U.setCaipAddress(caipAddress, namespace);
            }
            else {
                console.warn(`No current network found for namespace "${namespace}"`);
            }
        }
        else {
            const connector = ConnectorController/* ConnectorController */.a.getConnector(connection.connectorId);
            if (connector) {
                ConnectionController.connectExternal(connector, namespace);
            }
            else {
                console.warn(`No connector found for namespace "${namespace}"`);
            }
        }
    }
};
// Export the controller wrapped with our error boundary
const ConnectionController = (0,withErrorBoundary/* withErrorBoundary */.X)(ConnectionController_controller);
//# sourceMappingURL=ConnectionController.js.map

/***/ }),

/***/ 665042:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ WalletUtil)
/* harmony export */ });
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(500026);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(236010);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(127508);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(226742);
/* harmony import */ var _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(188249);
/* harmony import */ var _reown_appkit_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(335306);
/* harmony import */ var _ConnectorUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56092);
/* harmony import */ var _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(841482);




const WalletUtil = {
    filterOutDuplicatesByRDNS(wallets) {
        const connectors = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__/* .OptionsController */ .H.state.enableEIP6963
            ? _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ConnectorController */ .a.state.connectors
            : [];
        const recent = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.getRecentWallets();
        const connectorRDNSs = connectors
            .map(connector => connector.info?.rdns)
            .filter(Boolean);
        const recentRDNSs = recent.map(wallet => wallet.rdns).filter(Boolean);
        const allRDNSs = connectorRDNSs.concat(recentRDNSs);
        if (allRDNSs.includes('io.metamask.mobile') && _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_5__/* .CoreHelperUtil */ .w.isMobile()) {
            const index = allRDNSs.indexOf('io.metamask.mobile');
            allRDNSs[index] = 'io.metamask';
        }
        const filtered = wallets.filter(wallet => !allRDNSs.includes(String(wallet?.rdns)));
        return filtered;
    },
    filterOutDuplicatesByIds(wallets) {
        const connectors = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ConnectorController */ .a.state.connectors.filter(connector => connector.type === 'ANNOUNCED' || connector.type === 'INJECTED');
        const recent = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.getRecentWallets();
        const connectorIds = connectors.map(connector => connector.explorerId);
        const recentIds = recent.map(wallet => wallet.id);
        const allIds = connectorIds.concat(recentIds);
        const filtered = wallets.filter(wallet => !allIds.includes(wallet?.id));
        return filtered;
    },
    filterOutDuplicateWallets(wallets) {
        const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
        const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
        return uniqueWallets;
    },
    markWalletsAsInstalled(wallets) {
        const { connectors } = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ConnectorController */ .a.state;
        const { featuredWalletIds } = _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__/* .OptionsController */ .H.state;
        const installedWalletRdnsMap = connectors
            .filter(connector => connector.type === 'ANNOUNCED')
            .reduce((rdnsMap, connector) => {
            if (!connector.info?.rdns) {
                return rdnsMap;
            }
            rdnsMap[connector.info.rdns] = true;
            return rdnsMap;
        }, {});
        const walletsWithInstallationStatus = wallets.map(wallet => ({
            ...wallet,
            installed: Boolean(wallet.rdns) && Boolean(installedWalletRdnsMap[wallet.rdns ?? ''])
        }));
        const sortedWallets = walletsWithInstallationStatus.sort((walletA, walletB) => {
            const installationComparison = Number(walletB.installed) - Number(walletA.installed);
            if (installationComparison !== 0) {
                return installationComparison;
            }
            if (featuredWalletIds?.length) {
                const walletAFeaturedIndex = featuredWalletIds.indexOf(walletA.id);
                const walletBFeaturedIndex = featuredWalletIds.indexOf(walletB.id);
                if (walletAFeaturedIndex !== -1 && walletBFeaturedIndex !== -1) {
                    return walletAFeaturedIndex - walletBFeaturedIndex;
                }
                if (walletAFeaturedIndex !== -1) {
                    return -1;
                }
                if (walletBFeaturedIndex !== -1) {
                    return 1;
                }
            }
            return 0;
        });
        return sortedWallets;
    },
    getConnectOrderMethod(_features, _connectors) {
        const connectMethodOrder = _features?.connectMethodsOrder || _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_2__/* .OptionsController */ .H.state.features?.connectMethodsOrder;
        const connectors = _connectors || _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_3__/* .ConnectorController */ .a.state.connectors;
        if (connectMethodOrder) {
            return connectMethodOrder;
        }
        const { injected, announced } = _ConnectorUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectorUtil */ .g.getConnectorsByType(connectors, _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__/* .ApiController */ .N.state.recommended, _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__/* .ApiController */ .N.state.featured);
        const shownInjected = injected.filter(_ConnectorUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectorUtil */ .g.showConnector);
        const shownAnnounced = announced.filter(_ConnectorUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectorUtil */ .g.showConnector);
        if (shownInjected.length || shownAnnounced.length) {
            return ['wallet', 'email', 'social'];
        }
        return _ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_1__/* .ConstantsUtil */ .o.DEFAULT_CONNECT_METHOD_ORDER;
    },
    isExcluded(wallet) {
        const isRDNSExcluded = Boolean(wallet.rdns) && _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__/* .ApiController */ .N.state.excludedWallets.some(w => w.rdns === wallet.rdns);
        const isNameExcluded = Boolean(wallet.name) &&
            _reown_appkit_controllers__WEBPACK_IMPORTED_MODULE_6__/* .ApiController */ .N.state.excludedWallets.some(w => _reown_appkit_utils__WEBPACK_IMPORTED_MODULE_7__/* .HelpersUtil */ .y.isLowerCaseMatch(w.name, wallet.name));
        return isRDNSExcluded || isNameExcluded;
    }
};
//# sourceMappingURL=WalletUtil.js.map

/***/ }),

/***/ 669510:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ ConstantsUtil)
/* harmony export */ });
const ConstantsUtil = {
    METMASK_CONNECTOR_NAME: 'MetaMask',
    TRUST_CONNECTOR_NAME: 'Trust Wallet',
    SOLFLARE_CONNECTOR_NAME: 'Solflare',
    PHANTOM_CONNECTOR_NAME: 'Phantom',
    COIN98_CONNECTOR_NAME: 'Coin98',
    MAGIC_EDEN_CONNECTOR_NAME: 'Magic Eden',
    BACKPACK_CONNECTOR_NAME: 'Backpack',
    BITGET_CONNECTOR_NAME: 'Bitget Wallet',
    FRONTIER_CONNECTOR_NAME: 'Frontier',
    XVERSE_CONNECTOR_NAME: 'Xverse Wallet',
    LEATHER_CONNECTOR_NAME: 'Leather',
    EIP155: 'eip155',
    ADD_CHAIN_METHOD: 'wallet_addEthereumChain',
    EIP6963_ANNOUNCE_EVENT: 'eip6963:announceProvider',
    EIP6963_REQUEST_EVENT: 'eip6963:requestProvider',
    CONNECTOR_RDNS_MAP: {
        coinbaseWallet: 'com.coinbase.wallet',
        coinbaseWalletSDK: 'com.coinbase.wallet'
    },
    CONNECTOR_TYPE_EXTERNAL: 'EXTERNAL',
    CONNECTOR_TYPE_WALLET_CONNECT: 'WALLET_CONNECT',
    CONNECTOR_TYPE_INJECTED: 'INJECTED',
    CONNECTOR_TYPE_ANNOUNCED: 'ANNOUNCED',
    CONNECTOR_TYPE_AUTH: 'AUTH',
    CONNECTOR_TYPE_MULTI_CHAIN: 'MULTI_CHAIN',
    CONNECTOR_TYPE_W3M_AUTH: 'ID_AUTH'
};
//# sourceMappingURL=ConstantsUtil.js.map

/***/ }),

/***/ 682419:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BX: () => (/* binding */ proxy),
  KR: () => (/* binding */ ref),
  P9: () => (/* binding */ snapshot),
  B1: () => (/* binding */ subscribe)
});

// UNUSED EXPORTS: getVersion, unstable_buildProxyFunction

;// ./node_modules/proxy-compare/dist/index.modern.js
const e=Symbol(),t=Symbol(),r="a",n="w";let o=(e,t)=>new Proxy(e,t);const s=Object.getPrototypeOf,c=new WeakMap,l=e=>e&&(c.has(e)?c.get(e):s(e)===Object.prototype||s(e)===Array.prototype),f=e=>"object"==typeof e&&null!==e,i=e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(s(e),t)},u=e=>e[t]||e,a=(s,c,f,p)=>{if(!l(s))return s;let g=p&&p.get(s);if(!g){const e=u(s);g=(e=>Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.configurable&&!e.writable))(e)?[e,i(e)]:[e],null==p||p.set(s,g)}const[y,h]=g;let w=f&&f.get(y);return w&&w[1].f===!!h||(w=((o,s)=>{const c={f:s};let l=!1;const f=(e,t)=>{if(!l){let s=c[r].get(o);if(s||(s={},c[r].set(o,s)),e===n)s[n]=!0;else{let r=s[e];r||(r=new Set,s[e]=r),r.add(t)}}},i={get:(e,n)=>n===t?o:(f("k",n),a(Reflect.get(e,n),c[r],c.c,c.t)),has:(t,n)=>n===e?(l=!0,c[r].delete(o),!0):(f("h",n),Reflect.has(t,n)),getOwnPropertyDescriptor:(e,t)=>(f("o",t),Reflect.getOwnPropertyDescriptor(e,t)),ownKeys:e=>(f(n),Reflect.ownKeys(e))};return s&&(i.set=i.deleteProperty=()=>!1),[i,c]})(y,!!h),w[1].p=o(h||y,w[0]),f&&f.set(y,w)),w[1][r]=c,w[1].c=f,w[1].t=p,w[1].p},p=(e,t,r,o,s=Object.is)=>{if(s(e,t))return!1;if(!f(e)||!f(t))return!0;const c=r.get(u(e));if(!c)return!0;if(o){const r=o.get(e);if(r&&r.n===t)return r.g;o.set(e,{n:t,g:!1})}let l=null;try{for(const r of c.h||[])if(l=Reflect.has(e,r)!==Reflect.has(t,r),l)return l;if(!0===c[n]){if(l=((e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])})(e,t),l)return l}else for(const r of c.o||[])if(l=!!Reflect.getOwnPropertyDescriptor(e,r)!=!!Reflect.getOwnPropertyDescriptor(t,r),l)return l;for(const n of c.k||[])if(l=p(e[n],t[n],r,o,s),l)return l;return null===l&&(l=!0),l}finally{o&&o.set(e,{n:t,g:l})}},g=t=>!!l(t)&&e in t,y=e=>l(e)&&e[t]||null,h=(e,t=!0)=>{c.set(e,t)},w=(e,t,r)=>{const o=[],s=new WeakSet,c=(e,l)=>{if(s.has(e))return;f(e)&&s.add(e);const i=f(e)&&t.get(u(e));if(i){var a,p;if(null==(a=i.h)||a.forEach(e=>{const t=`:has(${String(e)})`;o.push(l?[...l,t]:[t])}),!0===i[n]){const e=":ownKeys";o.push(l?[...l,e]:[e])}else{var g;null==(g=i.o)||g.forEach(e=>{const t=`:hasOwn(${String(e)})`;o.push(l?[...l,t]:[t])})}null==(p=i.k)||p.forEach(t=>{r&&!("value"in(Object.getOwnPropertyDescriptor(e,t)||{}))||c(e[t],l?[...l,t]:[t])})}else l&&o.push(l)};return c(e),o},O=e=>{o=e};
//# sourceMappingURL=index.modern.mjs.map

;// ./node_modules/valtio/esm/vanilla.mjs


const isObject = (x) => typeof x === "object" && x !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value = Reflect.get(target, key);
    const { enumerable } = Reflect.getOwnPropertyDescriptor(
      target,
      key
    );
    const desc = {
      value,
      enumerable,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (( false ? 0 : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (( false ? 0 : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v) => {
          value.status = "fulfilled";
          value.value = v;
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          value.status = "rejected";
          value.reason = e;
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if ("value" in desc) {
      proxyObject[key] = initialObject[key];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function getVersion(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  return proxyState == null ? void 0 : proxyState[1]();
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (( false ? 0 : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (( false ? 0 : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
const unstable_buildProxyFunction = (/* unused pure expression or super */ null && (buildProxyFunction));




/***/ }),

/***/ 698467:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ PublicStateController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);


// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    loading: false,
    open: false,
    selectedNetworkId: undefined,
    activeChain: undefined,
    initialized: false
});
// -- Controller ---------------------------------------- //
const PublicStateController = {
    state,
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state, () => callback(state));
    },
    subscribeOpen(callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, 'open', callback);
    },
    set(newState) {
        Object.assign(state, { ...state, ...newState });
    }
};
//# sourceMappingURL=PublicStateController.js.map

/***/ }),

/***/ 725574:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ CUSTOM_DEEPLINK_WALLETS),
/* harmony export */   W: () => (/* binding */ MobileWalletUtil)
/* harmony export */ });
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(824376);

/*
 * Exclude wallets that do not support relay connections but have custom deeplink mechanisms
 * Excludes:
 * - Phantom
 * - Coinbase
 */
const CUSTOM_DEEPLINK_WALLETS = {
    PHANTOM: {
        id: 'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
        url: 'https://phantom.app'
    },
    SOLFLARE: {
        id: '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
        url: 'https://solflare.com'
    },
    COINBASE: {
        id: 'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
        url: 'https://go.cb-w.com'
    }
};
const MobileWalletUtil = {
    /**
     * Handles mobile wallet redirection for wallets that have Universal Links and doesn't support WalletConnect Deep Links.
     *
     * @param {string} id - The id of the wallet.
     * @param {ChainNamespace} namespace - The namespace of the chain.
     */
    handleMobileDeeplinkRedirect(id, namespace) {
        /**
         * Universal Links requires explicit user interaction to open the wallet app.
         * Previously we've been calling this with the life-cycle methods in the Solana clients by listening the SELECT_WALLET event of EventController.
         * But this breaks the UL functionality for some wallets like Phantom.
         */
        const href = window.location.href;
        const encodedHref = encodeURIComponent(href);
        if (id === CUSTOM_DEEPLINK_WALLETS.PHANTOM.id && !('phantom' in window)) {
            const protocol = href.startsWith('https') ? 'https' : 'http';
            const host = href.split('/')[2];
            const encodedRef = encodeURIComponent(`${protocol}://${host}`);
            window.location.href = `${CUSTOM_DEEPLINK_WALLETS.PHANTOM.url}/ul/browse/${encodedHref}?ref=${encodedRef}`;
        }
        if (id === CUSTOM_DEEPLINK_WALLETS.SOLFLARE.id && !('solflare' in window)) {
            window.location.href = `${CUSTOM_DEEPLINK_WALLETS.SOLFLARE.url}/ul/v1/browse/${encodedHref}?ref=${encodedHref}`;
        }
        if (namespace === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_0__/* .ConstantsUtil */ .o.CHAIN.SOLANA) {
            if (id === CUSTOM_DEEPLINK_WALLETS.COINBASE.id && !('coinbaseSolana' in window)) {
                window.location.href = `${CUSTOM_DEEPLINK_WALLETS.COINBASE.url}/dapp?cb_url=${encodedHref}`;
            }
        }
    }
};
//# sourceMappingURL=MobileWallet.js.map

/***/ }),

/***/ 740512:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  mN: () => (/* binding */ g),
  AH: () => (/* reexport */ i),
  W3: () => (/* binding */ b),
  Ec: () => (/* binding */ m),
  iz: () => (/* reexport */ r)
});

// UNUSED EXPORTS: CSSResult, adoptStyles, getCompatibleStyle, supportsAdoptingStyleSheets

;// ./node_modules/@lit-labs/ssr-dom-shim/lib/element-internals.js
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Map of ARIAMixin properties to attributes
 */
const ariaMixinAttributes = {
    ariaAtomic: 'aria-atomic',
    ariaAutoComplete: 'aria-autocomplete',
    ariaBrailleLabel: 'aria-braillelabel',
    ariaBrailleRoleDescription: 'aria-brailleroledescription',
    ariaBusy: 'aria-busy',
    ariaChecked: 'aria-checked',
    ariaColCount: 'aria-colcount',
    ariaColIndex: 'aria-colindex',
    ariaColSpan: 'aria-colspan',
    ariaCurrent: 'aria-current',
    ariaDescription: 'aria-description',
    ariaDisabled: 'aria-disabled',
    ariaExpanded: 'aria-expanded',
    ariaHasPopup: 'aria-haspopup',
    ariaHidden: 'aria-hidden',
    ariaInvalid: 'aria-invalid',
    ariaKeyShortcuts: 'aria-keyshortcuts',
    ariaLabel: 'aria-label',
    ariaLevel: 'aria-level',
    ariaLive: 'aria-live',
    ariaModal: 'aria-modal',
    ariaMultiLine: 'aria-multiline',
    ariaMultiSelectable: 'aria-multiselectable',
    ariaOrientation: 'aria-orientation',
    ariaPlaceholder: 'aria-placeholder',
    ariaPosInSet: 'aria-posinset',
    ariaPressed: 'aria-pressed',
    ariaReadOnly: 'aria-readonly',
    ariaRequired: 'aria-required',
    ariaRoleDescription: 'aria-roledescription',
    ariaRowCount: 'aria-rowcount',
    ariaRowIndex: 'aria-rowindex',
    ariaRowSpan: 'aria-rowspan',
    ariaSelected: 'aria-selected',
    ariaSetSize: 'aria-setsize',
    ariaSort: 'aria-sort',
    ariaValueMax: 'aria-valuemax',
    ariaValueMin: 'aria-valuemin',
    ariaValueNow: 'aria-valuenow',
    ariaValueText: 'aria-valuetext',
    role: 'role',
};
// Shim the global element internals object
// Methods should be fine as noops and properties can generally
// be while on the server.
const ElementInternalsShim = class ElementInternals {
    get shadowRoot() {
        // Grab the shadow root instance from the Element shim
        // to ensure that the shadow root is always available
        // to the internals instance even if the mode is 'closed'
        return this.__host
            .__shadowRoot;
    }
    constructor(_host) {
        this.ariaAtomic = '';
        this.ariaAutoComplete = '';
        this.ariaBrailleLabel = '';
        this.ariaBrailleRoleDescription = '';
        this.ariaBusy = '';
        this.ariaChecked = '';
        this.ariaColCount = '';
        this.ariaColIndex = '';
        this.ariaColSpan = '';
        this.ariaCurrent = '';
        this.ariaDescription = '';
        this.ariaDisabled = '';
        this.ariaExpanded = '';
        this.ariaHasPopup = '';
        this.ariaHidden = '';
        this.ariaInvalid = '';
        this.ariaKeyShortcuts = '';
        this.ariaLabel = '';
        this.ariaLevel = '';
        this.ariaLive = '';
        this.ariaModal = '';
        this.ariaMultiLine = '';
        this.ariaMultiSelectable = '';
        this.ariaOrientation = '';
        this.ariaPlaceholder = '';
        this.ariaPosInSet = '';
        this.ariaPressed = '';
        this.ariaReadOnly = '';
        this.ariaRequired = '';
        this.ariaRoleDescription = '';
        this.ariaRowCount = '';
        this.ariaRowIndex = '';
        this.ariaRowSpan = '';
        this.ariaSelected = '';
        this.ariaSetSize = '';
        this.ariaSort = '';
        this.ariaValueMax = '';
        this.ariaValueMin = '';
        this.ariaValueNow = '';
        this.ariaValueText = '';
        this.role = '';
        this.form = null;
        this.labels = [];
        this.states = new Set();
        this.validationMessage = '';
        this.validity = {};
        this.willValidate = true;
        this.__host = _host;
    }
    checkValidity() {
        // TODO(augustjk) Consider actually implementing logic.
        // See https://github.com/lit/lit/issues/3740
        console.warn('`ElementInternals.checkValidity()` was called on the server.' +
            'This method always returns true.');
        return true;
    }
    reportValidity() {
        return true;
    }
    setFormValue() { }
    setValidity() { }
};
const ElementInternalsShimWithRealType = (/* unused pure expression or super */ null && (ElementInternalsShim));

const HYDRATE_INTERNALS_ATTR_PREFIX = 'hydrate-internals-';
//# sourceMappingURL=element-internals.js.map
;// ./node_modules/@lit-labs/ssr-dom-shim/lib/events.js
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Event_cancelable, _Event_bubbles, _Event_composed, _Event_defaultPrevented, _Event_timestamp, _Event_propagationStopped, _Event_type, _Event_target, _Event_isBeingDispatched, _a, _CustomEvent_detail, _b;
const isCaptureEventListener = (options) => (typeof options === 'boolean' ? options : options?.capture ?? false);
// Event phases
const NONE = 0;
const CAPTURING_PHASE = 1;
const AT_TARGET = 2;
const BUBBLING_PHASE = 3;
// Shim the global EventTarget object
const EventTargetShim = class EventTarget {
    constructor() {
        this.__eventListeners = new Map();
        this.__captureEventListeners = new Map();
    }
    addEventListener(type, callback, options) {
        if (callback === undefined || callback === null) {
            return;
        }
        const eventListenersMap = isCaptureEventListener(options)
            ? this.__captureEventListeners
            : this.__eventListeners;
        let eventListeners = eventListenersMap.get(type);
        if (eventListeners === undefined) {
            eventListeners = new Map();
            eventListenersMap.set(type, eventListeners);
        }
        else if (eventListeners.has(callback)) {
            return;
        }
        const normalizedOptions = typeof options === 'object' && options ? options : {};
        normalizedOptions.signal?.addEventListener('abort', () => this.removeEventListener(type, callback, options));
        eventListeners.set(callback, normalizedOptions ?? {});
    }
    removeEventListener(type, callback, options) {
        if (callback === undefined || callback === null) {
            return;
        }
        const eventListenersMap = isCaptureEventListener(options)
            ? this.__captureEventListeners
            : this.__eventListeners;
        const eventListeners = eventListenersMap.get(type);
        if (eventListeners !== undefined) {
            eventListeners.delete(callback);
            if (!eventListeners.size) {
                eventListenersMap.delete(type);
            }
        }
    }
    dispatchEvent(event) {
        const composedPath = [this];
        let parent = this.__eventTargetParent;
        if (event.composed) {
            while (parent) {
                composedPath.push(parent);
                parent = parent.__eventTargetParent;
            }
        }
        else {
            // If the event is not composed and the event was dispatched inside
            // shadow DOM, we need to stop before the host of the shadow DOM.
            while (parent && parent !== this.__host) {
                composedPath.push(parent);
                parent = parent.__eventTargetParent;
            }
        }
        // We need to patch various properties that would either be empty or wrong
        // in this scenario.
        let stopPropagation = false;
        let stopImmediatePropagation = false;
        let eventPhase = NONE;
        let target = null;
        let tmpTarget = null;
        let currentTarget = null;
        const originalStopPropagation = event.stopPropagation;
        const originalStopImmediatePropagation = event.stopImmediatePropagation;
        Object.defineProperties(event, {
            target: {
                get() {
                    return target ?? tmpTarget;
                },
                ...enumerableProperty,
            },
            srcElement: {
                get() {
                    return event.target;
                },
                ...enumerableProperty,
            },
            currentTarget: {
                get() {
                    return currentTarget;
                },
                ...enumerableProperty,
            },
            eventPhase: {
                get() {
                    return eventPhase;
                },
                ...enumerableProperty,
            },
            composedPath: {
                value: () => composedPath,
                ...enumerableProperty,
            },
            stopPropagation: {
                value: () => {
                    stopPropagation = true;
                    originalStopPropagation.call(event);
                },
                ...enumerableProperty,
            },
            stopImmediatePropagation: {
                value: () => {
                    stopImmediatePropagation = true;
                    originalStopImmediatePropagation.call(event);
                },
                ...enumerableProperty,
            },
        });
        // An event handler can either be a function, an object with a handleEvent
        // method or null. This function takes care to call the event handler
        // correctly.
        const invokeEventListener = (listener, options, eventListenerMap) => {
            if (typeof listener === 'function') {
                listener(event);
            }
            else if (typeof listener?.handleEvent === 'function') {
                listener.handleEvent(event);
            }
            if (options.once) {
                eventListenerMap.delete(listener);
            }
        };
        // When an event is finished being dispatched, which can be after the event
        // tree has been traversed or stopPropagation/stopImmediatePropagation has
        // been called. Once that is the case, the currentTarget and eventPhase
        // need to be reset and a value, representing whether the event has not
        // been prevented, needs to be returned.
        const finishDispatch = () => {
            currentTarget = null;
            eventPhase = NONE;
            return !event.defaultPrevented;
        };
        // An event starts with the capture order, where it starts from the top.
        // This is done even if bubbles is set to false, which is the default.
        const captureEventPath = composedPath.slice().reverse();
        // If the event target, which dispatches the event, is either in the light DOM
        // or the event is not composed, the target is always itself. If that is not
        // the case, the target needs to be retargeted: https://dom.spec.whatwg.org/#retarget
        target = !this.__host || !event.composed ? this : null;
        const retarget = (eventTargets) => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            tmpTarget = this;
            while (tmpTarget.__host && eventTargets.includes(tmpTarget.__host)) {
                tmpTarget = tmpTarget.__host;
            }
        };
        for (const eventTarget of captureEventPath) {
            if (!target && (!tmpTarget || tmpTarget === eventTarget.__host)) {
                retarget(captureEventPath.slice(captureEventPath.indexOf(eventTarget)));
            }
            currentTarget = eventTarget;
            eventPhase = eventTarget === event.target ? AT_TARGET : CAPTURING_PHASE;
            const captureEventListeners = eventTarget.__captureEventListeners.get(event.type);
            if (captureEventListeners) {
                for (const [listener, options] of captureEventListeners) {
                    invokeEventListener(listener, options, captureEventListeners);
                    if (stopImmediatePropagation) {
                        // Event.stopImmediatePropagation() stops any following invocation
                        // of an event handler even on the same event target.
                        return finishDispatch();
                    }
                }
            }
            if (stopPropagation) {
                // Event.stopPropagation() stops any following invocation
                // of an event handler for any following event targets.
                return finishDispatch();
            }
        }
        const bubbleEventPath = event.bubbles ? composedPath : [this];
        tmpTarget = null;
        for (const eventTarget of bubbleEventPath) {
            if (!target &&
                (!tmpTarget || eventTarget === tmpTarget.__host)) {
                retarget(bubbleEventPath.slice(0, bubbleEventPath.indexOf(eventTarget) + 1));
            }
            currentTarget = eventTarget;
            eventPhase = eventTarget === event.target ? AT_TARGET : BUBBLING_PHASE;
            const captureEventListeners = eventTarget.__eventListeners.get(event.type);
            if (captureEventListeners) {
                for (const [listener, options] of captureEventListeners) {
                    invokeEventListener(listener, options, captureEventListeners);
                    if (stopImmediatePropagation) {
                        // Event.stopImmediatePropagation() stops any following invocation
                        // of an event handler even on the same event target.
                        return finishDispatch();
                    }
                }
            }
            if (stopPropagation) {
                // Event.stopPropagation() stops any following invocation
                // of an event handler for any following event targets.
                return finishDispatch();
            }
        }
        return finishDispatch();
    }
};
const EventTargetShimWithRealType = EventTargetShim;

const enumerableProperty = { __proto__: null };
enumerableProperty.enumerable = true;
Object.freeze(enumerableProperty);
// TODO: Remove this when we remove support for vm modules (--experimental-vm-modules).
const EventShim = (_a = class Event {
        constructor(type, options = {}) {
            _Event_cancelable.set(this, false);
            _Event_bubbles.set(this, false);
            _Event_composed.set(this, false);
            _Event_defaultPrevented.set(this, false);
            _Event_timestamp.set(this, Date.now());
            _Event_propagationStopped.set(this, false);
            _Event_type.set(this, void 0);
            _Event_target.set(this, void 0);
            _Event_isBeingDispatched.set(this, void 0);
            this.NONE = NONE;
            this.CAPTURING_PHASE = CAPTURING_PHASE;
            this.AT_TARGET = AT_TARGET;
            this.BUBBLING_PHASE = BUBBLING_PHASE;
            if (arguments.length === 0)
                throw new Error(`The type argument must be specified`);
            if (typeof options !== 'object' || !options) {
                throw new Error(`The "options" argument must be an object`);
            }
            const { bubbles, cancelable, composed } = options;
            __classPrivateFieldSet(this, _Event_cancelable, !!cancelable, "f");
            __classPrivateFieldSet(this, _Event_bubbles, !!bubbles, "f");
            __classPrivateFieldSet(this, _Event_composed, !!composed, "f");
            __classPrivateFieldSet(this, _Event_type, `${type}`, "f");
            __classPrivateFieldSet(this, _Event_target, null, "f");
            __classPrivateFieldSet(this, _Event_isBeingDispatched, false, "f");
        }
        initEvent(_type, _bubbles, _cancelable) {
            throw new Error('Method not implemented.');
        }
        stopImmediatePropagation() {
            this.stopPropagation();
        }
        preventDefault() {
            __classPrivateFieldSet(this, _Event_defaultPrevented, true, "f");
        }
        get target() {
            return __classPrivateFieldGet(this, _Event_target, "f");
        }
        get currentTarget() {
            return __classPrivateFieldGet(this, _Event_target, "f");
        }
        get srcElement() {
            return __classPrivateFieldGet(this, _Event_target, "f");
        }
        get type() {
            return __classPrivateFieldGet(this, _Event_type, "f");
        }
        get cancelable() {
            return __classPrivateFieldGet(this, _Event_cancelable, "f");
        }
        get defaultPrevented() {
            return __classPrivateFieldGet(this, _Event_cancelable, "f") && __classPrivateFieldGet(this, _Event_defaultPrevented, "f");
        }
        get timeStamp() {
            return __classPrivateFieldGet(this, _Event_timestamp, "f");
        }
        composedPath() {
            return __classPrivateFieldGet(this, _Event_isBeingDispatched, "f") ? [__classPrivateFieldGet(this, _Event_target, "f")] : [];
        }
        get returnValue() {
            return !__classPrivateFieldGet(this, _Event_cancelable, "f") || !__classPrivateFieldGet(this, _Event_defaultPrevented, "f");
        }
        get bubbles() {
            return __classPrivateFieldGet(this, _Event_bubbles, "f");
        }
        get composed() {
            return __classPrivateFieldGet(this, _Event_composed, "f");
        }
        get eventPhase() {
            return __classPrivateFieldGet(this, _Event_isBeingDispatched, "f") ? _a.AT_TARGET : _a.NONE;
        }
        get cancelBubble() {
            return __classPrivateFieldGet(this, _Event_propagationStopped, "f");
        }
        set cancelBubble(value) {
            if (value) {
                __classPrivateFieldSet(this, _Event_propagationStopped, true, "f");
            }
        }
        stopPropagation() {
            __classPrivateFieldSet(this, _Event_propagationStopped, true, "f");
        }
        get isTrusted() {
            return false;
        }
    },
    _Event_cancelable = new WeakMap(),
    _Event_bubbles = new WeakMap(),
    _Event_composed = new WeakMap(),
    _Event_defaultPrevented = new WeakMap(),
    _Event_timestamp = new WeakMap(),
    _Event_propagationStopped = new WeakMap(),
    _Event_type = new WeakMap(),
    _Event_target = new WeakMap(),
    _Event_isBeingDispatched = new WeakMap(),
    _a.NONE = NONE,
    _a.CAPTURING_PHASE = CAPTURING_PHASE,
    _a.AT_TARGET = AT_TARGET,
    _a.BUBBLING_PHASE = BUBBLING_PHASE,
    _a);
Object.defineProperties(EventShim.prototype, {
    initEvent: enumerableProperty,
    stopImmediatePropagation: enumerableProperty,
    preventDefault: enumerableProperty,
    target: enumerableProperty,
    currentTarget: enumerableProperty,
    srcElement: enumerableProperty,
    type: enumerableProperty,
    cancelable: enumerableProperty,
    defaultPrevented: enumerableProperty,
    timeStamp: enumerableProperty,
    composedPath: enumerableProperty,
    returnValue: enumerableProperty,
    bubbles: enumerableProperty,
    composed: enumerableProperty,
    eventPhase: enumerableProperty,
    cancelBubble: enumerableProperty,
    stopPropagation: enumerableProperty,
    isTrusted: enumerableProperty,
});
// TODO: Remove this when we remove support for vm modules (--experimental-vm-modules).
const CustomEventShim = (_b = class CustomEvent extends EventShim {
        constructor(type, options = {}) {
            super(type, options);
            _CustomEvent_detail.set(this, void 0);
            __classPrivateFieldSet(this, _CustomEvent_detail, options?.detail ?? null, "f");
        }
        initCustomEvent(_type, _bubbles, _cancelable, _detail) {
            throw new Error('Method not implemented.');
        }
        get detail() {
            return __classPrivateFieldGet(this, _CustomEvent_detail, "f");
        }
    },
    _CustomEvent_detail = new WeakMap(),
    _b);
Object.defineProperties(CustomEventShim.prototype, {
    detail: enumerableProperty,
});
const EventShimWithRealType = EventShim;
const CustomEventShimWithRealType = CustomEventShim;

//# sourceMappingURL=events.js.map
;// ./node_modules/@lit-labs/ssr-dom-shim/index.js
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */




// In an empty Node.js vm, we need to patch the global context.
// TODO: Remove these globalThis assignments when we remove support
// for vm modules (--experimental-vm-modules).
globalThis.Event ??= EventShimWithRealType;
globalThis.CustomEvent ??= CustomEventShimWithRealType;
const attributes = new WeakMap();
const attributesForElement = (element) => {
    let attrs = attributes.get(element);
    if (attrs === undefined) {
        attributes.set(element, (attrs = new Map()));
    }
    return attrs;
};
// The typings around the exports below are a little funky:
//
// 1. We want the `name` of the shim classes to match the real ones at runtime,
//    hence e.g. `class Element`.
// 2. We can't shadow the global types with a simple class declaration, because
//    then we can't reference the global types for casting, hence e.g.
//    `const ElementShim = class Element`.
// 3. We want to export the classes typed as the real ones, hence e.g.
//    `const ElementShimWithRealType = ElementShim as object as typeof Element;`.
// 4. We want the exported names to match the real ones, hence e.g.
//    `export {ElementShimWithRealType as Element}`.
const ElementShim = class Element extends EventTargetShimWithRealType {
    constructor() {
        super(...arguments);
        this.__shadowRootMode = null;
        this.__shadowRoot = null;
        this.__internals = null;
    }
    get attributes() {
        return Array.from(attributesForElement(this)).map(([name, value]) => ({
            name,
            value,
        }));
    }
    get shadowRoot() {
        if (this.__shadowRootMode === 'closed') {
            return null;
        }
        return this.__shadowRoot;
    }
    get localName() {
        return this.constructor.__localName;
    }
    get tagName() {
        return this.localName?.toUpperCase();
    }
    setAttribute(name, value) {
        // Emulate browser behavior that silently casts all values to string. E.g.
        // `42` becomes `"42"` and `{}` becomes `"[object Object]""`.
        attributesForElement(this).set(name, String(value));
    }
    removeAttribute(name) {
        attributesForElement(this).delete(name);
    }
    toggleAttribute(name, force) {
        // Steps reference https://dom.spec.whatwg.org/#dom-element-toggleattribute
        if (this.hasAttribute(name)) {
            // Step 5
            if (force === undefined || !force) {
                this.removeAttribute(name);
                return false;
            }
        }
        else {
            // Step 4
            if (force === undefined || force) {
                // Step 4.1
                this.setAttribute(name, '');
                return true;
            }
            else {
                // Step 4.2
                return false;
            }
        }
        // Step 6
        return true;
    }
    hasAttribute(name) {
        return attributesForElement(this).has(name);
    }
    attachShadow(init) {
        const shadowRoot = { host: this };
        this.__shadowRootMode = init.mode;
        if (init && init.mode === 'open') {
            this.__shadowRoot = shadowRoot;
        }
        return shadowRoot;
    }
    attachInternals() {
        if (this.__internals !== null) {
            throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': ` +
                `ElementInternals for the specified element was already attached.`);
        }
        const internals = new ElementInternalsShim(this);
        this.__internals = internals;
        return internals;
    }
    getAttribute(name) {
        const value = attributesForElement(this).get(name);
        return value ?? null;
    }
};
const ElementShimWithRealType = (/* unused pure expression or super */ null && (ElementShim));

const HTMLElementShim = class HTMLElement extends ElementShim {
};
const HTMLElementShimWithRealType = HTMLElementShim;

// For convenience, we provide a global instance of a HTMLElement as an event
// target. This facilitates registering global event handlers
// (e.g. for @lit/context ContextProvider).
// We use this in in the SSR render function.
// Note, this is a bespoke element and not simply `document` or `window` since
// user code relies on these being undefined in the server environment.
globalThis.litServerRoot ??= Object.defineProperty(new HTMLElementShimWithRealType(), 'localName', {
    // Patch localName (and tagName) to return a unique name.
    get() {
        return 'lit-server-root';
    },
});
const CustomElementRegistryShim = class CustomElementRegistry {
    constructor() {
        this.__definitions = new Map();
    }
    define(name, ctor) {
        if (this.__definitions.has(name)) {
            if (false) // removed by dead control flow
{}
            else {
                throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': ` +
                    `the name "${name}" has already been used with this registry`);
            }
        }
        // Provide tagName and localName for the component.
        ctor.__localName = name;
        this.__definitions.set(name, {
            ctor,
            // Note it's important we read `observedAttributes` in case it is a getter
            // with side-effects, as is the case in Lit, where it triggers class
            // finalization.
            //
            // TODO(aomarks) To be spec compliant, we should also capture the
            // registration-time lifecycle methods like `connectedCallback`. For them
            // to be actually accessible to e.g. the Lit SSR element renderer, though,
            // we'd need to introduce a new API for accessing them (since `get` only
            // returns the constructor).
            observedAttributes: ctor.observedAttributes ?? [],
        });
    }
    get(name) {
        const definition = this.__definitions.get(name);
        return definition?.ctor;
    }
};
const CustomElementRegistryShimWithRealType = CustomElementRegistryShim;

const customElements = new CustomElementRegistryShimWithRealType();
//# sourceMappingURL=index.js.map
;// ./node_modules/@lit/reactive-element/node/css-tag.js
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t=globalThis,e=t.ShadowRoot&&(void 0===t.ShadyCSS||t.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s=Symbol(),o=new WeakMap;class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e}get styleSheet(){let t=this.o;const s=this.t;if(e&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o.set(s,t))}return t}toString(){return this.cssText}}const r=t=>new n("string"==typeof t?t:t+"",void 0,s),i=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n(o,t,s)},S=(s,o)=>{if(e)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o)}},c=e||void 0===t.CSSStyleSheet?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r(e)})(t):t;
//# sourceMappingURL=css-tag.js.map

;// ./node_modules/@lit/reactive-element/node/reactive-element.js
const{is:h,defineProperty:reactive_element_r,getOwnPropertyDescriptor:reactive_element_o,getOwnPropertyNames:reactive_element_n,getOwnPropertySymbols:a,getPrototypeOf:reactive_element_c}=Object,l=globalThis;l.customElements??=customElements;const p=l.trustedTypes,d=p?p.emptyScript:"",u=l.reactiveElementPolyfillSupport,f=(t,s)=>t,b={toAttribute(t,s){switch(s){case Boolean:t=t?d:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t)}catch(t){i=null}}return i}},m=(t,s)=>!h(t,s),y={attribute:!0,type:String,converter:b,reflect:!1,useDefault:!1,hasChanged:m};Symbol.metadata??=Symbol("metadata"),l.litPropertyMetadata??=new WeakMap;class g extends(globalThis.HTMLElement??HTMLElementShimWithRealType){static addInitializer(t){this._$Ei(),(this.l??=[]).push(t)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y){if(s.state&&(s.attribute=!1),this._$Ei(),this.prototype.hasOwnProperty(t)&&((s=Object.create(s)).wrapped=!0),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),e=this.getPropertyDescriptor(t,i,s);void 0!==e&&reactive_element_r(this.prototype,t,e)}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=reactive_element_o(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t}};return{get:e,set(s){const r=e?.call(this);h?.call(this,s),this.requestUpdate(t,r,i)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y}static _$Ei(){if(this.hasOwnProperty(f("elementProperties")))return;const t=reactive_element_c(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties)}static finalize(){if(this.hasOwnProperty(f("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(f("properties"))){const t=this.properties,s=[...reactive_element_n(t),...a(t)];for(const i of s)this.createProperty(i,t[i])}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i)}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(t){const s=[];if(Array.isArray(t)){const e=new Set(t.flat(1/0).reverse());for(const t of e)s.unshift(c(t))}else void 0!==t&&s.push(c(t));return s}static _$Eu(t,s){const i=s.attribute;return!1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)))}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.()}removeController(t){this._$EO?.delete(t)}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t)}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()))}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()))}attributeChangedCallback(t,s,i){this._$AK(t,i)}_$ET(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const h=(void 0!==i.converter?.toAttribute?i.converter:b).toAttribute(s,i.type);this._$Em=t,null==h?this.removeAttribute(e):this.setAttribute(e,h),this._$Em=null}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),h="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:b;this._$Em=e,this[e]=h.fromAttribute(s,t.type)??this._$Ej?.get(e)??null,this._$Em=null}}requestUpdate(t,s,i){if(void 0!==t){const e=this.constructor,h=this[t];if(i??=e.getPropertyOptions(t),!((i.hasChanged??m)(h,s)||i.useDefault&&i.reflect&&h===this._$Ej?.get(t)&&!this.hasAttribute(e._$Eu(t,i))))return;this.C(t,s,i)}!1===this.isUpdatePending&&(this._$ES=this._$EP())}C(t,s,{useDefault:i,reflect:e,wrapped:h},r){i&&!(this._$Ej??=new Map).has(t)&&(this._$Ej.set(t,r??s??this[t]),!0!==h||void 0!==r)||(this._$AL.has(t)||(this.hasUpdated||i||(s=void 0),this._$AL.set(t,s)),!0===e&&this._$Em!==t&&(this._$Eq??=new Set).add(t))}async _$EP(){this.isUpdatePending=!0;try{await this._$ES}catch(t){Promise.reject(t)}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t){const{wrapped:t}=i,e=this[s];!0!==t||this._$AL.has(s)||void 0===e||this.C(s,void 0,i,e)}}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EM()}catch(s){throw t=!1,this._$EM(),s}t&&this._$AE(s)}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}_$EM(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return!0}update(t){this._$Eq&&=this._$Eq.forEach((t=>this._$ET(t,this[t]))),this._$EM()}updated(t){}firstUpdated(t){}}g.elementStyles=[],g.shadowRootOptions={mode:"open"},g[f("elementProperties")]=new Map,g[f("finalized")]=new Map,u?.({ReactiveElement:g}),(l.reactiveElementVersions??=[]).push("2.1.0");
//# sourceMappingURL=reactive-element.js.map


/***/ }),

/***/ 765826:
/***/ (function(module) {

!function(e,n){ true?module.exports=n():0}(this,(function(){"use strict";return{name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(e){var n=["th","st","nd","rd"],t=e%100;return"["+e+(n[(t-20)%10]||n[t]||n[0])+"]"}}}));

/***/ }),

/***/ 773337:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ AssetController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(923082);



// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    walletImages: {},
    networkImages: {},
    chainImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {}
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribeNetworkImages(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state.networkImages, () => callback(state.networkImages));
    },
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state, () => callback(state));
    },
    setWalletImage(key, value) {
        state.walletImages[key] = value;
    },
    setNetworkImage(key, value) {
        state.networkImages[key] = value;
    },
    setChainImage(key, value) {
        state.chainImages[key] = value;
    },
    setConnectorImage(key, value) {
        state.connectorImages = { ...state.connectorImages, [key]: value };
    },
    setTokenImage(key, value) {
        state.tokenImages[key] = value;
    },
    setCurrencyImage(key, value) {
        state.currencyImages[key] = value;
    }
};
// Export the controller wrapped with our error boundary
const AssetController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_2__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=AssetController.js.map

/***/ }),

/***/ 775595:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ BlockchainApiController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(682419);
/* harmony import */ var _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(562944);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226742);
/* harmony import */ var _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25905);
/* harmony import */ var _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(127508);
/* harmony import */ var _AccountController_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(863450);
/* harmony import */ var _ChainController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(806056);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(500026);
/* harmony import */ var _SnackController_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(121871);









const DEFAULT_OPTIONS = {
    purchaseCurrencies: [
        {
            id: '2b92315d-eab7-5bef-84fa-089a131333f5',
            name: 'USD Coin',
            symbol: 'USDC',
            networks: [
                {
                    name: 'ethereum-mainnet',
                    display_name: 'Ethereum',
                    chain_id: '1',
                    contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
                },
                {
                    name: 'polygon-mainnet',
                    display_name: 'Polygon',
                    chain_id: '137',
                    contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
                }
            ]
        },
        {
            id: '2b92315d-eab7-5bef-84fa-089a131333f5',
            name: 'Ether',
            symbol: 'ETH',
            networks: [
                {
                    name: 'ethereum-mainnet',
                    display_name: 'Ethereum',
                    chain_id: '1',
                    contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
                },
                {
                    name: 'polygon-mainnet',
                    display_name: 'Polygon',
                    chain_id: '137',
                    contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
                }
            ]
        }
    ],
    paymentCurrencies: [
        {
            id: 'USD',
            payment_method_limits: [
                {
                    id: 'card',
                    min: '10.00',
                    max: '7500.00'
                },
                {
                    id: 'ach_bank_account',
                    min: '10.00',
                    max: '25000.00'
                }
            ]
        },
        {
            id: 'EUR',
            payment_method_limits: [
                {
                    id: 'card',
                    min: '10.00',
                    max: '7500.00'
                },
                {
                    id: 'ach_bank_account',
                    min: '10.00',
                    max: '25000.00'
                }
            ]
        }
    ]
};
// -- Helpers ------------------------------------------- //
const baseUrl = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.getBlockchainApiUrl();
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_1__/* .proxy */ .BX)({
    clientId: null,
    api: new _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .FetchUtil */ .Z({ baseUrl, clientId: null }),
    supportedChains: { http: [], ws: [] }
});
// -- Controller ---------------------------------------- //
const BlockchainApiController = {
    state,
    async get(request) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const projectId = _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId;
        const params = {
            ...(request.params || {}),
            st,
            sv,
            projectId
        };
        return state.api.get({
            ...request,
            params
        });
    },
    getSdkProperties() {
        const { sdkType, sdkVersion } = _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state;
        return {
            st: sdkType || 'unknown',
            sv: sdkVersion || 'unknown'
        };
    },
    async isNetworkSupported(networkId) {
        if (!networkId) {
            return false;
        }
        try {
            if (!state.supportedChains.http.length) {
                await BlockchainApiController.getSupportedNetworks();
            }
        }
        catch (e) {
            return false;
        }
        return state.supportedChains.http.includes(networkId);
    },
    async getSupportedNetworks() {
        try {
            const supportedChains = await BlockchainApiController.get({
                path: 'v1/supported-chains'
            });
            state.supportedChains = supportedChains;
            return supportedChains;
        }
        catch {
            return state.supportedChains;
        }
    },
    async fetchIdentity({ address, caipNetworkId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(caipNetworkId);
        if (!isSupported) {
            return { avatar: '', name: '' };
        }
        const identityCache = _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.getIdentityFromCacheForAddress(address);
        if (identityCache) {
            return identityCache;
        }
        const result = await BlockchainApiController.get({
            path: `/v1/identity/${address}`,
            params: {
                sender: _ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipAddress
                    ? _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_0__/* .CoreHelperUtil */ .w.getPlainAddress(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipAddress)
                    : undefined
            }
        });
        _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.updateIdentityCache({
            address,
            identity: result,
            timestamp: Date.now()
        });
        return result;
    },
    async fetchTransactions({ account, cursor, onramp, signal, cache, chainId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { data: [], next: undefined };
        }
        return BlockchainApiController.get({
            path: `/v1/account/${account}/history`,
            params: {
                cursor,
                onramp,
                chainId
            },
            signal,
            cache
        });
    },
    async fetchSwapQuote({ amount, userAddress, from, to, gasPrice }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { quotes: [] };
        }
        return BlockchainApiController.get({
            path: `/v1/convert/quotes`,
            headers: {
                'Content-Type': 'application/json'
            },
            params: {
                amount,
                userAddress,
                from,
                to,
                gasPrice
            }
        });
    },
    async fetchSwapTokens({ chainId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { tokens: [] };
        }
        return BlockchainApiController.get({
            path: `/v1/convert/tokens`,
            params: { chainId }
        });
    },
    async fetchTokenPrice({ addresses }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { fungibles: [] };
        }
        return state.api.post({
            path: '/v1/fungible/price',
            body: {
                currency: 'usd',
                addresses,
                projectId: _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId
            },
            headers: {
                'Content-Type': 'application/json'
            }
        });
    },
    async fetchSwapAllowance({ tokenAddress, userAddress }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { allowance: '0' };
        }
        return BlockchainApiController.get({
            path: `/v1/convert/allowance`,
            params: {
                tokenAddress,
                userAddress
            },
            headers: {
                'Content-Type': 'application/json'
            }
        });
    },
    async fetchGasPrice({ chainId }) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            throw new Error('Network not supported for Gas Price');
        }
        return BlockchainApiController.get({
            path: `/v1/convert/gas-price`,
            headers: {
                'Content-Type': 'application/json'
            },
            params: {
                chainId,
                st,
                sv
            }
        });
    },
    async generateSwapCalldata({ amount, from, to, userAddress, disableEstimate }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            throw new Error('Network not supported for Swaps');
        }
        return state.api.post({
            path: '/v1/convert/build-transaction',
            headers: {
                'Content-Type': 'application/json'
            },
            body: {
                amount,
                eip155: {
                    slippage: _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_6__/* .ConstantsUtil */ .oU.CONVERT_SLIPPAGE_TOLERANCE
                },
                projectId: _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId,
                from,
                to,
                userAddress,
                disableEstimate
            }
        });
    },
    async generateApproveCalldata({ from, to, userAddress }) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            throw new Error('Network not supported for Swaps');
        }
        return BlockchainApiController.get({
            path: `/v1/convert/build-approve`,
            headers: {
                'Content-Type': 'application/json'
            },
            params: {
                userAddress,
                from,
                to,
                st,
                sv
            }
        });
    },
    async getBalance(address, chainId, forceUpdate) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            _SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.showError('Token Balance Unavailable');
            return { balances: [] };
        }
        const caipAddress = `${chainId}:${address}`;
        const cachedBalance = _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.getBalanceCacheForCaipAddress(caipAddress);
        if (cachedBalance) {
            return cachedBalance;
        }
        const balance = await BlockchainApiController.get({
            path: `/v1/account/${address}/balance`,
            params: {
                currency: 'usd',
                chainId,
                forceUpdate,
                st,
                sv
            }
        });
        _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_4__/* .StorageUtil */ .i.updateBalanceCache({
            caipAddress,
            balance,
            timestamp: Date.now()
        });
        return balance;
    },
    async lookupEnsName(name) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { addresses: {}, attributes: [] };
        }
        return BlockchainApiController.get({
            path: `/v1/profile/account/${name}`,
            params: { apiVersion: '2' }
        });
    },
    async reverseLookupEnsName({ address }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return [];
        }
        return BlockchainApiController.get({
            path: `/v1/profile/reverse/${address}`,
            params: {
                sender: _AccountController_js__WEBPACK_IMPORTED_MODULE_8__/* .AccountController */ .U.state.address,
                apiVersion: '2'
            }
        });
    },
    async getEnsNameSuggestions(name) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { suggestions: [] };
        }
        return BlockchainApiController.get({
            path: `/v1/profile/suggestions/${name}`,
            params: { zone: 'reown.id' }
        });
    },
    async registerEnsName({ coinType, address, message, signature }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { success: false };
        }
        return state.api.post({
            path: `/v1/profile/account`,
            body: { coin_type: coinType, address, message, signature },
            headers: {
                'Content-Type': 'application/json'
            }
        });
    },
    async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return '';
        }
        const response = await state.api.post({
            path: `/v1/generators/onrampurl`,
            params: {
                projectId: _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId
            },
            body: {
                destinationWallets,
                defaultNetwork,
                partnerUserId,
                defaultExperience: 'buy',
                presetCryptoAmount: purchaseAmount,
                presetFiatAmount: paymentAmount
            }
        });
        return response.url;
    },
    async getOnrampOptions() {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { paymentCurrencies: [], purchaseCurrencies: [] };
        }
        try {
            const response = await BlockchainApiController.get({
                path: `/v1/onramp/options`
            });
            return response;
        }
        catch (e) {
            return DEFAULT_OPTIONS;
        }
    },
    async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
        try {
            const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
            if (!isSupported) {
                return null;
            }
            const response = await state.api.post({
                path: `/v1/onramp/quote`,
                params: {
                    projectId: _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId
                },
                body: {
                    purchaseCurrency,
                    paymentCurrency,
                    amount,
                    network
                }
            });
            return response;
        }
        catch (e) {
            // Mocking response as 1:1 until endpoint is ready
            return {
                coinbaseFee: { amount, currency: paymentCurrency.id },
                networkFee: { amount, currency: paymentCurrency.id },
                paymentSubtotal: { amount, currency: paymentCurrency.id },
                paymentTotal: { amount, currency: paymentCurrency.id },
                purchaseAmount: { amount, currency: paymentCurrency.id },
                quoteId: 'mocked-quote-id'
            };
        }
    },
    async getSmartSessions(caipAddress) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return [];
        }
        return BlockchainApiController.get({
            path: `/v1/sessions/${caipAddress}`
        });
    },
    async revokeSmartSession(address, pci, signature) {
        const isSupported = await BlockchainApiController.isNetworkSupported(_ChainController_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
            return { success: false };
        }
        return state.api.post({
            path: `/v1/sessions/${address}/revoke`,
            params: {
                projectId: _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.projectId
            },
            body: {
                pci,
                signature
            }
        });
    },
    setClientId(clientId) {
        state.clientId = clientId;
        state.api = new _utils_FetchUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .FetchUtil */ .Z({ baseUrl, clientId });
    }
};
//# sourceMappingURL=BlockchainApiController.js.map

/***/ }),

/***/ 778508:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ RouterController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(923082);
/* harmony import */ var _AccountController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(863450);
/* harmony import */ var _ChainController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(806056);
/* harmony import */ var _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(236010);
/* harmony import */ var _ModalController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91111);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(500026);








// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    view: 'Connect',
    history: ['Connect'],
    transactionStack: []
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    pushTransactionStack(action) {
        state.transactionStack.push(action);
    },
    popTransactionStack(status) {
        const action = state.transactionStack.pop();
        if (!action) {
            return;
        }
        const { onSuccess, onError, onCancel } = action;
        switch (status) {
            case 'success':
                onSuccess?.();
                break;
            case 'error':
                onError?.();
                RouterController.goBack();
                break;
            case 'cancel':
                onCancel?.();
                RouterController.goBack();
                break;
            default:
        }
    },
    push(view, data) {
        if (view !== state.view) {
            state.view = view;
            state.history.push(view);
            state.data = data;
        }
    },
    reset(view, data) {
        state.view = view;
        state.history = [view];
        state.data = data;
    },
    replace(view, data) {
        const lastView = state.history.at(-1);
        const isSameView = lastView === view;
        if (!isSameView) {
            state.view = view;
            state.history[state.history.length - 1] = view;
            state.data = data;
        }
    },
    goBack() {
        const isConnected = _ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.state.activeCaipAddress;
        const isFarcasterView = RouterController.state.view === 'ConnectingFarcaster';
        const shouldReload = !isConnected && isFarcasterView;
        if (state.history.length > 1) {
            state.history.pop();
            const [last] = state.history.slice(-1);
            if (last) {
                const isConnectView = last === 'Connect';
                if (isConnected && isConnectView) {
                    state.view = 'Account';
                }
                else {
                    state.view = last;
                }
            }
        }
        else {
            _ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.close();
        }
        if (state.data?.wallet) {
            state.data.wallet = undefined;
        }
        // Reloading the iframe contentwindow and doing the view animation in the modal causes a small freeze in the transition. Doing these separately fixes that.
        setTimeout(() => {
            if (shouldReload) {
                _AccountController_js__WEBPACK_IMPORTED_MODULE_4__/* .AccountController */ .U.setFarcasterUrl(undefined, _ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.state.activeChain);
                const authConnector = _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.getAuthConnector();
                authConnector?.provider?.reload();
                const optionsState = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .snapshot */ .P9)(_OptionsController_js__WEBPACK_IMPORTED_MODULE_6__/* .OptionsController */ .H.state);
                authConnector?.provider?.syncDappData?.({
                    metadata: optionsState.metadata,
                    sdkVersion: optionsState.sdkVersion,
                    projectId: optionsState.projectId,
                    sdkType: optionsState.sdkType
                });
            }
        }, 100);
    },
    goBackToIndex(historyIndex) {
        if (state.history.length > 1) {
            state.history = state.history.slice(0, historyIndex + 1);
            const [last] = state.history.slice(-1);
            if (last) {
                state.view = last;
            }
        }
    },
    goBackOrCloseModal() {
        if (RouterController.state.history.length > 1) {
            RouterController.goBack();
        }
        else {
            _ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.close();
        }
    }
};
// Export the controller wrapped with our error boundary
const RouterController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_7__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=RouterController.js.map

/***/ }),

/***/ 792968:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  R: () => (/* binding */ SendController)
});

// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
;// ./node_modules/@reown/appkit-common/node_modules/big.js/big.mjs
/*
 *  big.js v6.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2024 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,            // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,     // true or false


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true && typeof n !== 'bigint') {
          throw TypeError(INVALID + 'value');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }

      parse(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;

  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;

  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }

  if (sd < 1) {
    more =
      rm === 3 && (more || !!xc[0]) || sd === 0 && (
      rm === 1 && xc[0] >= 5 ||
      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
    );

    xc.length = 1;

    if (more) {

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {

      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {

    // xc[sd] is the digit after the digit that may be rounded up.
    more =
      rm === 1 && xc[sd] >= 5 ||
      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
      rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd;

    // Round up?
    if (more) {

      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[--sd] > 9;) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && isNonzero ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big negated.
 */
P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e, k, t,
    x = this,
    Big = x.constructor;

  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }

    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }

  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(+stringify(x, true, true));

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, true, !!n);
};


/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, false, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};


/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = +stringify(this, true, true);
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];

  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }

  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};


// Export


var Big = _Big_();

/// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
/* harmony default export */ const big = (Big);

;// ./node_modules/@reown/appkit-common/dist/esm/src/utils/NumberUtil.js

const NumberUtil = {
    bigNumber(value) {
        if (!value) {
            return new big(0);
        }
        return new big(value);
    },
    multiply(a, b) {
        if (a === undefined || b === undefined) {
            return new big(0);
        }
        const aBigNumber = new big(a);
        const bBigNumber = new big(b);
        return aBigNumber.times(bBigNumber);
    },
    formatNumberToLocalString(value, decimals = 2) {
        if (value === undefined) {
            return '0.00';
        }
        if (typeof value === 'number') {
            return value.toLocaleString('en-US', {
                maximumFractionDigits: decimals,
                minimumFractionDigits: decimals
            });
        }
        return parseFloat(value).toLocaleString('en-US', {
            maximumFractionDigits: decimals,
            minimumFractionDigits: decimals
        });
    },
    parseLocalStringToNumber(value) {
        if (value === undefined) {
            return 0;
        }
        return parseFloat(value.replace(/,/gu, ''));
    }
};
//# sourceMappingURL=NumberUtil.js.map
;// ./node_modules/@reown/appkit-common/dist/esm/src/contracts/erc20.js
const erc20ABI = [
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: '_from',
                type: 'address'
            },
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ]
    }
];
//# sourceMappingURL=erc20.js.map
;// ./node_modules/@reown/appkit-common/dist/esm/src/contracts/swap.js
const swapABI = [
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' }
        ],
        outputs: [{ type: 'bool' }]
    }
];
//# sourceMappingURL=swap.js.map
;// ./node_modules/@reown/appkit-common/dist/esm/src/contracts/usdt.js
const usdtABI = [
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: []
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address'
            },
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ]
    }
];
//# sourceMappingURL=usdt.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = __webpack_require__(824376);
;// ./node_modules/@reown/appkit-common/dist/esm/src/utils/ContractUtil.js




const ContractUtil = {
    getERC20Abi: (tokenAddress) => {
        if (ConstantsUtil/* ConstantsUtil */.o.USDT_CONTRACT_ADDRESSES.includes(tokenAddress)) {
            return usdtABI;
        }
        return erc20ABI;
    },
    getSwapAbi: () => swapABI
};
//# sourceMappingURL=ContractUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js
var W3mFrameConstants = __webpack_require__(110152);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var utils_ConstantsUtil = __webpack_require__(562944);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var AccountController = __webpack_require__(863450);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var BlockchainApiController = __webpack_require__(775595);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var ChainController = __webpack_require__(806056);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js + 1 modules
var ConnectionController = __webpack_require__(627987);
// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/unit/formatUnits.js
var formatUnits = __webpack_require__(287135);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ERC7811Util.js

const ERC7811Utils = {
    /**
     * Creates a Balance object from an ERC7811 Asset object
     * @param asset - Asset object to convert
     * @param chainId - Chain ID in CAIP-2 format
     * @returns Balance object
     */
    createBalance(asset, chainId) {
        const metadata = {
            name: (asset.metadata['name'] || ''),
            symbol: (asset.metadata['symbol'] || ''),
            decimals: (asset.metadata['decimals'] || 0),
            value: (asset.metadata['value'] || 0),
            price: (asset.metadata['price'] || 0),
            iconUrl: (asset.metadata['iconUrl'] || '')
        };
        return {
            name: metadata.name,
            symbol: metadata.symbol,
            chainId,
            address: asset.address === 'native'
                ? undefined
                : this.convertAddressToCAIP10Address(asset.address, chainId),
            value: metadata.value,
            price: metadata.price,
            quantity: {
                decimals: metadata.decimals.toString(),
                numeric: this.convertHexToBalance({
                    hex: asset.balance,
                    decimals: metadata.decimals
                })
            },
            iconUrl: metadata.iconUrl
        };
    },
    /**
     * Converts a hex string to a Balance object
     * @param hex - Hex string to convert
     * @param decimals - Number of decimals to use
     * @returns Balance object
     */
    convertHexToBalance({ hex, decimals }) {
        return (0,formatUnits/* formatUnits */.J)(BigInt(hex), decimals);
    },
    /**
     * Converts an address to a CAIP-10 address
     * @param address - Address to convert
     * @param chainId - Chain ID in CAIP-2 format
     * @returns CAIP-10 address
     */
    convertAddressToCAIP10Address(address, chainId) {
        return `${chainId}:${address}`;
    },
    /**
     *  Creates a CAIP-2 Chain ID from a chain ID and namespace
     * @param chainId  - Chain ID in hex format
     * @param namespace  - Chain namespace
     * @returns
     */
    createCAIP2ChainId(chainId, namespace) {
        return `${namespace}:${parseInt(chainId, 16)}`;
    },
    /**
     * Gets the chain ID in hex format from a CAIP-2 Chain ID
     * @param caip2ChainId - CAIP-2 Chain ID
     * @returns Chain ID in hex format
     */
    getChainIdHexFromCAIP2ChainId(caip2ChainId) {
        const parts = caip2ChainId.split(':');
        if (parts.length < 2 || !parts[1]) {
            return '0x0';
        }
        const chainPart = parts[1];
        const parsed = parseInt(chainPart, 10);
        return isNaN(parsed) ? '0x0' : `0x${parsed.toString(16)}`;
    },
    /**
     * Checks if a response is a valid WalletGetAssetsResponse
     * @param response - The response to check
     * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
     */
    isWalletGetAssetsResponse(response) {
        // Check if response is an object and has the expected structure
        if (typeof response !== 'object' || response === null) {
            return false;
        }
        // Check if all values are arrays and conform to the expected asset structure
        return Object.values(response).every(value => Array.isArray(value) && value.every(asset => this.isValidAsset(asset)));
    },
    /**
     * Checks if an asset object is valid.
     * @param asset - The asset object to check.
     * @returns True if the asset is valid, false otherwise.
     */
    isValidAsset(asset) {
        return (typeof asset === 'object' &&
            asset !== null &&
            typeof asset.address === 'string' &&
            typeof asset.balance === 'string' &&
            (asset.type === 'ERC20' || asset.type === 'NATIVE') &&
            typeof asset.metadata === 'object' &&
            asset.metadata !== null &&
            typeof asset.metadata['name'] === 'string' &&
            typeof asset.metadata['symbol'] === 'string' &&
            typeof asset.metadata['decimals'] === 'number' &&
            typeof asset.metadata['price'] === 'number' &&
            typeof asset.metadata['iconUrl'] === 'string');
    }
};
//# sourceMappingURL=ERC7811Util.js.map
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/SendApiUtil.js





// -- Controller ---------------------------------------- //
const SendApiUtil = {
    async getMyTokensWithBalance(forceUpdate) {
        const address = AccountController/* AccountController */.U.state.address;
        const caipNetwork = ChainController/* ChainController */.W.state.activeCaipNetwork;
        if (!address || !caipNetwork) {
            return [];
        }
        // Extract EIP-155 specific logic
        if (caipNetwork.chainNamespace === 'eip155') {
            const eip155Balances = await this.getEIP155Balances(address, caipNetwork);
            if (eip155Balances) {
                return this.filterLowQualityTokens(eip155Balances);
            }
        }
        // Fallback to 1Inch API
        const response = await BlockchainApiController/* BlockchainApiController */.T.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);
        return this.filterLowQualityTokens(response.balances);
    },
    async getEIP155Balances(address, caipNetwork) {
        try {
            const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);
            const walletCapabilities = (await ConnectionController/* ConnectionController */.x.getCapabilities(address));
            if (!walletCapabilities?.[chainIdHex]?.['assetDiscovery']?.supported) {
                return null;
            }
            const walletGetAssetsResponse = await ConnectionController/* ConnectionController */.x.walletGetAssets({
                account: address,
                chainFilter: [chainIdHex]
            });
            if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {
                return null;
            }
            const assets = walletGetAssetsResponse[chainIdHex] || [];
            return assets.map(asset => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));
        }
        catch (error) {
            return null;
        }
    },
    /**
     * The 1Inch API includes many low-quality tokens in the balance response,
     * which appear inconsistently. This filter prevents them from being displayed.
     */
    filterLowQualityTokens(balances) {
        return balances.filter(balance => balance.quantity.decimals !== '0');
    },
    mapBalancesToSwapTokens(balances) {
        return (balances?.map(token => ({
            ...token,
            address: token?.address
                ? token.address
                : ChainController/* ChainController */.W.getActiveNetworkTokenAddress(),
            decimals: parseInt(token.quantity.decimals, 10),
            logoUri: token.iconUrl,
            eip2612: false
        })) || []);
    }
};
//# sourceMappingURL=SendApiUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js + 1 modules
var withErrorBoundary = __webpack_require__(923082);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var EventsController = __webpack_require__(390184);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var RouterController = __webpack_require__(778508);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var SnackController = __webpack_require__(121871);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js















// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    tokenBalances: [],
    loading: false
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(state, () => callback(state));
    },
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(state, key, callback);
    },
    setToken(token) {
        if (token) {
            state.token = (0,vanilla/* ref */.KR)(token);
        }
    },
    setTokenAmount(sendTokenAmount) {
        state.sendTokenAmount = sendTokenAmount;
    },
    setReceiverAddress(receiverAddress) {
        state.receiverAddress = receiverAddress;
    },
    setReceiverProfileImageUrl(receiverProfileImageUrl) {
        state.receiverProfileImageUrl = receiverProfileImageUrl;
    },
    setReceiverProfileName(receiverProfileName) {
        state.receiverProfileName = receiverProfileName;
    },
    setNetworkBalanceInUsd(networkBalanceInUSD) {
        state.networkBalanceInUSD = networkBalanceInUSD;
    },
    setLoading(loading) {
        state.loading = loading;
    },
    async sendToken() {
        try {
            SendController.setLoading(true);
            switch (ChainController/* ChainController */.W.state.activeCaipNetwork?.chainNamespace) {
                case 'eip155':
                    await SendController.sendEvmToken();
                    return;
                case 'solana':
                    await SendController.sendSolanaToken();
                    return;
                default:
                    throw new Error('Unsupported chain');
            }
        }
        finally {
            SendController.setLoading(false);
        }
    },
    async sendEvmToken() {
        const activeChainNamespace = ChainController/* ChainController */.W.state.activeChain;
        const activeAccountType = AccountController/* AccountController */.U.state.preferredAccountTypes?.[activeChainNamespace];
        if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
            throw new Error('An amount and receiver address are required');
        }
        if (!SendController.state.token) {
            throw new Error('A token is required');
        }
        if (SendController.state.token?.address) {
            EventsController/* EventsController */.E.sendEvent({
                type: 'track',
                event: 'SEND_INITIATED',
                properties: {
                    isSmartAccount: activeAccountType === W3mFrameConstants/* W3mFrameRpcConstants */.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: SendController.state.token.address,
                    amount: SendController.state.sendTokenAmount,
                    network: ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId || ''
                }
            });
            await SendController.sendERC20Token({
                receiverAddress: SendController.state.receiverAddress,
                tokenAddress: SendController.state.token.address,
                sendTokenAmount: SendController.state.sendTokenAmount,
                decimals: SendController.state.token.quantity.decimals
            });
        }
        else {
            EventsController/* EventsController */.E.sendEvent({
                type: 'track',
                event: 'SEND_INITIATED',
                properties: {
                    isSmartAccount: activeAccountType === W3mFrameConstants/* W3mFrameRpcConstants */.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: SendController.state.token.symbol || '',
                    amount: SendController.state.sendTokenAmount,
                    network: ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId || ''
                }
            });
            await SendController.sendNativeToken({
                receiverAddress: SendController.state.receiverAddress,
                sendTokenAmount: SendController.state.sendTokenAmount,
                decimals: SendController.state.token.quantity.decimals
            });
        }
    },
    async fetchTokenBalance(onError) {
        state.loading = true;
        const chainId = ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId;
        const chain = ChainController/* ChainController */.W.state.activeCaipNetwork?.chainNamespace;
        const caipAddress = ChainController/* ChainController */.W.state.activeCaipAddress;
        const address = caipAddress ? CoreHelperUtil/* CoreHelperUtil */.w.getPlainAddress(caipAddress) : undefined;
        if (state.lastRetry &&
            !CoreHelperUtil/* CoreHelperUtil */.w.isAllowedRetry(state.lastRetry, 30 * utils_ConstantsUtil/* ConstantsUtil */.oU.ONE_SEC_MS)) {
            state.loading = false;
            return [];
        }
        try {
            if (address && chainId && chain) {
                const balances = await SendApiUtil.getMyTokensWithBalance();
                state.tokenBalances = balances;
                state.lastRetry = undefined;
                return balances;
            }
        }
        catch (error) {
            state.lastRetry = Date.now();
            onError?.(error);
            SnackController/* SnackController */.P.showError('Token Balance Unavailable');
        }
        finally {
            state.loading = false;
        }
        return [];
    },
    fetchNetworkBalance() {
        if (state.tokenBalances.length === 0) {
            return;
        }
        const networkTokenBalances = SendApiUtil.mapBalancesToSwapTokens(state.tokenBalances);
        if (!networkTokenBalances) {
            return;
        }
        const networkToken = networkTokenBalances.find(token => token.address === ChainController/* ChainController */.W.getActiveNetworkTokenAddress());
        if (!networkToken) {
            return;
        }
        state.networkBalanceInUSD = networkToken
            ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString()
            : '0';
    },
    async sendNativeToken(params) {
        RouterController/* RouterController */.I.pushTransactionStack({});
        const to = params.receiverAddress;
        const address = AccountController/* AccountController */.U.state.address;
        const value = ConnectionController/* ConnectionController */.x.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
        const data = '0x';
        await ConnectionController/* ConnectionController */.x.sendTransaction({
            chainNamespace: 'eip155',
            to,
            address,
            data,
            value: value ?? BigInt(0)
        });
        EventsController/* EventsController */.E.sendEvent({
            type: 'track',
            event: 'SEND_SUCCESS',
            properties: {
                isSmartAccount: AccountController/* AccountController */.U.state.preferredAccountTypes?.['eip155'] ===
                    W3mFrameConstants/* W3mFrameRpcConstants */.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                token: SendController.state.token?.symbol || '',
                amount: params.sendTokenAmount,
                network: ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId || ''
            }
        });
        ConnectionController/* ConnectionController */.x._getClient()?.updateBalance('eip155');
        SendController.resetSend();
    },
    async sendERC20Token(params) {
        RouterController/* RouterController */.I.pushTransactionStack({
            onSuccess() {
                RouterController/* RouterController */.I.replace('Account');
            }
        });
        const amount = ConnectionController/* ConnectionController */.x.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
        if (AccountController/* AccountController */.U.state.address &&
            params.sendTokenAmount &&
            params.receiverAddress &&
            params.tokenAddress) {
            const tokenAddress = CoreHelperUtil/* CoreHelperUtil */.w.getPlainAddress(params.tokenAddress);
            await ConnectionController/* ConnectionController */.x.writeContract({
                fromAddress: AccountController/* AccountController */.U.state.address,
                tokenAddress,
                args: [params.receiverAddress, amount ?? BigInt(0)],
                method: 'transfer',
                abi: ContractUtil.getERC20Abi(tokenAddress),
                chainNamespace: 'eip155'
            });
            SendController.resetSend();
        }
    },
    async sendSolanaToken() {
        if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
            throw new Error('An amount and receiver address are required');
        }
        RouterController/* RouterController */.I.pushTransactionStack({
            onSuccess() {
                RouterController/* RouterController */.I.replace('Account');
            }
        });
        await ConnectionController/* ConnectionController */.x.sendTransaction({
            chainNamespace: 'solana',
            to: SendController.state.receiverAddress,
            value: SendController.state.sendTokenAmount
        });
        ConnectionController/* ConnectionController */.x._getClient()?.updateBalance('solana');
        SendController.resetSend();
    },
    resetSend() {
        state.token = undefined;
        state.sendTokenAmount = undefined;
        state.receiverAddress = undefined;
        state.receiverProfileImageUrl = undefined;
        state.receiverProfileName = undefined;
        state.loading = false;
        state.tokenBalances = [];
    }
};
// Export the controller wrapped with our error boundary
const SendController = (0,withErrorBoundary/* withErrorBoundary */.X)(controller);
//# sourceMappingURL=SendController.js.map

/***/ }),

/***/ 801122:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ SIWXUtil)
/* harmony export */ });
/* harmony import */ var _walletconnect_universal_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155500);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(824376);
/* harmony import */ var _reown_appkit_wallet_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(110152);
/* harmony import */ var _controllers_AccountController_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(863450);
/* harmony import */ var _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(806056);
/* harmony import */ var _controllers_ConnectionController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(627987);
/* harmony import */ var _controllers_ConnectorController_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(236010);
/* harmony import */ var _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(390184);
/* harmony import */ var _controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91111);
/* harmony import */ var _controllers_OptionsController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(500026);
/* harmony import */ var _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(778508);
/* harmony import */ var _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(121871);
/* harmony import */ var _CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(226742);













/**
 * SIWXUtil holds the methods to interact with the SIWX plugin and must be called internally on AppKit.
 */
const SIWXUtil = {
    getSIWX() {
        return _controllers_OptionsController_js__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.siwx;
    },
    async initializeIfEnabled() {
        const siwx = _controllers_OptionsController_js__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.siwx;
        const caipAddress = _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipAddress();
        if (!(siwx && caipAddress)) {
            return;
        }
        const [namespace, chainId, address] = caipAddress.split(':');
        if (!_controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.checkIfSupportedNetwork(namespace)) {
            return;
        }
        try {
            const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address);
            if (sessions.length) {
                return;
            }
            await _controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.open({
                view: 'SIWXSignMessage'
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('SIWXUtil:initializeIfEnabled', error);
            _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                type: 'track',
                event: 'SIWX_AUTH_ERROR',
                properties: this.getSIWXEventProperties()
            });
            // eslint-disable-next-line no-console
            await _controllers_ConnectionController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectionController */ .x._getClient()?.disconnect().catch(console.error);
            _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.reset('Connect');
            _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.showError('A problem occurred while trying initialize authentication');
        }
    },
    async requestSignMessage() {
        const siwx = _controllers_OptionsController_js__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.siwx;
        const address = _CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_8__/* .CoreHelperUtil */ .w.getPlainAddress(_controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipAddress());
        const network = _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipNetwork();
        const client = _controllers_ConnectionController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectionController */ .x._getClient();
        if (!siwx) {
            throw new Error('SIWX is not enabled');
        }
        if (!address) {
            throw new Error('No ActiveCaipAddress found');
        }
        if (!network) {
            throw new Error('No ActiveCaipNetwork or client found');
        }
        if (!client) {
            throw new Error('No ConnectionController client found');
        }
        try {
            const siwxMessage = await siwx.createMessage({
                chainId: network.caipNetworkId,
                accountAddress: address
            });
            const message = siwxMessage.toString();
            const connectorId = _controllers_ConnectorController_js__WEBPACK_IMPORTED_MODULE_9__/* .ConnectorController */ .a.getConnectorId(network.chainNamespace);
            if (connectorId === _reown_appkit_common__WEBPACK_IMPORTED_MODULE_10__/* .ConstantsUtil */ .o.CONNECTOR_ID.AUTH) {
                _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.pushTransactionStack({});
            }
            const signature = await client.signMessage(message);
            await siwx.addSession({
                data: siwxMessage,
                message,
                signature: signature
            });
            _controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.close();
            _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                type: 'track',
                event: 'SIWX_AUTH_SUCCESS',
                properties: this.getSIWXEventProperties()
            });
        }
        catch (error) {
            const properties = this.getSIWXEventProperties();
            if (!_controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.state.open || _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.state.view === 'ApproveTransaction') {
                await _controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.open({
                    view: 'SIWXSignMessage'
                });
            }
            if (properties.isSmartAccount) {
                _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.showError('This application might not support Smart Accounts');
            }
            else {
                _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.showError('Signature declined');
            }
            _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                type: 'track',
                event: 'SIWX_AUTH_ERROR',
                properties
            });
            // eslint-disable-next-line no-console
            console.error('SWIXUtil:requestSignMessage', error);
        }
    },
    async cancelSignMessage() {
        try {
            const siwx = this.getSIWX();
            const isRequired = siwx?.getRequired?.();
            if (isRequired) {
                await _controllers_ConnectionController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectionController */ .x.disconnect();
            }
            else {
                _controllers_ModalController_js__WEBPACK_IMPORTED_MODULE_3__/* .ModalController */ .W.close();
            }
            _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.reset('Connect');
            _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                event: 'CLICK_CANCEL_SIWX',
                type: 'track',
                properties: this.getSIWXEventProperties()
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('SIWXUtil:cancelSignMessage', error);
        }
    },
    async getSessions() {
        const siwx = _controllers_OptionsController_js__WEBPACK_IMPORTED_MODULE_1__/* .OptionsController */ .H.state.siwx;
        const address = _CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_8__/* .CoreHelperUtil */ .w.getPlainAddress(_controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipAddress());
        const network = _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipNetwork();
        if (!(siwx && address && network)) {
            return [];
        }
        return siwx.getSessions(network.caipNetworkId, address);
    },
    async isSIWXCloseDisabled() {
        const siwx = this.getSIWX();
        if (siwx) {
            const isApproveSignScreen = _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.state.view === 'ApproveTransaction';
            const isSiwxSignMessage = _controllers_RouterController_js__WEBPACK_IMPORTED_MODULE_6__/* .RouterController */ .I.state.view === 'SIWXSignMessage';
            if (isApproveSignScreen || isSiwxSignMessage) {
                return siwx.getRequired?.() && (await this.getSessions()).length === 0;
            }
        }
        return false;
    },
    async universalProviderAuthenticate({ universalProvider, chains, methods }) {
        const siwx = SIWXUtil.getSIWX();
        const namespaces = new Set(chains.map(chain => chain.split(':')[0]));
        if (!siwx || namespaces.size !== 1 || !namespaces.has('eip155')) {
            return false;
        }
        // Ignores chainId and account address to get other message data
        const siwxMessage = await siwx.createMessage({
            chainId: _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.getActiveCaipNetwork()?.caipNetworkId || '',
            accountAddress: ''
        });
        const result = await universalProvider.authenticate({
            nonce: siwxMessage.nonce,
            domain: siwxMessage.domain,
            uri: siwxMessage.uri,
            exp: siwxMessage.expirationTime,
            iat: siwxMessage.issuedAt,
            nbf: siwxMessage.notBefore,
            requestId: siwxMessage.requestId,
            version: siwxMessage.version,
            resources: siwxMessage.resources,
            statement: siwxMessage.statement,
            chainId: siwxMessage.chainId,
            methods,
            // The first chainId is what is used for universal provider to build the message
            chains: [siwxMessage.chainId, ...chains.filter(chain => chain !== siwxMessage.chainId)]
        });
        _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.showLoading('Authenticating...', { autoClose: false });
        _controllers_AccountController_js__WEBPACK_IMPORTED_MODULE_11__/* .AccountController */ .U.setConnectedWalletInfo({
            ...result.session.peer.metadata,
            name: result.session.peer.metadata.name,
            icon: result.session.peer.metadata.icons?.[0],
            type: 'WALLET_CONNECT'
        }, Array.from(namespaces)[0]);
        if (result?.auths?.length) {
            const sessions = result.auths.map(cacao => {
                const message = universalProvider.client.formatAuthMessage({
                    request: cacao.p,
                    iss: cacao.p.iss
                });
                return {
                    data: {
                        ...cacao.p,
                        accountAddress: cacao.p.iss.split(':').slice(-1).join(''),
                        chainId: cacao.p.iss.split(':').slice(2, 4).join(':'),
                        uri: cacao.p.aud,
                        version: cacao.p.version || siwxMessage.version,
                        expirationTime: cacao.p.exp,
                        issuedAt: cacao.p.iat,
                        notBefore: cacao.p.nbf
                    },
                    message,
                    signature: cacao.s.s,
                    cacao
                };
            });
            try {
                await siwx.setSessions(sessions);
                _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                    type: 'track',
                    event: 'SIWX_AUTH_SUCCESS',
                    properties: SIWXUtil.getSIWXEventProperties()
                });
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error('SIWX:universalProviderAuth - failed to set sessions', error);
                _controllers_EventsController_js__WEBPACK_IMPORTED_MODULE_4__/* .EventsController */ .E.sendEvent({
                    type: 'track',
                    event: 'SIWX_AUTH_ERROR',
                    properties: SIWXUtil.getSIWXEventProperties()
                });
                // eslint-disable-next-line no-console
                await universalProvider.disconnect().catch(console.error);
                throw error;
            }
            finally {
                _controllers_SnackController_js__WEBPACK_IMPORTED_MODULE_7__/* .SnackController */ .P.hide();
            }
        }
        return true;
    },
    getSIWXEventProperties() {
        const activeChainNamespace = _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.state.activeChain;
        return {
            network: _controllers_ChainController_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId || '',
            isSmartAccount: _controllers_AccountController_js__WEBPACK_IMPORTED_MODULE_11__/* .AccountController */ .U.state.preferredAccountTypes?.[activeChainNamespace] ===
                _reown_appkit_wallet_utils__WEBPACK_IMPORTED_MODULE_12__/* .W3mFrameRpcConstants */ .Vl.ACCOUNT_TYPES.SMART_ACCOUNT
        };
    },
    async clearSessions() {
        const siwx = this.getSIWX();
        if (siwx) {
            await siwx.setSessions([]);
        }
    }
};
//# sourceMappingURL=SIWXUtil.js.map

/***/ }),

/***/ 806056:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ChainController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204707);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(173495);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(824376);
/* harmony import */ var _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(562944);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(226742);
/* harmony import */ var _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127508);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(923082);
/* harmony import */ var _AccountController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(863450);
/* harmony import */ var _ConnectionController_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(627987);
/* harmony import */ var _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(236010);
/* harmony import */ var _EventsController_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(390184);
/* harmony import */ var _ModalController_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(91111);
/* harmony import */ var _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(500026);
/* harmony import */ var _PublicStateController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(698467);
/* harmony import */ var _RouterController_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(778508);
/* harmony import */ var _SendController_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(792968);
















// -- Constants ----------------------------------------- //
const accountState = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: false,
    addressLabels: new Map(),
    allAccounts: [],
    user: undefined
};
const networkState = {
    caipNetwork: undefined,
    supportsAllNetworks: true,
    smartAccountEnabledNetworks: []
};
// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    chains: (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .proxyMap */ .zC)(),
    activeCaipAddress: undefined,
    activeChain: undefined,
    activeCaipNetwork: undefined,
    noAdapters: false,
    universalAdapter: {
        networkControllerClient: undefined,
        connectionControllerClient: undefined
    },
    isSwitchingNamespace: false
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state, () => {
            callback(state);
        });
    },
    subscribeKey(key, callback) {
        return (0,valtio_vanilla_utils__WEBPACK_IMPORTED_MODULE_1__/* .subscribeKey */ .u$)(state, key, callback);
    },
    subscribeChainProp(property, callback, chain) {
        let prev = undefined;
        return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .subscribe */ .B1)(state.chains, () => {
            const activeChain = chain || state.activeChain;
            if (activeChain) {
                const nextValue = state.chains.get(activeChain)?.[property];
                if (prev !== nextValue) {
                    prev = nextValue;
                    callback(nextValue);
                }
            }
        });
    },
    initialize(adapters, caipNetworks, clients) {
        const { chainId: activeChainId, namespace: activeNamespace } = _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.getActiveNetworkProps();
        const activeCaipNetwork = caipNetworks?.find(network => network.id.toString() === activeChainId?.toString());
        const defaultAdapter = adapters.find(adapter => adapter?.namespace === activeNamespace);
        const adapterToActivate = defaultAdapter || adapters?.[0];
        const namespacesFromAdapters = adapters.map(a => a.namespace).filter(n => n !== undefined);
        /**
         * If the AppKit is in embedded mode (for Demo app), we should get the available namespaces from the adapters.
         */
        const namespaces = _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.enableEmbedded
            ? new Set([...namespacesFromAdapters])
            : new Set([...(caipNetworks?.map(network => network.chainNamespace) ?? [])]);
        if (adapters?.length === 0 || !adapterToActivate) {
            state.noAdapters = true;
        }
        if (!state.noAdapters) {
            state.activeChain = adapterToActivate?.namespace;
            state.activeCaipNetwork = activeCaipNetwork;
            ChainController.setChainNetworkData(adapterToActivate?.namespace, {
                caipNetwork: activeCaipNetwork
            });
            if (state.activeChain) {
                _PublicStateController_js__WEBPACK_IMPORTED_MODULE_4__/* .PublicStateController */ .z.set({ activeChain: adapterToActivate?.namespace });
            }
        }
        namespaces.forEach(namespace => {
            const namespaceNetworks = caipNetworks?.filter(network => network.chainNamespace === namespace);
            ChainController.state.chains.set(namespace, {
                namespace,
                networkState: (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
                    ...networkState,
                    caipNetwork: namespaceNetworks?.[0]
                }),
                accountState: (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)(accountState),
                caipNetworks: namespaceNetworks ?? [],
                ...clients
            });
            ChainController.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);
        });
    },
    removeAdapter(namespace) {
        if (state.activeChain === namespace) {
            const nextAdapter = Array.from(state.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);
            if (nextAdapter) {
                const caipNetwork = nextAdapter[1]?.caipNetworks?.[0];
                if (caipNetwork) {
                    ChainController.setActiveCaipNetwork(caipNetwork);
                }
            }
        }
        state.chains.delete(namespace);
    },
    addAdapter(adapter, { networkControllerClient, connectionControllerClient }, caipNetworks) {
        state.chains.set(adapter.namespace, {
            namespace: adapter.namespace,
            networkState: {
                ...networkState,
                caipNetwork: caipNetworks[0]
            },
            accountState,
            caipNetworks,
            connectionControllerClient,
            networkControllerClient
        });
        ChainController.setRequestedCaipNetworks(caipNetworks?.filter(caipNetwork => caipNetwork.chainNamespace === adapter.namespace) ?? [], adapter.namespace);
    },
    addNetwork(network) {
        const chainAdapter = state.chains.get(network.chainNamespace);
        if (chainAdapter) {
            const newNetworks = [...(chainAdapter.caipNetworks || [])];
            if (!chainAdapter.caipNetworks?.find(caipNetwork => caipNetwork.id === network.id)) {
                newNetworks.push(network);
            }
            state.chains.set(network.chainNamespace, { ...chainAdapter, caipNetworks: newNetworks });
            ChainController.setRequestedCaipNetworks(newNetworks, network.chainNamespace);
            _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.filterByNamespace(network.chainNamespace, true);
        }
    },
    removeNetwork(namespace, networkId) {
        const chainAdapter = state.chains.get(namespace);
        if (chainAdapter) {
            // Check if network being removed is active network
            const isActiveNetwork = state.activeCaipNetwork?.id === networkId;
            // Filter out the network being removed
            const newCaipNetworksOfAdapter = [
                ...(chainAdapter.caipNetworks?.filter(network => network.id !== networkId) || [])
            ];
            // If active network was removed and there are other networks available, switch to first one
            if (isActiveNetwork && chainAdapter?.caipNetworks?.[0]) {
                ChainController.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);
            }
            state.chains.set(namespace, { ...chainAdapter, caipNetworks: newCaipNetworksOfAdapter });
            ChainController.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);
            if (newCaipNetworksOfAdapter.length === 0) {
                _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.filterByNamespace(namespace, false);
            }
        }
    },
    setAdapterNetworkState(chain, props) {
        const chainAdapter = state.chains.get(chain);
        if (chainAdapter) {
            chainAdapter.networkState = {
                ...(chainAdapter.networkState || networkState),
                ...props
            };
            state.chains.set(chain, chainAdapter);
        }
    },
    setChainAccountData(chain, accountProps, _unknown = true) {
        if (!chain) {
            throw new Error('Chain is required to update chain account data');
        }
        const chainAdapter = state.chains.get(chain);
        if (chainAdapter) {
            const newAccountState = { ...(chainAdapter.accountState || accountState), ...accountProps };
            state.chains.set(chain, { ...chainAdapter, accountState: newAccountState });
            if (state.chains.size === 1 || state.activeChain === chain) {
                if (accountProps.caipAddress) {
                    state.activeCaipAddress = accountProps.caipAddress;
                }
                _AccountController_js__WEBPACK_IMPORTED_MODULE_6__/* .AccountController */ .U.replaceState(newAccountState);
            }
        }
    },
    setChainNetworkData(chain, networkProps) {
        if (!chain) {
            return;
        }
        const chainAdapter = state.chains.get(chain);
        if (chainAdapter) {
            const newNetworkState = { ...(chainAdapter.networkState || networkState), ...networkProps };
            state.chains.set(chain, { ...chainAdapter, networkState: newNetworkState });
        }
    },
    // eslint-disable-next-line max-params
    setAccountProp(prop, value, chain, replaceState = true) {
        ChainController.setChainAccountData(chain, { [prop]: value }, replaceState);
        if (prop === 'status' && value === 'disconnected' && chain) {
            _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.removeConnectorId(chain);
        }
    },
    setActiveNamespace(chain) {
        state.activeChain = chain;
        const newAdapter = chain ? state.chains.get(chain) : undefined;
        const caipNetwork = newAdapter?.networkState?.caipNetwork;
        if (caipNetwork?.id && chain) {
            state.activeCaipAddress = newAdapter?.accountState?.caipAddress;
            state.activeCaipNetwork = caipNetwork;
            ChainController.setChainNetworkData(chain, { caipNetwork });
            _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.setActiveCaipNetworkId(caipNetwork?.caipNetworkId);
            _PublicStateController_js__WEBPACK_IMPORTED_MODULE_4__/* .PublicStateController */ .z.set({
                activeChain: chain,
                selectedNetworkId: caipNetwork?.caipNetworkId
            });
        }
    },
    setActiveCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
            return;
        }
        if (state.activeChain !== caipNetwork.chainNamespace) {
            ChainController.setIsSwitchingNamespace(true);
        }
        const newAdapter = state.chains.get(caipNetwork.chainNamespace);
        state.activeChain = caipNetwork.chainNamespace;
        state.activeCaipNetwork = caipNetwork;
        ChainController.setChainNetworkData(caipNetwork.chainNamespace, { caipNetwork });
        if (newAdapter?.accountState?.address) {
            state.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${newAdapter?.accountState?.address}`;
        }
        else {
            state.activeCaipAddress = undefined;
        }
        // Update the chain's account state with the new caip address value
        ChainController.setAccountProp('caipAddress', state.activeCaipAddress, caipNetwork.chainNamespace);
        if (newAdapter) {
            _AccountController_js__WEBPACK_IMPORTED_MODULE_6__/* .AccountController */ .U.replaceState(newAdapter.accountState);
        }
        // Reset send state when switching networks
        _SendController_js__WEBPACK_IMPORTED_MODULE_7__/* .SendController */ .R.resetSend();
        _PublicStateController_js__WEBPACK_IMPORTED_MODULE_4__/* .PublicStateController */ .z.set({
            activeChain: state.activeChain,
            selectedNetworkId: state.activeCaipNetwork?.caipNetworkId
        });
        _utils_StorageUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .StorageUtil */ .i.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
        const isSupported = ChainController.checkIfSupportedNetwork(caipNetwork.chainNamespace);
        if (!isSupported &&
            _OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.enableNetworkSwitch &&
            !_OptionsController_js__WEBPACK_IMPORTED_MODULE_3__/* .OptionsController */ .H.state.allowUnsupportedChain &&
            !_ConnectionController_js__WEBPACK_IMPORTED_MODULE_8__/* .ConnectionController */ .x.state.wcBasic) {
            ChainController.showUnsupportedChainUI();
        }
    },
    addCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
            return;
        }
        const chain = state.chains.get(caipNetwork.chainNamespace);
        if (chain) {
            chain?.caipNetworks?.push(caipNetwork);
        }
    },
    async switchActiveNamespace(namespace) {
        if (!namespace) {
            return;
        }
        const isDifferentChain = namespace !== ChainController.state.activeChain;
        const caipNetworkOfNamespace = ChainController.getNetworkData(namespace)?.caipNetwork;
        const firstNetworkWithChain = ChainController.getCaipNetworkByNamespace(namespace, caipNetworkOfNamespace?.id);
        if (isDifferentChain && firstNetworkWithChain) {
            await ChainController.switchActiveNetwork(firstNetworkWithChain);
        }
    },
    async switchActiveNetwork(network) {
        const activeAdapter = ChainController.state.chains.get(ChainController.state.activeChain);
        const unsupportedNetwork = !activeAdapter?.caipNetworks?.some(caipNetwork => caipNetwork.id === state.activeCaipNetwork?.id);
        const networkControllerClient = ChainController.getNetworkControllerClient(network.chainNamespace);
        if (networkControllerClient) {
            try {
                await networkControllerClient.switchCaipNetwork(network);
                if (unsupportedNetwork) {
                    _ModalController_js__WEBPACK_IMPORTED_MODULE_9__/* .ModalController */ .W.close();
                }
            }
            catch (error) {
                _RouterController_js__WEBPACK_IMPORTED_MODULE_10__/* .RouterController */ .I.goBack();
            }
            _EventsController_js__WEBPACK_IMPORTED_MODULE_11__/* .EventsController */ .E.sendEvent({
                type: 'track',
                event: 'SWITCH_NETWORK',
                properties: { network: network.caipNetworkId }
            });
        }
    },
    getNetworkControllerClient(chainNamespace) {
        const chain = chainNamespace || state.activeChain;
        const chainAdapter = state.chains.get(chain);
        if (!chainAdapter) {
            throw new Error('Chain adapter not found');
        }
        if (!chainAdapter.networkControllerClient) {
            throw new Error('NetworkController client not set');
        }
        return chainAdapter.networkControllerClient;
    },
    getConnectionControllerClient(_chain) {
        const chain = _chain || state.activeChain;
        if (!chain) {
            throw new Error('Chain is required to get connection controller client');
        }
        const chainAdapter = state.chains.get(chain);
        if (!chainAdapter?.connectionControllerClient) {
            throw new Error('ConnectionController client not set');
        }
        return chainAdapter.connectionControllerClient;
    },
    getAccountProp(key, _chain) {
        let chain = state.activeChain;
        if (_chain) {
            chain = _chain;
        }
        if (!chain) {
            return undefined;
        }
        const chainAccountState = state.chains.get(chain)?.accountState;
        if (!chainAccountState) {
            return undefined;
        }
        return chainAccountState[key];
    },
    getNetworkProp(key, namespace) {
        const chainNetworkState = state.chains.get(namespace)?.networkState;
        if (!chainNetworkState) {
            return undefined;
        }
        return chainNetworkState[key];
    },
    getRequestedCaipNetworks(chainToFilter) {
        const adapter = state.chains.get(chainToFilter);
        const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = adapter?.networkState || {};
        const sortedNetworks = _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_12__/* .CoreHelperUtil */ .w.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
        return sortedNetworks;
    },
    getAllRequestedCaipNetworks() {
        const requestedCaipNetworks = [];
        state.chains.forEach(chainAdapter => {
            const caipNetworks = ChainController.getRequestedCaipNetworks(chainAdapter.namespace);
            requestedCaipNetworks.push(...caipNetworks);
        });
        return requestedCaipNetworks;
    },
    setRequestedCaipNetworks(caipNetworks, chain) {
        ChainController.setAdapterNetworkState(chain, { requestedCaipNetworks: caipNetworks });
        const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
        const namespaces = allRequestedCaipNetworks.map(network => network.chainNamespace);
        const uniqueNamespaces = Array.from(new Set(namespaces));
        _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.filterByNamespaces(uniqueNamespaces);
    },
    getAllApprovedCaipNetworkIds() {
        const approvedCaipNetworkIds = [];
        state.chains.forEach(chainAdapter => {
            const approvedIds = ChainController.getApprovedCaipNetworkIds(chainAdapter.namespace);
            approvedCaipNetworkIds.push(...approvedIds);
        });
        return approvedCaipNetworkIds;
    },
    getActiveCaipNetwork() {
        return state.activeCaipNetwork;
    },
    getActiveCaipAddress() {
        return state.activeCaipAddress;
    },
    getApprovedCaipNetworkIds(namespace) {
        const adapter = state.chains.get(namespace);
        const approvedCaipNetworkIds = adapter?.networkState?.approvedCaipNetworkIds || [];
        return approvedCaipNetworkIds;
    },
    async setApprovedCaipNetworksData(namespace) {
        const networkControllerClient = ChainController.getNetworkControllerClient();
        const data = await networkControllerClient?.getApprovedCaipNetworksData();
        ChainController.setAdapterNetworkState(namespace, {
            approvedCaipNetworkIds: data?.approvedCaipNetworkIds,
            supportsAllNetworks: data?.supportsAllNetworks
        });
    },
    checkIfSupportedNetwork(namespace, caipNetwork) {
        const activeCaipNetwork = caipNetwork || state.activeCaipNetwork;
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(namespace);
        if (!requestedCaipNetworks.length) {
            return true;
        }
        return requestedCaipNetworks?.some(network => network.id === activeCaipNetwork?.id);
    },
    checkIfSupportedChainId(chainId) {
        if (!state.activeChain) {
            return true;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(state.activeChain);
        return requestedCaipNetworks?.some(network => network.id === chainId);
    },
    // Smart Account Network Handlers
    setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
        ChainController.setAdapterNetworkState(chain, { smartAccountEnabledNetworks });
    },
    checkIfSmartAccountEnabled() {
        const networkId = _reown_appkit_common__WEBPACK_IMPORTED_MODULE_13__/* .NetworkUtil */ .L.caipNetworkIdToNumber(state.activeCaipNetwork?.caipNetworkId);
        const activeChain = state.activeChain;
        if (!activeChain || !networkId) {
            return false;
        }
        const smartAccountEnabledNetworks = ChainController.getNetworkProp('smartAccountEnabledNetworks', activeChain);
        return Boolean(smartAccountEnabledNetworks?.includes(Number(networkId)));
    },
    getActiveNetworkTokenAddress() {
        const namespace = state.activeCaipNetwork?.chainNamespace || 'eip155';
        const chainId = state.activeCaipNetwork?.id || 1;
        const address = _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_14__/* .ConstantsUtil */ .oU.NATIVE_TOKEN_ADDRESS[namespace];
        return `${namespace}:${chainId}:${address}`;
    },
    showUnsupportedChainUI() {
        _ModalController_js__WEBPACK_IMPORTED_MODULE_9__/* .ModalController */ .W.open({ view: 'UnsupportedChain' });
    },
    checkIfNamesSupported() {
        const activeCaipNetwork = state.activeCaipNetwork;
        return Boolean(activeCaipNetwork?.chainNamespace &&
            _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_14__/* .ConstantsUtil */ .oU.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
    },
    resetNetwork(namespace) {
        ChainController.setAdapterNetworkState(namespace, {
            approvedCaipNetworkIds: undefined,
            supportsAllNetworks: true,
            smartAccountEnabledNetworks: []
        });
    },
    resetAccount(chain) {
        const chainToWrite = chain;
        if (!chainToWrite) {
            throw new Error('Chain is required to set account prop');
        }
        state.activeCaipAddress = undefined;
        ChainController.setChainAccountData(chainToWrite, {
            smartAccountDeployed: false,
            currentTab: 0,
            caipAddress: undefined,
            address: undefined,
            balance: undefined,
            balanceSymbol: undefined,
            profileName: undefined,
            profileImage: undefined,
            addressExplorerUrl: undefined,
            tokenBalance: [],
            connectedWalletInfo: undefined,
            preferredAccountTypes: undefined,
            socialProvider: undefined,
            socialWindow: undefined,
            farcasterUrl: undefined,
            allAccounts: [],
            user: undefined,
            status: 'disconnected'
        });
        _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.removeConnectorId(chainToWrite);
    },
    setIsSwitchingNamespace(isSwitchingNamespace) {
        state.isSwitchingNamespace = isSwitchingNamespace;
    },
    getFirstCaipNetworkSupportsAuthConnector() {
        const availableChains = [];
        let firstCaipNetwork = undefined;
        state.chains.forEach(chain => {
            if (_reown_appkit_common__WEBPACK_IMPORTED_MODULE_15__/* .ConstantsUtil */ .o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(ns => ns === chain.namespace)) {
                if (chain.namespace) {
                    availableChains.push(chain.namespace);
                }
            }
        });
        if (availableChains.length > 0) {
            const firstAvailableChain = availableChains[0];
            firstCaipNetwork = firstAvailableChain
                ? state.chains.get(firstAvailableChain)?.caipNetworks?.[0]
                : undefined;
            return firstCaipNetwork;
        }
        return undefined;
    },
    getAccountData(chainNamespace) {
        if (!chainNamespace) {
            return _AccountController_js__WEBPACK_IMPORTED_MODULE_6__/* .AccountController */ .U.state;
        }
        return ChainController.state.chains.get(chainNamespace)?.accountState;
    },
    getNetworkData(chainNamespace) {
        const namespace = chainNamespace || state.activeChain;
        if (!namespace) {
            return undefined;
        }
        return ChainController.state.chains.get(namespace)?.networkState;
    },
    getCaipNetworkByNamespace(chainNamespace, chainId) {
        if (!chainNamespace) {
            return undefined;
        }
        const chain = ChainController.state.chains.get(chainNamespace);
        const byChainId = chain?.caipNetworks?.find(network => network.id === chainId);
        if (byChainId) {
            return byChainId;
        }
        return chain?.networkState?.caipNetwork || chain?.caipNetworks?.[0];
    },
    /**
     * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned
     * @param namespace - The namespace to get the requested CaipNetwork IDs for
     * @returns The requested CaipNetwork IDs
     */
    getRequestedCaipNetworkIds() {
        const namespace = _ConnectorController_js__WEBPACK_IMPORTED_MODULE_5__/* .ConnectorController */ .a.state.filterByNamespace;
        const chains = namespace ? [state.chains.get(namespace)] : Array.from(state.chains.values());
        return chains
            .flatMap(chain => chain?.caipNetworks || [])
            .map(caipNetwork => caipNetwork.caipNetworkId);
    },
    getCaipNetworks(namespace) {
        if (namespace) {
            return ChainController.getRequestedCaipNetworks(namespace);
        }
        return ChainController.getAllRequestedCaipNetworks();
    }
};
// Export the controller wrapped with our error boundary
const ChainController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_16__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=ChainController.js.map

/***/ }),

/***/ 824376:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ ConstantsUtil)
/* harmony export */ });
const ConstantsUtil = {
    WC_NAME_SUFFIX: '.reown.id',
    WC_NAME_SUFFIX_LEGACY: '.wcn.id',
    BLOCKCHAIN_API_RPC_URL: 'https://rpc.walletconnect.org',
    PULSE_API_URL: 'https://pulse.walletconnect.org',
    W3M_API_URL: 'https://api.web3modal.org',
    CONNECTOR_ID: {
        WALLET_CONNECT: 'walletConnect',
        INJECTED: 'injected',
        WALLET_STANDARD: 'announced',
        COINBASE: 'coinbaseWallet',
        COINBASE_SDK: 'coinbaseWalletSDK',
        SAFE: 'safe',
        LEDGER: 'ledger',
        OKX: 'okx',
        EIP6963: 'eip6963',
        AUTH: 'ID_AUTH'
    },
    CONNECTOR_NAMES: {
        AUTH: 'Auth'
    },
    AUTH_CONNECTOR_SUPPORTED_CHAINS: ['eip155', 'solana'],
    LIMITS: {
        PENDING_TRANSACTIONS: 99
    },
    CHAIN: {
        EVM: 'eip155',
        SOLANA: 'solana',
        POLKADOT: 'polkadot',
        BITCOIN: 'bip122'
    },
    CHAIN_NAME_MAP: {
        eip155: 'EVM Networks',
        solana: 'Solana',
        polkadot: 'Polkadot',
        bip122: 'Bitcoin',
        cosmos: 'Cosmos'
    },
    ADAPTER_TYPES: {
        BITCOIN: 'bitcoin',
        SOLANA: 'solana',
        WAGMI: 'wagmi',
        ETHERS: 'ethers',
        ETHERS5: 'ethers5'
    },
    USDT_CONTRACT_ADDRESSES: [
        '0xdac17f958d2ee523a2206206994597c13d831ec7',
        '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
        '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
        '0x919C1c267BC06a7039e03fcc2eF738525769109c',
        '0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e',
        '0x55d398326f99059fF775485246999027B3197955',
        '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'
    ],
    HTTP_STATUS_CODES: {
        SERVICE_UNAVAILABLE: 503,
        FORBIDDEN: 403
    },
    UNSUPPORTED_NETWORK_NAME: 'Unknown Network',
    SECURE_SITE_SDK_ORIGIN: (typeof process !== 'undefined' && typeof process.env !== 'undefined'
        ? process.env['NEXT_PUBLIC_SECURE_SITE_ORIGIN']
        : undefined) || 'https://secure.walletconnect.org'
};
//# sourceMappingURL=ConstantsUtil.js.map

/***/ }),

/***/ 841482:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ ConstantsUtil)
/* harmony export */ });
const ConstantsUtil = {
    ACCOUNT_TABS: [{ label: 'Tokens' }, { label: 'NFTs' }, { label: 'Activity' }],
    SECURE_SITE_ORIGIN: (typeof process !== 'undefined' && typeof process.env !== 'undefined'
        ? process.env['NEXT_PUBLIC_SECURE_SITE_ORIGIN']
        : undefined) || 'https://secure.walletconnect.org',
    VIEW_DIRECTION: {
        Next: 'next',
        Prev: 'prev'
    },
    DEFAULT_CONNECT_METHOD_ORDER: ['email', 'social', 'wallet'],
    ANIMATION_DURATIONS: {
        HeaderText: 120,
        ModalHeight: 150,
        ViewTransition: 150
    }
};
//# sourceMappingURL=ConstantsUtil.js.map

/***/ }),

/***/ 853581:
/***/ (function(module) {

!function(e,n){ true?module.exports=n():0}(this,(function(){"use strict";return function(e,n,t){t.updateLocale=function(e,n){var o=t.Ls[e];if(o)return(n?Object.keys(n):[]).forEach((function(e){o[e]=n[e]})),o}}}));

/***/ }),

/***/ 853895:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createAppKit: () => (/* binding */ createAppKit)
});

// UNUSED EXPORTS: AppKit

// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var ConnectorController = __webpack_require__(236010);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js + 1 modules
var ConnectionController = __webpack_require__(627987);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js + 1 modules
var OptionsController = __webpack_require__(500026);
// EXTERNAL MODULE: ./node_modules/@walletconnect/universal-provider/dist/index.es.js + 25 modules
var index_es = __webpack_require__(155500);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = __webpack_require__(824376);
;// ./node_modules/@reown/appkit-common/dist/esm/src/utils/ParseUtil.js
const ParseUtil = {
    validateCaipAddress(address) {
        if (address.split(':')?.length !== 3) {
            throw new Error('Invalid CAIP Address');
        }
        return address;
    },
    parseCaipAddress(caipAddress) {
        const parts = caipAddress.split(':');
        if (parts.length !== 3) {
            throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
        }
        const [chainNamespace, chainId, address] = parts;
        if (!chainNamespace || !chainId || !address) {
            throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
        }
        return {
            chainNamespace: chainNamespace,
            chainId: chainId,
            address
        };
    },
    parseCaipNetworkId(caipNetworkId) {
        const parts = caipNetworkId.split(':');
        if (parts.length !== 2) {
            throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
        }
        const [chainNamespace, chainId] = parts;
        if (!chainNamespace || !chainId) {
            throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
        }
        return {
            chainNamespace: chainNamespace,
            chainId: chainId
        };
    }
};
//# sourceMappingURL=ParseUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-common/dist/esm/src/utils/NetworkUtil.js
var NetworkUtil = __webpack_require__(173495);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var ChainController = __webpack_require__(806056);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var BlockchainApiController = __webpack_require__(775595);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var AccountController = __webpack_require__(863450);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js
var StorageUtil = __webpack_require__(127508);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
const SLIP44_MSB = 0x80000000;
const EnsUtil = {
    convertEVMChainIdToCoinType(chainId) {
        if (chainId >= SLIP44_MSB) {
            throw new Error('Invalid chainId');
        }
        return (SLIP44_MSB | chainId) >>> 0;
    }
};
//# sourceMappingURL=EnsUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js + 1 modules
var withErrorBoundary = __webpack_require__(923082);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var RouterController = __webpack_require__(778508);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js











// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    suggestions: [],
    loading: false
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(state, () => callback(state));
    },
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(state, key, callback);
    },
    async resolveName(name) {
        try {
            return await BlockchainApiController/* BlockchainApiController */.T.lookupEnsName(name);
        }
        catch (e) {
            const error = e;
            throw new Error(error?.reasons?.[0]?.description || 'Error resolving name');
        }
    },
    async isNameRegistered(name) {
        try {
            await BlockchainApiController/* BlockchainApiController */.T.lookupEnsName(name);
            return true;
        }
        catch {
            return false;
        }
    },
    async getSuggestions(value) {
        try {
            state.loading = true;
            state.suggestions = [];
            const response = await BlockchainApiController/* BlockchainApiController */.T.getEnsNameSuggestions(value);
            state.suggestions =
                response.suggestions.map(suggestion => ({
                    ...suggestion,
                    name: suggestion.name
                })) || [];
            return state.suggestions;
        }
        catch (e) {
            const errorMessage = EnsController.parseEnsApiError(e, 'Error fetching name suggestions');
            throw new Error(errorMessage);
        }
        finally {
            state.loading = false;
        }
    },
    async getNamesForAddress(address) {
        try {
            const network = ChainController/* ChainController */.W.state.activeCaipNetwork;
            if (!network) {
                return [];
            }
            const cachedEns = StorageUtil/* StorageUtil */.i.getEnsFromCacheForAddress(address);
            if (cachedEns) {
                return cachedEns;
            }
            const response = await BlockchainApiController/* BlockchainApiController */.T.reverseLookupEnsName({ address });
            StorageUtil/* StorageUtil */.i.updateEnsCache({
                address,
                ens: response,
                timestamp: Date.now()
            });
            return response;
        }
        catch (e) {
            const errorMessage = EnsController.parseEnsApiError(e, 'Error fetching names for address');
            throw new Error(errorMessage);
        }
    },
    async registerName(name) {
        const network = ChainController/* ChainController */.W.state.activeCaipNetwork;
        if (!network) {
            throw new Error('Network not found');
        }
        const address = AccountController/* AccountController */.U.state.address;
        const emailConnector = ConnectorController/* ConnectorController */.a.getAuthConnector();
        if (!address || !emailConnector) {
            throw new Error('Address or auth connector not found');
        }
        state.loading = true;
        try {
            const message = JSON.stringify({
                name,
                attributes: {},
                // Unix timestamp
                timestamp: Math.floor(Date.now() / 1000)
            });
            RouterController/* RouterController */.I.pushTransactionStack({
                onCancel() {
                    RouterController/* RouterController */.I.replace('RegisterAccountName');
                }
            });
            const signature = await ConnectionController/* ConnectionController */.x.signMessage(message);
            state.loading = false;
            const networkId = network.id;
            if (!networkId) {
                throw new Error('Network not found');
            }
            const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
            await BlockchainApiController/* BlockchainApiController */.T.registerEnsName({
                coinType,
                address: address,
                signature: signature,
                message
            });
            AccountController/* AccountController */.U.setProfileName(name, network.chainNamespace);
            RouterController/* RouterController */.I.replace('RegisterAccountNameSuccess');
        }
        catch (e) {
            const errorMessage = EnsController.parseEnsApiError(e, `Error registering name ${name}`);
            RouterController/* RouterController */.I.replace('RegisterAccountName');
            throw new Error(errorMessage);
        }
        finally {
            state.loading = false;
        }
    },
    validateName(name) {
        return /^[a-zA-Z0-9-]{4,}$/u.test(name);
    },
    parseEnsApiError(error, defaultError) {
        const ensError = error;
        return ensError?.reasons?.[0]?.description || defaultError;
    }
};
// Export the controller wrapped with our error boundary
const EnsController = (0,withErrorBoundary/* withErrorBoundary */.X)(controller);
//# sourceMappingURL=EnsController.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js
var AssetUtil = __webpack_require__(527601);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var utils_ConstantsUtil = __webpack_require__(562944);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var ApiController = __webpack_require__(188249);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js










const USDC_CURRENCY_DEFAULT = {
    id: '2b92315d-eab7-5bef-84fa-089a131333f5',
    name: 'USD Coin',
    symbol: 'USDC',
    networks: [
        {
            name: 'ethereum-mainnet',
            display_name: 'Ethereum',
            chain_id: '1',
            contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
        },
        {
            name: 'polygon-mainnet',
            display_name: 'Polygon',
            chain_id: '137',
            contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
        }
    ]
};
const USD_CURRENCY_DEFAULT = {
    id: 'USD',
    payment_method_limits: [
        {
            id: 'card',
            min: '10.00',
            max: '7500.00'
        },
        {
            id: 'ach_bank_account',
            min: '10.00',
            max: '25000.00'
        }
    ]
};
const defaultState = {
    providers: utils_ConstantsUtil/* ONRAMP_PROVIDERS */.tM,
    selectedProvider: null,
    error: null,
    purchaseCurrency: USDC_CURRENCY_DEFAULT,
    paymentCurrency: USD_CURRENCY_DEFAULT,
    purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
    paymentCurrencies: [],
    quotesLoading: false
};
// -- State --------------------------------------------- //
const OnRampController_state = (0,vanilla/* proxy */.BX)(defaultState);
// -- Controller ---------------------------------------- //
const OnRampController_controller = {
    state: OnRampController_state,
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(OnRampController_state, () => callback(OnRampController_state));
    },
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(OnRampController_state, key, callback);
    },
    setSelectedProvider(provider) {
        if (provider && provider.name === 'meld') {
            const currency = ChainController/* ChainController */.W.state.activeChain === ConstantsUtil/* ConstantsUtil */.o.CHAIN.SOLANA ? 'SOL' : 'USDC';
            const address = AccountController/* AccountController */.U.state.address ?? '';
            const url = new URL(provider.url);
            url.searchParams.append('publicKey', utils_ConstantsUtil/* MELD_PUBLIC_KEY */.Db);
            url.searchParams.append('destinationCurrencyCode', currency);
            url.searchParams.append('walletAddress', address);
            url.searchParams.append('externalCustomerId', OptionsController/* OptionsController */.H.state.projectId);
            OnRampController_state.selectedProvider = { ...provider, url: url.toString() };
        }
        else {
            OnRampController_state.selectedProvider = provider;
        }
    },
    setOnrampProviders(providers) {
        if (Array.isArray(providers) && providers.every(item => typeof item === 'string')) {
            const validOnramp = providers;
            const newProviders = utils_ConstantsUtil/* ONRAMP_PROVIDERS */.tM.filter(provider => validOnramp.includes(provider.name));
            OnRampController_state.providers = newProviders;
        }
        else {
            OnRampController_state.providers = [];
        }
    },
    setPurchaseCurrency(currency) {
        OnRampController_state.purchaseCurrency = currency;
    },
    setPaymentCurrency(currency) {
        OnRampController_state.paymentCurrency = currency;
    },
    setPurchaseAmount(amount) {
        OnRampController.state.purchaseAmount = amount;
    },
    setPaymentAmount(amount) {
        OnRampController.state.paymentAmount = amount;
    },
    async getAvailableCurrencies() {
        const options = await BlockchainApiController/* BlockchainApiController */.T.getOnrampOptions();
        OnRampController_state.purchaseCurrencies = options.purchaseCurrencies;
        OnRampController_state.paymentCurrencies = options.paymentCurrencies;
        OnRampController_state.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
        OnRampController_state.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
        await ApiController/* ApiController */.N.fetchCurrencyImages(options.paymentCurrencies.map(currency => currency.id));
        await ApiController/* ApiController */.N.fetchTokenImages(options.purchaseCurrencies.map(currency => currency.symbol));
    },
    async getQuote() {
        OnRampController_state.quotesLoading = true;
        try {
            const quote = await BlockchainApiController/* BlockchainApiController */.T.getOnrampQuote({
                purchaseCurrency: OnRampController_state.purchaseCurrency,
                paymentCurrency: OnRampController_state.paymentCurrency,
                amount: OnRampController_state.paymentAmount?.toString() || '0',
                network: OnRampController_state.purchaseCurrency?.symbol
            });
            OnRampController_state.quotesLoading = false;
            OnRampController_state.purchaseAmount = Number(quote?.purchaseAmount.amount);
            return quote;
        }
        catch (error) {
            OnRampController_state.error = error.message;
            OnRampController_state.quotesLoading = false;
            return null;
        }
        finally {
            OnRampController_state.quotesLoading = false;
        }
    },
    resetState() {
        OnRampController_state.selectedProvider = null;
        OnRampController_state.error = null;
        OnRampController_state.purchaseCurrency = USDC_CURRENCY_DEFAULT;
        OnRampController_state.paymentCurrency = USD_CURRENCY_DEFAULT;
        OnRampController_state.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
        OnRampController_state.paymentCurrencies = [];
        OnRampController_state.paymentAmount = undefined;
        OnRampController_state.purchaseAmount = undefined;
        OnRampController_state.quotesLoading = false;
    }
};
// Export the controller wrapped with our error boundary
const OnRampController = (0,withErrorBoundary/* withErrorBoundary */.X)(OnRampController_controller);
//# sourceMappingURL=OnRampController.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js
var AlertController = __webpack_require__(471655);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var EventsController = __webpack_require__(390184);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ThemeController.js
var ThemeController = __webpack_require__(568996);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js + 8 modules
var SendController = __webpack_require__(792968);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js
var SIWXUtil = __webpack_require__(801122);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js + 1 modules
var ModalController = __webpack_require__(91111);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js
var PublicStateController = __webpack_require__(698467);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var SnackController = __webpack_require__(121871);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js

/**
 * Checks if the given namespace is associated with the specified connector id.
 * @param namespace - The namespace to check.
 * @param connectorId - The connector id to compare against.
 * @returns True if the namespace is associated with the connector id, false otherwise.
 */
function checkNamespaceConnectorId(namespace, connectorId) {
    return ConnectorController/* ConnectorController */.a.getConnectorId(namespace) === connectorId;
}
//# sourceMappingURL=ConnectorControllerUtil.js.map
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js



/**
 * Returns the array of chains to disconnect from the connector with the given namespace.
 * If no namespace is provided, it returns all chains.
 * @param namespace - The namespace of the connector to disconnect from.
 * @returns An array of chains to disconnect.
 */
function getChainsToDisconnect(namespace) {
    const namespaces = Array.from(ChainController/* ChainController */.W.state.chains.keys());
    let chains = [];
    if (namespace) {
        chains.push([namespace, ChainController/* ChainController */.W.state.chains.get(namespace)]);
        if (checkNamespaceConnectorId(namespace, ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT)) {
            namespaces.forEach(ns => {
                if (ns !== namespace &&
                    checkNamespaceConnectorId(ns, ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT)) {
                    chains.push([ns, ChainController/* ChainController */.W.state.chains.get(ns)]);
                }
            });
        }
        else if (checkNamespaceConnectorId(namespace, ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH)) {
            namespaces.forEach(ns => {
                if (ns !== namespace &&
                    checkNamespaceConnectorId(ns, ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH)) {
                    chains.push([ns, ChainController/* ChainController */.W.state.chains.get(ns)]);
                }
            });
        }
    }
    else {
        chains = Array.from(ChainController/* ChainController */.W.state.chains.entries());
    }
    return chains;
}
//# sourceMappingURL=ChainControllerUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConnectorUtil.js
var ConnectorUtil = __webpack_require__(56092);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var src_utils_ConstantsUtil = __webpack_require__(841482);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js
var WalletUtil = __webpack_require__(665042);
;// ./node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/utils.js



//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-ui/dist/esm/exports/index.js + 3 modules
var esm_exports = __webpack_require__(441454);
;// ./node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js
const abortController = new AbortController();
const ErrorUtil = {
    EmbeddedWalletAbortController: abortController,
    UniversalProviderErrors: {
        UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: 'Unauthorized: origin not allowed',
            alertErrorKey: 'INVALID_APP_CONFIGURATION'
        },
        JWT_VALIDATION_ERROR: {
            message: 'JWT validation error: JWT Token is not yet valid',
            alertErrorKey: 'JWT_TOKEN_NOT_VALID'
        },
        INVALID_KEY: {
            message: 'Unauthorized: invalid key',
            alertErrorKey: 'INVALID_PROJECT_ID'
        }
    },
    ALERT_ERRORS: {
        SWITCH_NETWORK_NOT_FOUND: {
            shortMessage: 'Network Not Found',
            longMessage: "Network not found - please make sure it is included in 'networks' array in createAppKit function"
        },
        INVALID_APP_CONFIGURATION: {
            shortMessage: 'Invalid App Configuration',
            longMessage: () => `Origin ${isSafe() ? window.origin : 'unknown'} not found on Allowlist - update configuration on cloud.reown.com`
        },
        IFRAME_LOAD_FAILED: {
            shortMessage: 'Network Error - Could not load embedded wallet',
            longMessage: () => 'There was an issue loading the embedded wallet. Please try again later.'
        },
        IFRAME_REQUEST_TIMEOUT: {
            shortMessage: 'Embedded Wallet Request Timed Out',
            longMessage: () => 'There was an issue doing the request to the embedded wallet. Please try again later.'
        },
        UNVERIFIED_DOMAIN: {
            shortMessage: 'Invalid App Configuration',
            longMessage: () => 'There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com'
        },
        JWT_TOKEN_NOT_VALID: {
            shortMessage: 'Session Expired',
            longMessage: 'Invalid session found on UniversalProvider - please check your time settings and connect again'
        },
        INVALID_PROJECT_ID: {
            shortMessage: 'Invalid App Configuration',
            longMessage: 'Invalid Project ID - update configuration'
        },
        PROJECT_ID_NOT_CONFIGURED: {
            shortMessage: 'Project ID Not Configured',
            longMessage: 'Project ID Not Configured - update configuration on cloud.reown.com'
        }
    }
};
function isSafe() {
    return typeof window !== 'undefined';
}
//# sourceMappingURL=ErrorUtil.js.map
// EXTERNAL MODULE: ./node_modules/viem/_esm/clients/transports/http.js + 4 modules
var http = __webpack_require__(12406);
// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/node.js
var node = __webpack_require__(92592);
// EXTERNAL MODULE: ./node_modules/viem/_esm/errors/rpc.js
var rpc = __webpack_require__(727513);
// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/wait.js
var wait = __webpack_require__(150669);
// EXTERNAL MODULE: ./node_modules/viem/_esm/clients/transports/createTransport.js + 2 modules
var createTransport = __webpack_require__(964539);
;// ./node_modules/viem/_esm/clients/transports/fallback.js




function fallback(transports_, config = {}) {
    const { key = 'fallback', name = 'Fallback', rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay, } = config;
    return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {
        let transports = transports_;
        let onResponse = () => { };
        const transport = (0,createTransport/* createTransport */.o)({
            key,
            name,
            async request({ method, params }) {
                let includes;
                const fetch = async (i = 0) => {
                    const transport = transports[i]({
                        ...rest,
                        chain,
                        retryCount: 0,
                        timeout,
                    });
                    try {
                        const response = await transport.request({
                            method,
                            params,
                        });
                        onResponse({
                            method,
                            params: params,
                            response,
                            transport,
                            status: 'success',
                        });
                        return response;
                    }
                    catch (err) {
                        onResponse({
                            error: err,
                            method,
                            params: params,
                            transport,
                            status: 'error',
                        });
                        if (shouldThrow_(err))
                            throw err;
                        // If we've reached the end of the fallbacks, throw the error.
                        if (i === transports.length - 1)
                            throw err;
                        // Check if at least one other transport includes the method
                        includes ??= transports.slice(i + 1).some((transport) => {
                            const { include, exclude } = transport({ chain }).config.methods || {};
                            if (include)
                                return include.includes(method);
                            if (exclude)
                                return !exclude.includes(method);
                            return true;
                        });
                        if (!includes)
                            throw err;
                        // Otherwise, try the next fallback.
                        return fetch(i + 1);
                    }
                };
                return fetch();
            },
            retryCount,
            retryDelay,
            type: 'fallback',
        }, {
            onResponse: (fn) => (onResponse = fn),
            transports: transports.map((fn) => fn({ chain, retryCount: 0 })),
        });
        if (rank) {
            const rankOptions = (typeof rank === 'object' ? rank : {});
            rankTransports({
                chain,
                interval: rankOptions.interval ?? pollingInterval,
                onTransports: (transports_) => (transports = transports_),
                ping: rankOptions.ping,
                sampleCount: rankOptions.sampleCount,
                timeout: rankOptions.timeout,
                transports,
                weights: rankOptions.weights,
            });
        }
        return transport;
    });
}
function shouldThrow(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === rpc/* TransactionRejectedRpcError */.YW.code ||
            error.code === rpc/* UserRejectedRequestError */.vx.code ||
            node/* ExecutionRevertedError */.A7.nodeMessage.test(error.message) ||
            error.code === 5000 // CAIP UserRejectedRequestError
        )
            return true;
    }
    return false;
}
/** @internal */
function rankTransports({ chain, interval = 4_000, onTransports, ping, sampleCount = 10, timeout = 1_000, transports, weights = {}, }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
        // 1. Take a sample from each Transport.
        const sample = await Promise.all(transports.map(async (transport) => {
            const transport_ = transport({ chain, retryCount: 0, timeout });
            const start = Date.now();
            let end;
            let success;
            try {
                await (ping
                    ? ping({ transport: transport_ })
                    : transport_.request({ method: 'net_listening' }));
                success = 1;
            }
            catch {
                success = 0;
            }
            finally {
                end = Date.now();
            }
            const latency = end - start;
            return { latency, success };
        }));
        // 2. Store the sample. If we have more than `sampleCount` samples, remove
        // the oldest sample.
        samples.push(sample);
        if (samples.length > sampleCount)
            samples.shift();
        // 3. Calculate the max latency from samples.
        const maxLatency = Math.max(...samples.map((sample) => Math.max(...sample.map(({ latency }) => latency))));
        // 4. Calculate the score for each Transport.
        const scores = transports
            .map((_, i) => {
            const latencies = samples.map((sample) => sample[i].latency);
            const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) /
                latencies.length;
            const latencyScore = 1 - meanLatency / maxLatency;
            const successes = samples.map((sample) => sample[i].success);
            const stabilityScore = successes.reduce((acc, success) => acc + success, 0) /
                successes.length;
            if (stabilityScore === 0)
                return [0, i];
            return [
                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
                i,
            ];
        })
            .sort((a, b) => b[0] - a[0]);
        // 5. Sort the Transports by score.
        onTransports(scores.map(([, i]) => transports[i]));
        // 6. Wait, and then rank again.
        await (0,wait/* wait */.u)(interval);
        rankTransports_();
    };
    rankTransports_();
}
//# sourceMappingURL=fallback.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js
var src_ConstantsUtil = __webpack_require__(669510);
;// ./node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js


const PresetsUtil = {
    ConnectorExplorerIds: {
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE]: 'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE_SDK]: 'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.SAFE]: '225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.LEDGER]: '19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.OKX]: '971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709',
        [src_ConstantsUtil/* ConstantsUtil */.o.METMASK_CONNECTOR_NAME]: 'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96',
        [src_ConstantsUtil/* ConstantsUtil */.o.TRUST_CONNECTOR_NAME]: '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0',
        [src_ConstantsUtil/* ConstantsUtil */.o.SOLFLARE_CONNECTOR_NAME]: '1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79',
        [src_ConstantsUtil/* ConstantsUtil */.o.PHANTOM_CONNECTOR_NAME]: 'a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393',
        [src_ConstantsUtil/* ConstantsUtil */.o.COIN98_CONNECTOR_NAME]: '2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01',
        [src_ConstantsUtil/* ConstantsUtil */.o.MAGIC_EDEN_CONNECTOR_NAME]: '8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6',
        [src_ConstantsUtil/* ConstantsUtil */.o.BACKPACK_CONNECTOR_NAME]: '2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0',
        [src_ConstantsUtil/* ConstantsUtil */.o.BITGET_CONNECTOR_NAME]: '38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662',
        [src_ConstantsUtil/* ConstantsUtil */.o.FRONTIER_CONNECTOR_NAME]: '85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041',
        [src_ConstantsUtil/* ConstantsUtil */.o.XVERSE_CONNECTOR_NAME]: '2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b',
        [src_ConstantsUtil/* ConstantsUtil */.o.LEATHER_CONNECTOR_NAME]: '483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13'
    },
    NetworkImageIds: {
        1: 'ba0ba0cd-17c6-4806-ad93-f9d174f17900',
        42161: '3bff954d-5cb0-47a0-9a23-d20192e74600',
        43114: '30c46e53-e989-45fb-4549-be3bd4eb3b00',
        56: '93564157-2e8e-4ce7-81df-b264dbee9b00',
        250: '06b26297-fe0c-4733-5d6b-ffa5498aac00',
        10: 'ab9c186a-c52f-464b-2906-ca59d760a400',
        137: '41d04d42-da3b-4453-8506-668cc0727900',
        5000: 'e86fae9b-b770-4eea-e520-150e12c81100',
        295: '6a97d510-cac8-4e58-c7ce-e8681b044c00',
        11_155_111: 'e909ea0a-f92a-4512-c8fc-748044ea6800',
        84532: 'a18a7ecd-e307-4360-4746-283182228e00',
        1301: '4eeea7ef-0014-4649-5d1d-07271a80f600',
        130: '2257980a-3463-48c6-cbac-a42d2a956e00',
        10_143: '0a728e83-bacb-46db-7844-948f05434900',
        100: '02b53f6a-e3d4-479e-1cb4-21178987d100',
        9001: 'f926ff41-260d-4028-635e-91913fc28e00',
        324: 'b310f07f-4ef7-49f3-7073-2a0a39685800',
        314: '5a73b3dd-af74-424e-cae0-0de859ee9400',
        4689: '34e68754-e536-40da-c153-6ef2e7188a00',
        1088: '3897a66d-40b9-4833-162f-a2c90531c900',
        1284: '161038da-44ae-4ec7-1208-0ea569454b00',
        1285: 'f1d73bb6-5450-4e18-38f7-fb6484264a00',
        7777777: '845c60df-d429-4991-e687-91ae45791600',
        42220: 'ab781bbc-ccc6-418d-d32d-789b15da1f00',
        8453: '7289c336-3981-4081-c5f4-efc26ac64a00',
        1313161554: '3ff73439-a619-4894-9262-4470c773a100',
        2020: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
        2021: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
        80094: 'e329c2c9-59b0-4a02-83e4-212ff3779900',
        2741: 'fc2427d1-5af9-4a9c-8da5-6f94627cd900',
        '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
        '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
        EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 'a1b58899-f671-4276-6a5e-56ca5bd59700',
        '000000000019d6689c085ae165831e93': '0b4838db-0161-4ffe-022d-532bf03dba00',
        '000000000933ea01ad0ee984209779ba': '39354064-d79b-420b-065d-f980c4b78200'
    },
    ConnectorImageIds: {
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE_SDK]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.SAFE]: '461db637-8616-43ce-035a-d89b8a1d5800',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.LEDGER]: '54a1aa77-d202-4f8d-0fb2-5d2bb6db0300',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT]: 'ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.INJECTED]: '07ba87ed-43aa-4adf-4540-9e6a2b9cae00'
    },
    ConnectorNamesMap: {
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.INJECTED]: 'Browser Wallet',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT]: 'WalletConnect',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE]: 'Coinbase',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE_SDK]: 'Coinbase',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.LEDGER]: 'Ledger',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.SAFE]: 'Safe'
    },
    ConnectorTypesMap: {
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.INJECTED]: 'INJECTED',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT]: 'WALLET_CONNECT',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.EIP6963]: 'ANNOUNCED',
        [ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH]: 'AUTH'
    },
    WalletConnectRpcChainIds: [
        1,
        5,
        11155111,
        10,
        420,
        42161,
        421613,
        137,
        80001,
        42220,
        1313161554,
        1313161555,
        56,
        97,
        43114,
        43113,
        100,
        8453,
        84531,
        7777777,
        999,
        324,
        280
    ]
};
//# sourceMappingURL=PresetsUtil.js.map
;// ./node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js




const RPC_URL_HOST = 'rpc.walletconnect.org';
function getBlockchainApiRpcUrl(caipNetworkId, projectId) {
    const url = new URL('https://rpc.walletconnect.org/v1/');
    url.searchParams.set('chainId', caipNetworkId);
    url.searchParams.set('projectId', projectId);
    return url.toString();
}
const WC_HTTP_RPC_SUPPORTED_CHAINS = [
    'near:mainnet',
    'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    'eip155:1101',
    'eip155:56',
    'eip155:42161',
    'eip155:7777777',
    'eip155:59144',
    'eip155:324',
    'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    'eip155:5000',
    'solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz',
    'eip155:80084',
    'eip155:5003',
    'eip155:100',
    'eip155:8453',
    'eip155:42220',
    'eip155:1313161555',
    'eip155:17000',
    'eip155:1',
    'eip155:300',
    'eip155:1313161554',
    'eip155:1329',
    'eip155:84532',
    'eip155:421614',
    'eip155:11155111',
    'eip155:8217',
    'eip155:43114',
    'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    'eip155:999999999',
    'eip155:11155420',
    'eip155:80002',
    'eip155:97',
    'eip155:43113',
    'eip155:137',
    'eip155:10',
    'eip155:1301',
    'bip122:000000000019d6689c085ae165831e93',
    'bip122:000000000933ea01ad0ee984209779ba'
];
const CaipNetworksUtil = {
    extendRpcUrlWithProjectId(rpcUrl, projectId) {
        let isReownUrl = false;
        try {
            const url = new URL(rpcUrl);
            isReownUrl = url.host === RPC_URL_HOST;
        }
        catch (e) {
            isReownUrl = false;
        }
        if (isReownUrl) {
            const url = new URL(rpcUrl);
            if (!url.searchParams.has('projectId')) {
                url.searchParams.set('projectId', projectId);
            }
            return url.toString();
        }
        return rpcUrl;
    },
    isCaipNetwork(network) {
        return 'chainNamespace' in network && 'caipNetworkId' in network;
    },
    getChainNamespace(network) {
        if (this.isCaipNetwork(network)) {
            return network.chainNamespace;
        }
        return ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM;
    },
    getCaipNetworkId(network) {
        if (this.isCaipNetwork(network)) {
            return network.caipNetworkId;
        }
        return `${ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM}:${network.id}`;
    },
    getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId) {
        const defaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetworkId)) {
            return getBlockchainApiRpcUrl(caipNetworkId, projectId);
        }
        return defaultRpcUrl || '';
    },
    extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId, customRpcUrls }) {
        const chainNamespace = this.getChainNamespace(caipNetwork);
        const caipNetworkId = this.getCaipNetworkId(caipNetwork);
        const networkDefaultRpcUrl = caipNetwork.rpcUrls.default.http?.[0];
        const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId);
        const chainDefaultRpcUrl = caipNetwork?.rpcUrls?.['chainDefault']?.http?.[0] || networkDefaultRpcUrl;
        const customRpcUrlsOfNetwork = customRpcUrls?.[caipNetworkId]?.map(i => i.url) || [];
        const rpcUrls = [...customRpcUrlsOfNetwork, reownRpcUrl];
        const rpcUrlsWithoutReown = [...customRpcUrlsOfNetwork];
        if (chainDefaultRpcUrl && !rpcUrlsWithoutReown.includes(chainDefaultRpcUrl)) {
            rpcUrlsWithoutReown.push(chainDefaultRpcUrl);
        }
        return {
            ...caipNetwork,
            chainNamespace,
            caipNetworkId,
            assets: {
                imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
                imageUrl: customNetworkImageUrls?.[caipNetwork.id]
            },
            rpcUrls: {
                ...caipNetwork.rpcUrls,
                default: {
                    http: rpcUrls
                },
                chainDefault: {
                    http: rpcUrlsWithoutReown
                }
            }
        };
    },
    extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId, customRpcUrls }) {
        return caipNetworks.map(caipNetwork => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
            customNetworkImageUrls,
            customRpcUrls,
            projectId
        }));
    },
    getViemTransport(caipNetwork, projectId, customRpcUrls) {
        const transports = [];
        customRpcUrls?.forEach(rpcUrl => {
            transports.push((0,http/* http */.L)(rpcUrl.url, rpcUrl.config));
        });
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
            transports.push((0,http/* http */.L)(getBlockchainApiRpcUrl(caipNetwork.caipNetworkId, projectId), {
                fetchOptions: {
                    headers: {
                        'Content-Type': 'text/plain'
                    }
                }
            }));
        }
        caipNetwork?.rpcUrls?.default?.http?.forEach(rpcUrl => {
            transports.push((0,http/* http */.L)(rpcUrl));
        });
        return fallback(transports);
    },
    extendWagmiTransports(caipNetwork, projectId, transport) {
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
            const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetwork.caipNetworkId, projectId);
            return fallback([transport, (0,http/* http */.L)(reownRpcUrl)]);
        }
        return transport;
    },
    getUnsupportedNetwork(caipNetworkId) {
        return {
            id: caipNetworkId.split(':')[1],
            caipNetworkId,
            name: ConstantsUtil/* ConstantsUtil */.o.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: caipNetworkId.split(':')[0],
            nativeCurrency: {
                name: '',
                decimals: 0,
                symbol: ''
            },
            rpcUrls: {
                default: {
                    http: []
                }
            }
        };
    },
    getCaipNetworkFromStorage(defaultCaipNetwork) {
        const caipNetworkIdFromStorage = StorageUtil/* StorageUtil */.i.getActiveCaipNetworkId();
        const caipNetworks = ChainController/* ChainController */.W.getAllRequestedCaipNetworks();
        const availableNamespaces = Array.from(ChainController/* ChainController */.W.state.chains?.keys() || []);
        const namespace = caipNetworkIdFromStorage?.split(':')[0];
        const isNamespaceAvailable = namespace ? availableNamespaces.includes(namespace) : false;
        const caipNetwork = caipNetworks?.find(cn => cn.caipNetworkId === caipNetworkIdFromStorage);
        const isUnsupportedNetwork = isNamespaceAvailable && !caipNetwork && caipNetworkIdFromStorage;
        if (isUnsupportedNetwork) {
            return this.getUnsupportedNetwork(caipNetworkIdFromStorage);
        }
        if (caipNetwork) {
            return caipNetwork;
        }
        if (defaultCaipNetwork) {
            return defaultCaipNetwork;
        }
        return caipNetworks?.[0];
    }
};
//# sourceMappingURL=CaipNetworkUtil.js.map
// EXTERNAL MODULE: ./node_modules/@reown/appkit-utils/dist/esm/src/HelpersUtil.js
var HelpersUtil = __webpack_require__(335306);
// EXTERNAL MODULE: ./node_modules/@walletconnect/logger/dist/index.es.js
var dist_index_es = __webpack_require__(729838);
;// ./node_modules/@reown/appkit-utils/dist/esm/src/LoggerUtil.js

const LoggerUtil = {
    createLogger(onError, level = 'error') {
        const loggerOptions = (0,dist_index_es/* getDefaultLoggerOptions */.iP)({
            level
        });
        const { logger } = (0,dist_index_es/* generatePlatformLogger */.D5)({
            opts: loggerOptions
        });
        logger.error = (...args) => {
            for (const arg of args) {
                if (arg instanceof Error) {
                    onError(arg, ...args);
                    return;
                }
            }
            onError(undefined, ...args);
        };
        return logger;
    }
};
//# sourceMappingURL=LoggerUtil.js.map
;// ./node_modules/@reown/appkit-utils/dist/esm/src/ProviderUtil.js


const CLEAN_PROVIDERS_STATE = {
    eip155: undefined,
    solana: undefined,
    polkadot: undefined,
    bip122: undefined,
    cosmos: undefined
};
const ProviderUtil_state = (0,vanilla/* proxy */.BX)({
    providers: { ...CLEAN_PROVIDERS_STATE },
    providerIds: { ...CLEAN_PROVIDERS_STATE }
});
const ProviderUtil = {
    state: ProviderUtil_state,
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(ProviderUtil_state, key, callback);
    },
    subscribe(callback) {
        return (0,vanilla/* subscribe */.B1)(ProviderUtil_state, () => {
            callback(ProviderUtil_state);
        });
    },
    subscribeProviders(callback) {
        return (0,vanilla/* subscribe */.B1)(ProviderUtil_state.providers, () => callback(ProviderUtil_state.providers));
    },
    setProvider(chainNamespace, provider) {
        if (provider) {
            ProviderUtil_state.providers[chainNamespace] = (0,vanilla/* ref */.KR)(provider);
        }
    },
    getProvider(chainNamespace) {
        return ProviderUtil_state.providers[chainNamespace];
    },
    setProviderId(chainNamespace, providerId) {
        if (providerId) {
            ProviderUtil_state.providerIds[chainNamespace] = providerId;
        }
    },
    getProviderId(chainNamespace) {
        if (!chainNamespace) {
            return undefined;
        }
        return ProviderUtil_state.providerIds[chainNamespace];
    },
    reset() {
        ProviderUtil_state.providers = { ...CLEAN_PROVIDERS_STATE };
        ProviderUtil_state.providerIds = { ...CLEAN_PROVIDERS_STATE };
    },
    resetChain(chainNamespace) {
        ProviderUtil_state.providers[chainNamespace] = undefined;
        ProviderUtil_state.providerIds[chainNamespace] = undefined;
    }
};
//# sourceMappingURL=ProviderUtil.js.map
// EXTERNAL MODULE: ./node_modules/bs58/src/esm/index.js + 1 modules
var esm = __webpack_require__(148450);
// EXTERNAL MODULE: ./node_modules/viem/_esm/utils/encoding/toHex.js
var toHex = __webpack_require__(584192);
;// ./node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
const WcConstantsUtil = {
    ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
    ERROR_CODE_DEFAULT: 5000,
    ERROR_INVALID_CHAIN_ID: 32603,
    DEFAULT_ALLOWED_ANCESTORS: [
        'http://localhost:*',
        'https://*.pages.dev',
        'https://*.vercel.app',
        'https://*.ngrok-free.app',
        'https://secure-mobile.walletconnect.com',
        'https://secure-mobile.walletconnect.org'
    ]
};
//# sourceMappingURL=ConstantsUtil.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain(chain) {
    return {
        formatters: undefined,
        fees: undefined,
        serializers: undefined,
        ...chain
    };
}
//# sourceMappingURL=utils.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js

const solana = defineChain({
    id: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    name: 'Solana',
    network: 'solana-mainnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: {
        default: { http: ['https://rpc.walletconnect.org/v1'] }
    },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: false,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    deprecatedCaipNetworkId: 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ'
});
//# sourceMappingURL=solana.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js

const solanaDevnet = defineChain({
    id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    name: 'Solana Devnet',
    network: 'solana-devnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: {
        default: { http: ['https://rpc.walletconnect.org/v1'] }
    },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: true,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    deprecatedCaipNetworkId: 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K'
});
//# sourceMappingURL=solanaDevnet.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js

const solanaTestnet = defineChain({
    id: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    name: 'Solana Testnet',
    network: 'solana-testnet',
    nativeCurrency: { name: 'Solana', symbol: 'SOL', decimals: 9 },
    rpcUrls: {
        default: { http: ['https://rpc.walletconnect.org/v1'] }
    },
    blockExplorers: { default: { name: 'Solscan', url: 'https://solscan.io' } },
    testnet: true,
    chainNamespace: 'solana',
    caipNetworkId: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
});
//# sourceMappingURL=solanaTestnet.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/solana/index.js



//# sourceMappingURL=index.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js

const bitcoin = defineChain({
    id: '000000000019d6689c085ae165831e93',
    caipNetworkId: 'bip122:000000000019d6689c085ae165831e93',
    chainNamespace: 'bip122',
    name: 'Bitcoin',
    nativeCurrency: {
        name: 'Bitcoin',
        symbol: 'BTC',
        decimals: 8
    },
    rpcUrls: {
        default: { http: ['https://rpc.walletconnect.org/v1'] }
    }
});
const bitcoinTestnet = defineChain({
    id: '000000000933ea01ad0ee984209779ba',
    caipNetworkId: 'bip122:000000000933ea01ad0ee984209779ba',
    chainNamespace: 'bip122',
    name: 'Bitcoin Testnet',
    nativeCurrency: {
        name: 'Bitcoin',
        symbol: 'BTC',
        decimals: 8
    },
    rpcUrls: {
        default: { http: ['https://rpc.walletconnect.org/v1'] }
    },
    testnet: true
});
//# sourceMappingURL=bitcoin.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/networks/index.js
// -- Networks ---------------------------------------------------------------



// -- Utils ------------------------------------------------------------------

//# sourceMappingURL=index.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js


const DEFAULT_METHODS = {
    solana: [
        'solana_signMessage',
        'solana_signTransaction',
        'solana_requestAccounts',
        'solana_getAccounts',
        'solana_signAllTransactions',
        'solana_signAndSendTransaction'
    ],
    eip155: [
        'eth_accounts',
        'eth_requestAccounts',
        'eth_sendRawTransaction',
        'eth_sign',
        'eth_signTransaction',
        'eth_signTypedData',
        'eth_signTypedData_v3',
        'eth_signTypedData_v4',
        'eth_sendTransaction',
        'personal_sign',
        'wallet_switchEthereumChain',
        'wallet_addEthereumChain',
        'wallet_getPermissions',
        'wallet_requestPermissions',
        'wallet_registerOnboarding',
        'wallet_watchAsset',
        'wallet_scanQRCode',
        // EIP-5792
        'wallet_getCallsStatus',
        'wallet_showCallsStatus',
        'wallet_sendCalls',
        'wallet_getCapabilities',
        // EIP-7715
        'wallet_grantPermissions',
        'wallet_revokePermissions',
        //EIP-7811
        'wallet_getAssets'
    ],
    bip122: ['sendTransfer', 'signMessage', 'signPsbt', 'getAccountAddresses']
};
const WcHelpersUtil = {
    getMethodsByChainNamespace(chainNamespace) {
        return DEFAULT_METHODS[chainNamespace] || [];
    },
    createDefaultNamespace(chainNamespace) {
        return {
            methods: this.getMethodsByChainNamespace(chainNamespace),
            events: ['accountsChanged', 'chainChanged'],
            chains: [],
            rpcMap: {}
        };
    },
    applyNamespaceOverrides(baseNamespaces, overrides) {
        if (!overrides) {
            return { ...baseNamespaces };
        }
        const result = { ...baseNamespaces };
        const namespacesToOverride = new Set();
        if (overrides.methods) {
            Object.keys(overrides.methods).forEach(ns => namespacesToOverride.add(ns));
        }
        if (overrides.chains) {
            Object.keys(overrides.chains).forEach(ns => namespacesToOverride.add(ns));
        }
        if (overrides.events) {
            Object.keys(overrides.events).forEach(ns => namespacesToOverride.add(ns));
        }
        if (overrides.rpcMap) {
            Object.keys(overrides.rpcMap).forEach(chainId => {
                const [ns] = chainId.split(':');
                if (ns) {
                    namespacesToOverride.add(ns);
                }
            });
        }
        namespacesToOverride.forEach(ns => {
            if (!result[ns]) {
                result[ns] = this.createDefaultNamespace(ns);
            }
        });
        if (overrides.methods) {
            Object.entries(overrides.methods).forEach(([ns, methods]) => {
                if (result[ns]) {
                    result[ns].methods = methods;
                }
            });
        }
        if (overrides.chains) {
            Object.entries(overrides.chains).forEach(([ns, chains]) => {
                if (result[ns]) {
                    result[ns].chains = chains;
                }
            });
        }
        if (overrides.events) {
            Object.entries(overrides.events).forEach(([ns, events]) => {
                if (result[ns]) {
                    result[ns].events = events;
                }
            });
        }
        if (overrides.rpcMap) {
            const processedNamespaces = new Set();
            Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
                const [ns, id] = chainId.split(':');
                if (!ns || !id || !result[ns]) {
                    return;
                }
                if (!result[ns].rpcMap) {
                    result[ns].rpcMap = {};
                }
                if (!processedNamespaces.has(ns)) {
                    result[ns].rpcMap = {};
                    processedNamespaces.add(ns);
                }
                result[ns].rpcMap[id] = rpcUrl;
            });
        }
        return result;
    },
    createNamespaces(caipNetworks, configOverride) {
        const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
            const { id, chainNamespace, rpcUrls } = chain;
            const rpcUrl = rpcUrls.default.http[0];
            if (!acc[chainNamespace]) {
                acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
            }
            const caipNetworkId = `${chainNamespace}:${id}`;
            // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
            const namespace = acc[chainNamespace];
            namespace.chains.push(caipNetworkId);
            // Workaround for wallets that only support deprecated Solana network ID
            switch (caipNetworkId) {
                case solana.caipNetworkId:
                    namespace.chains.push(solana.deprecatedCaipNetworkId);
                    break;
                case solanaDevnet.caipNetworkId:
                    namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
                    break;
                default:
            }
            if (namespace?.rpcMap && rpcUrl) {
                namespace.rpcMap[id] = rpcUrl;
            }
            return acc;
        }, {});
        return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
    },
    resolveReownName: async (name) => {
        const wcNameAddress = await EnsController.resolveName(name);
        const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
        return networkNameAddresses[0]?.address || false;
    },
    getChainsFromNamespaces(namespaces = {}) {
        return Object.values(namespaces).flatMap(namespace => {
            const chains = (namespace.chains || []);
            const accountsChains = namespace.accounts.map(account => {
                const [chainNamespace, chainId] = account.split(':');
                return `${chainNamespace}:${chainId}`;
            });
            return Array.from(new Set([...chains, ...accountsChains]));
        });
    },
    isSessionEventData(data) {
        return (typeof data === 'object' &&
            data !== null &&
            'id' in data &&
            'topic' in data &&
            'params' in data &&
            typeof data.params === 'object' &&
            data.params !== null &&
            'chainId' in data.params &&
            'event' in data.params &&
            typeof data.params.event === 'object' &&
            data.params.event !== null);
    },
    isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
        for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
            if (pattern.includes('*')) {
                // Convert wildcard pattern to regex, escape special chars, replace *, match whole string
                const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, '\\$&');
                const regexString = `^${escapedPattern.replace(/\\\*/gu, '.*')}$`;
                const regex = new RegExp(regexString, 'u');
                if (regex.test(currentOrigin)) {
                    return true;
                }
            }
            else {
                /**
                 * There are some cases where pattern is getting just the origin, where using new URL(pattern).origin will throw an error
                 * thus we a try catch to handle this case
                 */
                try {
                    if (new URL(pattern).origin === currentOrigin) {
                        return true;
                    }
                }
                catch (e) {
                    if (pattern === currentOrigin) {
                        return true;
                    }
                }
            }
        }
        // No match found
        return false;
    }
};
//# sourceMappingURL=HelpersUtil.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/utils/index.js



//# sourceMappingURL=index.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js





class WalletConnectConnector {
    constructor({ provider, namespace }) {
        this.id = ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT;
        this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT];
        this.type = 'WALLET_CONNECT';
        this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT];
        this.getCaipNetworks = ChainController/* ChainController */.W.getCaipNetworks.bind(ChainController/* ChainController */.W);
        this.caipNetworks = this.getCaipNetworks();
        this.provider = provider;
        this.chain = namespace;
    }
    get chains() {
        return this.getCaipNetworks();
    }
    async connectWalletConnect() {
        const isAuthenticated = await this.authenticate();
        if (!isAuthenticated) {
            const caipNetworks = this.getCaipNetworks();
            const universalProviderConfigOverride = OptionsController/* OptionsController */.H.state.universalProviderConfigOverride;
            const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
            await this.provider.connect({ optionalNamespaces: namespaces });
        }
        return {
            clientId: await this.provider.client.core.crypto.getClientId(),
            session: this.provider.session
        };
    }
    async disconnect() {
        await this.provider.disconnect();
    }
    async authenticate() {
        const chains = this.chains.map(network => network.caipNetworkId);
        return SIWXUtil/* SIWXUtil */.U.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains,
            methods: OPTIONAL_METHODS
        });
    }
}
const OPTIONAL_METHODS = [
    'eth_accounts',
    'eth_requestAccounts',
    'eth_sendRawTransaction',
    'eth_sign',
    'eth_signTransaction',
    'eth_signTypedData',
    'eth_signTypedData_v3',
    'eth_signTypedData_v4',
    'eth_sendTransaction',
    'personal_sign',
    'wallet_switchEthereumChain',
    'wallet_addEthereumChain',
    'wallet_getPermissions',
    'wallet_requestPermissions',
    'wallet_registerOnboarding',
    'wallet_watchAsset',
    'wallet_scanQRCode',
    // EIP-5792
    'wallet_getCallsStatus',
    'wallet_sendCalls',
    'wallet_getCapabilities',
    // EIP-7715
    'wallet_grantPermissions',
    'wallet_revokePermissions',
    //EIP-7811
    'wallet_getAssets'
];
//# sourceMappingURL=WalletConnectConnector.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js





/**
 * Abstract class representing a chain adapter blueprint.
 * @template Connector - The type of connector extending ChainAdapterConnector
 */
class AdapterBlueprint {
    /**
     * Creates an instance of AdapterBlueprint.
     * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
     */
    constructor(params) {
        this.availableConnectors = [];
        this.eventListeners = new Map();
        this.getCaipNetworks = (namespace) => ChainController/* ChainController */.W.getCaipNetworks(namespace);
        if (params) {
            this.construct(params);
        }
    }
    /**
     * Initializes the adapter with the given parameters.
     * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
     */
    construct(params) {
        this.projectId = params.projectId;
        this.namespace = params.namespace;
        this.adapterType = params.adapterType;
    }
    /**
     * Gets the available connectors.
     * @returns {Connector[]} An array of available connectors
     */
    get connectors() {
        return this.availableConnectors;
    }
    /**
     * Gets the supported networks.
     * @returns {CaipNetwork[]} An array of supported networks
     */
    get networks() {
        return this.getCaipNetworks(this.namespace);
    }
    /**
     * Sets the auth provider.
     * @param {W3mFrameProvider} authProvider - The auth provider instance
     */
    setAuthProvider(authProvider) {
        this.addConnector({
            id: ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH,
            type: 'AUTH',
            name: ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_NAMES.AUTH,
            provider: authProvider,
            imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: []
        });
    }
    /**
     * Adds one or more connectors to the available connectors list.
     * @param {...Connector} connectors - The connectors to add
     */
    addConnector(...connectors) {
        const connectorsAdded = new Set();
        this.availableConnectors = [...connectors, ...this.availableConnectors].filter(connector => {
            if (connectorsAdded.has(connector.id)) {
                return false;
            }
            connectorsAdded.add(connector.id);
            return true;
        });
        this.emit('connectors', this.availableConnectors);
    }
    setStatus(status, chainNamespace) {
        AccountController/* AccountController */.U.setStatus(status, chainNamespace);
    }
    /**
     * Adds an event listener for a specific event.
     * @template T
     * @param {T} eventName - The name of the event
     * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
     */
    on(eventName, callback) {
        if (!this.eventListeners.has(eventName)) {
            this.eventListeners.set(eventName, new Set());
        }
        this.eventListeners.get(eventName)?.add(callback);
    }
    /**
     * Removes an event listener for a specific event.
     * @template T
     * @param {T} eventName - The name of the event
     * @param {EventCallback<T>} callback - The callback function to be removed
     */
    off(eventName, callback) {
        const listeners = this.eventListeners.get(eventName);
        if (listeners) {
            listeners.delete(callback);
        }
    }
    /**
     * Removes all event listeners.
     */
    removeAllEventListeners() {
        this.eventListeners.forEach(listeners => {
            listeners.clear();
        });
    }
    /**
     * Emits an event with the given name and optional data.
     * @template T
     * @param {T} eventName - The name of the event to emit
     * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
     */
    emit(eventName, data) {
        const listeners = this.eventListeners.get(eventName);
        if (listeners) {
            listeners.forEach(callback => callback(data));
        }
    }
    /**
     * Connects to WalletConnect.
     * @param {number | string} [_chainId] - Optional chain ID to connect to
     */
    async connectWalletConnect(_chainId) {
        const connector = this.getWalletConnectConnector();
        const result = await connector.connectWalletConnect();
        return { clientId: result.clientId };
    }
    /**
     * Switches the network.
     * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
     */
    async switchNetwork(params) {
        const { caipNetwork, providerType } = params;
        if (!params.provider) {
            return;
        }
        const provider = 'provider' in params.provider ? params.provider.provider : params.provider;
        if (providerType === 'WALLET_CONNECT') {
            ;
            provider.setDefaultChain(caipNetwork.caipNetworkId);
            return;
        }
        if (provider && providerType === 'AUTH') {
            const authProvider = provider;
            const preferredAccountType = AccountController/* AccountController */.U.state.preferredAccountTypes?.[caipNetwork.chainNamespace];
            await authProvider.switchNetwork(caipNetwork.caipNetworkId);
            const user = await authProvider.getUser({
                chainId: caipNetwork.caipNetworkId,
                preferredAccountType
            });
            this.emit('switchNetwork', user);
        }
    }
    getWalletConnectConnector() {
        const connector = this.connectors.find(c => c instanceof WalletConnectConnector);
        if (!connector) {
            throw new Error('WalletConnectConnector not found');
        }
        return connector;
    }
}
//# sourceMappingURL=ChainAdapterBlueprint.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js







class UniversalAdapter extends AdapterBlueprint {
    setUniversalProvider(universalProvider) {
        this.addConnector(new WalletConnectConnector({
            provider: universalProvider,
            caipNetworks: this.getCaipNetworks(),
            namespace: this.namespace
        }));
    }
    async connect(params) {
        return Promise.resolve({
            id: 'WALLET_CONNECT',
            type: 'WALLET_CONNECT',
            chainId: Number(params.chainId),
            provider: this.provider,
            address: ''
        });
    }
    async disconnect() {
        try {
            const connector = this.getWalletConnectConnector();
            await connector.disconnect();
        }
        catch (error) {
            console.warn('UniversalAdapter:disconnect - error', error);
        }
    }
    async getAccounts({ namespace }) {
        const provider = this.provider;
        const addresses = (provider?.session?.namespaces?.[namespace]?.accounts
            ?.map(account => {
            const [, , address] = account.split(':');
            return address;
        })
            .filter((address, index, self) => self.indexOf(address) === index) || []);
        return Promise.resolve({
            accounts: addresses.map(address => CoreHelperUtil/* CoreHelperUtil */.w.createAccount(namespace, address, namespace === 'bip122' ? 'payment' : 'eoa'))
        });
    }
    async syncConnectors() {
        return Promise.resolve();
    }
    async getBalance(params) {
        const isBalanceSupported = params.caipNetwork &&
            utils_ConstantsUtil/* ConstantsUtil */.oU.BALANCE_SUPPORTED_CHAINS.includes(params.caipNetwork?.chainNamespace);
        if (!isBalanceSupported || params.caipNetwork?.testnet) {
            return {
                balance: '0.00',
                symbol: params.caipNetwork?.nativeCurrency.symbol || ''
            };
        }
        if (AccountController/* AccountController */.U.state.balanceLoading &&
            params.chainId === ChainController/* ChainController */.W.state.activeCaipNetwork?.id) {
            return {
                balance: AccountController/* AccountController */.U.state.balance || '0.00',
                symbol: AccountController/* AccountController */.U.state.balanceSymbol || ''
            };
        }
        const balances = await AccountController/* AccountController */.U.fetchTokenBalance();
        const balance = balances.find(b => b.chainId === `${params.caipNetwork?.chainNamespace}:${params.chainId}` &&
            b.symbol === params.caipNetwork?.nativeCurrency.symbol);
        return {
            balance: balance?.quantity.numeric || '0.00',
            symbol: balance?.symbol || params.caipNetwork?.nativeCurrency.symbol || ''
        };
    }
    async signMessage(params) {
        const { provider, message, address } = params;
        if (!provider) {
            throw new Error('UniversalAdapter:signMessage - provider is undefined');
        }
        let signature = '';
        if (ChainController/* ChainController */.W.state.activeCaipNetwork?.chainNamespace === ConstantsUtil/* ConstantsUtil */.o.CHAIN.SOLANA) {
            const response = await provider.request({
                method: 'solana_signMessage',
                params: {
                    message: esm/* default */.A.encode(new TextEncoder().encode(message)),
                    pubkey: address
                }
            }, ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId);
            signature = response.signature;
        }
        else {
            signature = await provider.request({
                method: 'personal_sign',
                params: [message, address]
            }, ChainController/* ChainController */.W.state.activeCaipNetwork?.caipNetworkId);
        }
        return { signature };
    }
    // -- Transaction methods ---------------------------------------------------
    /**
     *
     * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
     * These function definition is to have a type parity between the clients. Currently not in use.
     */
    async estimateGas() {
        return Promise.resolve({
            gas: BigInt(0)
        });
    }
    async sendTransaction() {
        return Promise.resolve({
            hash: ''
        });
    }
    walletGetAssets(_params) {
        return Promise.resolve({});
    }
    async writeContract() {
        return Promise.resolve({
            hash: ''
        });
    }
    parseUnits() {
        return 0n;
    }
    formatUnits() {
        return '0';
    }
    async getCapabilities() {
        return Promise.resolve({});
    }
    async grantPermissions() {
        return Promise.resolve({});
    }
    async revokePermissions() {
        return Promise.resolve('0x');
    }
    async syncConnection() {
        return Promise.resolve({
            id: 'WALLET_CONNECT',
            type: 'WALLET_CONNECT',
            chainId: 1,
            provider: this.provider,
            address: ''
        });
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async switchNetwork(params) {
        const { caipNetwork } = params;
        const connector = this.getWalletConnectConnector();
        if (caipNetwork.chainNamespace === ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM) {
            try {
                await connector.provider?.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: (0,toHex/* toHex */.nj)(caipNetwork.id) }]
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (switchError) {
                if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                    switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID ||
                    switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT ||
                    switchError?.data?.originalError?.code ===
                        WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
                    try {
                        await connector.provider?.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: (0,toHex/* toHex */.nj)(caipNetwork.id),
                                    rpcUrls: [caipNetwork?.rpcUrls['chainDefault']?.http],
                                    chainName: caipNetwork.name,
                                    nativeCurrency: caipNetwork.nativeCurrency,
                                    blockExplorerUrls: [caipNetwork.blockExplorers?.default.url]
                                }
                            ]
                        });
                    }
                    catch (error) {
                        throw new Error('Chain is not supported');
                    }
                }
            }
        }
        connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
    }
    getWalletConnectProvider() {
        const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
        const provider = connector?.provider;
        return provider;
    }
}
//# sourceMappingURL=client.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js

const FEATURE_KEYS = [
    'email',
    'socials',
    'swaps',
    'onramp',
    'activity',
    'reownBranding'
];
const featureConfig = {
    email: {
        apiFeatureName: 'social_login',
        localFeatureName: 'email',
        returnType: false,
        isLegacy: false,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => {
            if (!apiConfig?.config) {
                return false;
            }
            const config = apiConfig.config;
            return Boolean(apiConfig.isEnabled) && config.includes('email');
        },
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.email;
            }
            return Boolean(localValue);
        }
    },
    socials: {
        apiFeatureName: 'social_login',
        localFeatureName: 'socials',
        returnType: false,
        isLegacy: false,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => {
            if (!apiConfig?.config) {
                return false;
            }
            const config = apiConfig.config;
            return Boolean(apiConfig.isEnabled) && config.length > 0
                ? config.filter((s) => s !== 'email')
                : false;
        },
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.socials;
            }
            if (typeof localValue === 'boolean') {
                return localValue ? utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.socials : false;
            }
            return localValue;
        }
    },
    swaps: {
        apiFeatureName: 'swap',
        localFeatureName: 'swaps',
        returnType: false,
        isLegacy: false,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => {
            if (!apiConfig?.config) {
                return false;
            }
            const config = apiConfig.config;
            return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
        },
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.swaps;
            }
            if (typeof localValue === 'boolean') {
                return localValue ? utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.swaps : false;
            }
            return localValue;
        }
    },
    onramp: {
        apiFeatureName: 'onramp',
        localFeatureName: 'onramp',
        returnType: false,
        isLegacy: false,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => {
            if (!apiConfig?.config) {
                return false;
            }
            const config = apiConfig.config;
            return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
        },
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.onramp;
            }
            if (typeof localValue === 'boolean') {
                return localValue ? utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.onramp : false;
            }
            return localValue;
        }
    },
    activity: {
        apiFeatureName: 'activity',
        localFeatureName: 'history',
        returnType: false,
        isLegacy: true,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.activity;
            }
            return Boolean(localValue);
        }
    },
    reownBranding: {
        apiFeatureName: 'reown_branding',
        localFeatureName: 'reownBranding',
        returnType: false,
        isLegacy: false,
        isAvailableOnBasic: false,
        processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
        processFallback: (localValue) => {
            if (localValue === undefined) {
                return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES.reownBranding;
            }
            return Boolean(localValue);
        }
    }
};
const ConfigUtil = {
    localSettingsOverridden: new Set(),
    getApiConfig(id, apiProjectConfig) {
        return apiProjectConfig?.find((f) => f.id === id);
    },
    addWarning(localFeatureValue, featureKey) {
        if (localFeatureValue !== undefined) {
            const config = featureConfig[featureKey];
            const warningName = config.isLegacy
                ? `"features.${config.localFeatureName}" (now "${featureKey}")`
                : `"features.${featureKey}"`;
            this.localSettingsOverridden.add(warningName);
        }
    },
    processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
        const config = featureConfig[featureKey];
        const localValue = localFeatures[config.localFeatureName];
        if (isBasic && !config.isAvailableOnBasic) {
            return false;
        }
        if (useApi) {
            const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
            if (apiConfig?.config === null) {
                return this.processFallbackFeature(featureKey, localValue);
            }
            if (!apiConfig?.config) {
                return false;
            }
            if (localValue !== undefined) {
                this.addWarning(localValue, featureKey);
            }
            return this.processApiFeature(featureKey, apiConfig);
        }
        return this.processFallbackFeature(featureKey, localValue);
    },
    processApiFeature(featureKey, apiConfig) {
        return featureConfig[featureKey].processApi(apiConfig);
    },
    processFallbackFeature(featureKey, localValue) {
        return featureConfig[featureKey].processFallback(localValue);
    },
    async fetchRemoteFeatures(config) {
        const isBasic = config.basic ?? false;
        const localFeatures = config.features || {};
        this.localSettingsOverridden.clear();
        let apiProjectConfig = null;
        let useApiConfig = false;
        try {
            apiProjectConfig = await ApiController/* ApiController */.N.fetchProjectConfig();
            useApiConfig = apiProjectConfig !== null && apiProjectConfig !== undefined;
        }
        catch (e) {
            console.warn('[Reown Config] Failed to fetch remote project configuration. Using local/default values.', e);
        }
        const remoteFeaturesConfig = useApiConfig && !isBasic
            ? utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES
            : utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES_DISABLED;
        try {
            for (const featureKey of FEATURE_KEYS) {
                const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, useApiConfig, isBasic);
                Object.assign(remoteFeaturesConfig, { [featureKey]: result });
            }
        }
        catch (e) {
            console.warn('[Reown Config] Failed to process the configuration from Cloud. Using default values.', e);
            return utils_ConstantsUtil/* ConstantsUtil */.oU.DEFAULT_REMOTE_FEATURES;
        }
        if (useApiConfig && this.localSettingsOverridden.size > 0) {
            const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(', ')} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
            AlertController/* AlertController */.h.open({
                shortMessage: 'Local configuration ignored',
                longMessage: `[Reown Config Notice] ${warningMessage}`
            }, 'warning');
        }
        return remoteFeaturesConfig;
    }
};
//# sourceMappingURL=ConfigUtil.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js











class AppKitBaseClient {
    constructor(options) {
        this.chainNamespaces = [];
        this.remoteFeatures = {};
        this.reportedAlertErrors = {};
        // -- Public Internal ---------------------------------------------------
        this.getCaipNetwork = (chainNamespace, id) => {
            if (chainNamespace) {
                const caipNetworkWithId = ChainController/* ChainController */.W.getNetworkData(chainNamespace)?.requestedCaipNetworks?.find(c => c.id === id);
                if (caipNetworkWithId) {
                    return caipNetworkWithId;
                }
                const namespaceCaipNetwork = ChainController/* ChainController */.W.getNetworkData(chainNamespace)?.caipNetwork;
                if (namespaceCaipNetwork) {
                    return namespaceCaipNetwork;
                }
                const requestedCaipNetworks = ChainController/* ChainController */.W.getRequestedCaipNetworks(chainNamespace);
                return requestedCaipNetworks.filter(c => c.chainNamespace === chainNamespace)?.[0];
            }
            return ChainController/* ChainController */.W.state.activeCaipNetwork || this.defaultCaipNetwork;
        };
        this.getCaipNetworkId = () => {
            const network = this.getCaipNetwork();
            if (network) {
                return network.id;
            }
            return undefined;
        };
        this.getCaipNetworks = (namespace) => ChainController/* ChainController */.W.getCaipNetworks(namespace);
        this.getActiveChainNamespace = () => ChainController/* ChainController */.W.state.activeChain;
        this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
            ChainController/* ChainController */.W.setRequestedCaipNetworks(requestedCaipNetworks, chain);
        };
        this.getApprovedCaipNetworkIds = () => ChainController/* ChainController */.W.getAllApprovedCaipNetworkIds();
        this.getCaipAddress = (chainNamespace) => {
            if (ChainController/* ChainController */.W.state.activeChain === chainNamespace || !chainNamespace) {
                return ChainController/* ChainController */.W.state.activeCaipAddress;
            }
            return ChainController/* ChainController */.W.getAccountProp('caipAddress', chainNamespace);
        };
        this.setClientId = clientId => {
            BlockchainApiController/* BlockchainApiController */.T.setClientId(clientId);
        };
        this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
        this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
        this.getPreferredAccountType = (namespace) => AccountController/* AccountController */.U.state.preferredAccountTypes?.[namespace];
        this.setCaipAddress = (caipAddress, chain) => {
            AccountController/* AccountController */.U.setCaipAddress(caipAddress, chain);
            /**
             * For the embedded use cases (Demo app), we should call close() when the user is connected to redirect them to Account View.
             */
            if (caipAddress && OptionsController/* OptionsController */.H.state.enableEmbedded) {
                this.close();
            }
        };
        this.setBalance = (balance, balanceSymbol, chain) => {
            AccountController/* AccountController */.U.setBalance(balance, balanceSymbol, chain);
        };
        this.setProfileName = (profileName, chain) => {
            AccountController/* AccountController */.U.setProfileName(profileName, chain);
        };
        this.setProfileImage = (profileImage, chain) => {
            AccountController/* AccountController */.U.setProfileImage(profileImage, chain);
        };
        this.setUser = (user, chain) => {
            AccountController/* AccountController */.U.setUser(user, chain);
        };
        this.resetAccount = (chain) => {
            AccountController/* AccountController */.U.resetAccount(chain);
        };
        this.setCaipNetwork = caipNetwork => {
            ChainController/* ChainController */.W.setActiveCaipNetwork(caipNetwork);
        };
        this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
            ChainController/* ChainController */.W.setChainNetworkData(chainNamespace, { caipNetwork });
        };
        this.setAllAccounts = (addresses, chain) => {
            AccountController/* AccountController */.U.setAllAccounts(addresses, chain);
            OptionsController/* OptionsController */.H.setHasMultipleAddresses(addresses?.length > 1);
        };
        this.setStatus = (status, chain) => {
            AccountController/* AccountController */.U.setStatus(status, chain);
            // If at least one namespace is connected, set the connection status
            if (ConnectorController/* ConnectorController */.a.isConnected()) {
                StorageUtil/* StorageUtil */.i.setConnectionStatus('connected');
            }
            else {
                StorageUtil/* StorageUtil */.i.setConnectionStatus('disconnected');
            }
        };
        this.getAddressByChainNamespace = (chainNamespace) => ChainController/* ChainController */.W.getAccountProp('address', chainNamespace);
        this.setConnectors = connectors => {
            const allConnectors = [...ConnectorController/* ConnectorController */.a.state.allConnectors, ...connectors];
            ConnectorController/* ConnectorController */.a.setConnectors(allConnectors);
        };
        this.setConnections = (connections, chainNamespace) => {
            ConnectionController/* ConnectionController */.x.setConnections(connections, chainNamespace);
        };
        this.fetchIdentity = request => BlockchainApiController/* BlockchainApiController */.T.fetchIdentity(request);
        this.getReownName = address => EnsController.getNamesForAddress(address);
        this.getConnectors = () => ConnectorController/* ConnectorController */.a.getConnectors();
        this.getConnectorImage = connector => AssetUtil/* AssetUtil */.$.getConnectorImage(connector);
        this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
            const type = ProviderUtil.getProviderId(chain);
            const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : undefined;
            AccountController/* AccountController */.U.setConnectedWalletInfo(walletInfo, chain);
        };
        this.getIsConnectedState = () => Boolean(ChainController/* ChainController */.W.state.activeCaipAddress);
        this.addAddressLabel = (address, label, chain) => {
            AccountController/* AccountController */.U.addAddressLabel(address, label, chain);
        };
        this.removeAddressLabel = (address, chain) => {
            AccountController/* AccountController */.U.removeAddressLabel(address, chain);
        };
        this.getAddress = (chainNamespace) => {
            if (ChainController/* ChainController */.W.state.activeChain === chainNamespace || !chainNamespace) {
                return AccountController/* AccountController */.U.state.address;
            }
            return ChainController/* ChainController */.W.getAccountProp('address', chainNamespace);
        };
        this.setApprovedCaipNetworksData = namespace => ChainController/* ChainController */.W.setApprovedCaipNetworksData(namespace);
        this.resetNetwork = (namespace) => {
            ChainController/* ChainController */.W.resetNetwork(namespace);
        };
        this.addConnector = connector => {
            ConnectorController/* ConnectorController */.a.addConnector(connector);
        };
        this.resetWcConnection = () => {
            ConnectionController/* ConnectionController */.x.resetWcConnection();
        };
        this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
            AccountController/* AccountController */.U.setAddressExplorerUrl(addressExplorerUrl, chain);
        };
        this.setSmartAccountDeployed = (isDeployed, chain) => {
            AccountController/* AccountController */.U.setSmartAccountDeployed(isDeployed, chain);
        };
        this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
            ChainController/* ChainController */.W.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
        };
        this.setPreferredAccountType = (preferredAccountType, chain) => {
            AccountController/* AccountController */.U.setPreferredAccountType(preferredAccountType, chain);
        };
        this.setEIP6963Enabled = enabled => {
            OptionsController/* OptionsController */.H.setEIP6963Enabled(enabled);
        };
        this.handleUnsafeRPCRequest = () => {
            if (this.isOpen()) {
                // If we are on the modal but there is no transaction stack, close the modal
                if (this.isTransactionStackEmpty()) {
                    return;
                }
                // Check if we need to replace or redirect
                this.redirect('ApproveTransaction');
            }
            else {
                // If called from outside the modal, open ApproveTransaction
                this.open({ view: 'ApproveTransaction' });
            }
        };
        this.options = options;
        this.version = options.sdkVersion;
        this.caipNetworks = this.extendCaipNetworks(options);
        this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
        this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
        this.chainAdapters = this.createAdapters(options.adapters);
        this.readyPromise = this.initialize(options);
    }
    getChainNamespacesSet(adapters, caipNetworks) {
        const adapterNamespaces = adapters
            ?.map(adapter => adapter.namespace)
            .filter((namespace) => Boolean(namespace));
        if (adapterNamespaces?.length) {
            return [...new Set(adapterNamespaces)];
        }
        const networkNamespaces = caipNetworks?.map(network => network.chainNamespace);
        return [...new Set(networkNamespaces)];
    }
    async initialize(options) {
        this.initializeProjectSettings(options);
        this.initControllers(options);
        await this.initChainAdapters();
        this.sendInitializeEvent(options);
        await this.syncExistingConnection();
        this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
        OptionsController/* OptionsController */.H.setRemoteFeatures(this.remoteFeatures);
        if (this.remoteFeatures.onramp) {
            OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
        }
        // Check allowed origins only if email or social features are enabled
        if (OptionsController/* OptionsController */.H.state.remoteFeatures?.email ||
            (Array.isArray(OptionsController/* OptionsController */.H.state.remoteFeatures?.socials) &&
                OptionsController/* OptionsController */.H.state.remoteFeatures?.socials.length > 0)) {
            await this.checkAllowedOrigins();
        }
    }
    async checkAllowedOrigins() {
        const allowedOrigins = await ApiController/* ApiController */.N.fetchAllowedOrigins();
        if (allowedOrigins && CoreHelperUtil/* CoreHelperUtil */.w.isClient()) {
            const currentOrigin = window.location.origin;
            const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
            if (!isOriginAllowed) {
                AlertController/* AlertController */.h.open(ErrorUtil.ALERT_ERRORS.INVALID_APP_CONFIGURATION, 'error');
            }
        }
        else {
            AlertController/* AlertController */.h.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error');
        }
    }
    sendInitializeEvent(options) {
        const { ...optionsCopy } = options;
        delete optionsCopy.adapters;
        delete optionsCopy.universalProvider;
        EventsController/* EventsController */.E.sendEvent({
            type: 'track',
            event: 'INITIALIZE',
            properties: {
                ...optionsCopy,
                networks: options.networks.map(n => n.id),
                siweConfig: {
                    options: options.siweConfig?.options || {}
                }
            }
        });
    }
    // -- Controllers initialization ---------------------------------------------------
    initControllers(options) {
        this.initializeOptionsController(options);
        this.initializeChainController(options);
        this.initializeThemeController(options);
        this.initializeConnectionController(options);
        this.initializeConnectorController();
    }
    initializeThemeController(options) {
        if (options.themeMode) {
            ThemeController/* ThemeController */.W.setThemeMode(options.themeMode);
        }
        if (options.themeVariables) {
            ThemeController/* ThemeController */.W.setThemeVariables(options.themeVariables);
        }
    }
    initializeChainController(options) {
        if (!this.connectionControllerClient || !this.networkControllerClient) {
            throw new Error('ConnectionControllerClient and NetworkControllerClient must be set');
        }
        ChainController/* ChainController */.W.initialize(options.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient
        });
        const network = this.getDefaultNetwork();
        if (network) {
            ChainController/* ChainController */.W.setActiveCaipNetwork(network);
        }
    }
    initializeConnectionController(options) {
        ConnectionController/* ConnectionController */.x.setWcBasic(options.basic ?? false);
    }
    initializeConnectorController() {
        ConnectorController/* ConnectorController */.a.initialize(this.chainNamespaces);
    }
    initializeProjectSettings(options) {
        OptionsController/* OptionsController */.H.setProjectId(options.projectId);
        OptionsController/* OptionsController */.H.setSdkVersion(options.sdkVersion);
    }
    initializeOptionsController(options) {
        OptionsController/* OptionsController */.H.setDebug(options.debug !== false);
        // On by default
        OptionsController/* OptionsController */.H.setEnableWalletConnect(options.enableWalletConnect !== false);
        OptionsController/* OptionsController */.H.setEnableWalletGuide(options.enableWalletGuide !== false);
        OptionsController/* OptionsController */.H.setEnableWallets(options.enableWallets !== false);
        OptionsController/* OptionsController */.H.setEIP6963Enabled(options.enableEIP6963 !== false);
        OptionsController/* OptionsController */.H.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
        OptionsController/* OptionsController */.H.setEnableAuthLogger(options.enableAuthLogger !== false);
        OptionsController/* OptionsController */.H.setCustomRpcUrls(options.customRpcUrls);
        OptionsController/* OptionsController */.H.setEnableEmbedded(options.enableEmbedded);
        OptionsController/* OptionsController */.H.setAllWallets(options.allWallets);
        OptionsController/* OptionsController */.H.setIncludeWalletIds(options.includeWalletIds);
        OptionsController/* OptionsController */.H.setExcludeWalletIds(options.excludeWalletIds);
        OptionsController/* OptionsController */.H.setFeaturedWalletIds(options.featuredWalletIds);
        OptionsController/* OptionsController */.H.setTokens(options.tokens);
        OptionsController/* OptionsController */.H.setTermsConditionsUrl(options.termsConditionsUrl);
        OptionsController/* OptionsController */.H.setPrivacyPolicyUrl(options.privacyPolicyUrl);
        OptionsController/* OptionsController */.H.setCustomWallets(options.customWallets);
        OptionsController/* OptionsController */.H.setFeatures(options.features);
        OptionsController/* OptionsController */.H.setAllowUnsupportedChain(options.allowUnsupportedChain);
        OptionsController/* OptionsController */.H.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
        OptionsController/* OptionsController */.H.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
        // Save option in controller
        OptionsController/* OptionsController */.H.setDefaultAccountTypes(options.defaultAccountTypes);
        // Get stored account types
        const storedAccountTypes = StorageUtil/* StorageUtil */.i.getPreferredAccountTypes() || {};
        const defaultTypes = { ...OptionsController/* OptionsController */.H.state.defaultAccountTypes, ...storedAccountTypes };
        AccountController/* AccountController */.U.setPreferredAccountTypes(defaultTypes);
        const defaultMetaData = this.getDefaultMetaData();
        if (!options.metadata && defaultMetaData) {
            options.metadata = defaultMetaData;
        }
        OptionsController/* OptionsController */.H.setMetadata(options.metadata);
        OptionsController/* OptionsController */.H.setDisableAppend(options.disableAppend);
        OptionsController/* OptionsController */.H.setEnableEmbedded(options.enableEmbedded);
        OptionsController/* OptionsController */.H.setSIWX(options.siwx);
        if (!options.projectId) {
            AlertController/* AlertController */.h.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error');
            return;
        }
        const evmAdapter = options.adapters?.find(adapter => adapter.namespace === ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM);
        // Set the SIWE client for EVM chains
        if (evmAdapter) {
            if (options.siweConfig) {
                if (options.siwx) {
                    throw new Error('Cannot set both `siweConfig` and `siwx` options');
                }
                OptionsController/* OptionsController */.H.setSIWX(options.siweConfig.mapToSIWX());
            }
        }
    }
    getDefaultMetaData() {
        if (CoreHelperUtil/* CoreHelperUtil */.w.isClient()) {
            return {
                name: document.getElementsByTagName('title')?.[0]?.textContent || '',
                description: document.querySelector('meta[property="og:description"]')?.content || '',
                url: window.location.origin,
                icons: [document.querySelector('link[rel~="icon"]')?.href || '']
            };
        }
        return null;
    }
    // -- Network Initialization ---------------------------------------------------
    setUnsupportedNetwork(chainId) {
        const namespace = this.getActiveChainNamespace();
        if (namespace) {
            const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
            ChainController/* ChainController */.W.setActiveCaipNetwork(unsupportedNetwork);
        }
    }
    getDefaultNetwork() {
        return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
    }
    extendCaipNetwork(network, options) {
        const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
            customNetworkImageUrls: options.chainImages,
            projectId: options.projectId
        });
        return extendedNetwork;
    }
    extendCaipNetworks(options) {
        const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
            customNetworkImageUrls: options.chainImages,
            customRpcUrls: options.customRpcUrls,
            projectId: options.projectId
        });
        return extendedNetworks;
    }
    extendDefaultCaipNetwork(options) {
        const defaultNetwork = options.networks.find(n => n.id === options.defaultNetwork?.id);
        const extendedNetwork = defaultNetwork
            ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
                customNetworkImageUrls: options.chainImages,
                customRpcUrls: options.customRpcUrls,
                projectId: options.projectId
            })
            : undefined;
        return extendedNetwork;
    }
    async disconnectNamespace(namespace) {
        try {
            const adapter = this.getAdapter(namespace);
            const provider = ProviderUtil.getProvider(namespace);
            const providerType = ProviderUtil.getProviderId(namespace);
            const { caipAddress } = ChainController/* ChainController */.W.getAccountData(namespace) || {};
            this.setLoading(true, namespace);
            if (caipAddress && adapter?.disconnect) {
                await adapter.disconnect({ provider, providerType });
            }
            StorageUtil/* StorageUtil */.i.removeConnectedNamespace(namespace);
            ProviderUtil.resetChain(namespace);
            this.setUser(undefined, namespace);
            this.setStatus('disconnected', namespace);
            this.setConnectedWalletInfo(undefined, namespace);
            ConnectorController/* ConnectorController */.a.removeConnectorId(namespace);
            ChainController/* ChainController */.W.resetAccount(namespace);
            ChainController/* ChainController */.W.resetNetwork(namespace);
            this.setLoading(false, namespace);
        }
        catch (error) {
            this.setLoading(false, namespace);
            throw new Error(`Failed to disconnect chain ${namespace}: ${error.message}`);
        }
    }
    // -- Client Initialization ---------------------------------------------------
    createClients() {
        this.connectionControllerClient = {
            connectWalletConnect: async () => {
                const activeChain = ChainController/* ChainController */.W.state.activeChain;
                const adapter = this.getAdapter(activeChain);
                const chainId = this.getCaipNetwork(activeChain)?.id;
                if (!adapter) {
                    throw new Error('Adapter not found');
                }
                const result = await adapter.connectWalletConnect(chainId);
                this.close();
                this.setClientId(result?.clientId || null);
                StorageUtil/* StorageUtil */.i.setConnectedNamespaces([...ChainController/* ChainController */.W.state.chains.keys()]);
                this.chainNamespaces.forEach(namespace => {
                    ConnectorController/* ConnectorController */.a.setConnectorId(src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_WALLET_CONNECT, namespace);
                });
                await this.syncWalletConnectAccount();
            },
            connectExternal: async ({ id, info, type, provider, chain, caipNetwork, socialUri }) => {
                const activeChain = ChainController/* ChainController */.W.state.activeChain;
                const chainToUse = chain || activeChain;
                const adapter = this.getAdapter(chainToUse);
                if (chain && chain !== activeChain && !caipNetwork) {
                    const toConnectNetwork = this.getCaipNetworks().find(network => network.chainNamespace === chain);
                    if (toConnectNetwork) {
                        this.setCaipNetwork(toConnectNetwork);
                    }
                }
                if (!adapter) {
                    throw new Error('Adapter not found');
                }
                const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);
                const res = await adapter.connect({
                    id,
                    info,
                    type,
                    provider,
                    socialUri,
                    chainId: caipNetwork?.id || fallbackCaipNetwork?.id,
                    rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] ||
                        fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]
                });
                if (!res) {
                    return;
                }
                StorageUtil/* StorageUtil */.i.addConnectedNamespace(chainToUse);
                this.syncProvider({ ...res, chainNamespace: chainToUse });
                /*
                 * SyncAllAccounts already set the accounts in the state
                 * and its more efficient to use the stored accounts rather than fetching them again
                 */
                const syncedAccounts = AccountController/* AccountController */.U.state.allAccounts;
                const { accounts } = syncedAccounts?.length > 0
                    ? // eslint-disable-next-line line-comment-position
                        // Using new array else the accounts will have the same reference and react will not re-render
                        { accounts: [...syncedAccounts] }
                    : await adapter.getAccounts({ namespace: chainToUse, id });
                this.setAllAccounts(accounts, chainToUse);
                this.setStatus('connected', chainToUse);
                this.syncConnectedWalletInfo(chainToUse);
            },
            reconnectExternal: async ({ id, info, type, provider }) => {
                const namespace = ChainController/* ChainController */.W.state.activeChain;
                const adapter = this.getAdapter(namespace);
                if (adapter?.reconnect) {
                    await adapter?.reconnect({ id, info, type, provider, chainId: this.getCaipNetwork()?.id });
                    StorageUtil/* StorageUtil */.i.addConnectedNamespace(namespace);
                    this.syncConnectedWalletInfo(namespace);
                }
            },
            disconnect: async (chainNamespace) => {
                const chainsToDisconnect = getChainsToDisconnect(chainNamespace);
                try {
                    // Reset send state when disconnecting
                    const disconnectResults = await Promise.allSettled(chainsToDisconnect.map(async ([ns]) => this.disconnectNamespace(ns)));
                    SendController/* SendController */.R.resetSend();
                    ConnectionController/* ConnectionController */.x.resetWcConnection();
                    await SIWXUtil/* SIWXUtil */.U.clearSessions();
                    ConnectorController/* ConnectorController */.a.setFilterByNamespace(undefined);
                    const failures = disconnectResults.filter((result) => result.status === 'rejected');
                    if (failures.length > 0) {
                        throw new Error(failures.map(f => f.reason.message).join(', '));
                    }
                    StorageUtil/* StorageUtil */.i.deleteConnectedSocialProvider();
                    EventsController/* EventsController */.E.sendEvent({
                        type: 'track',
                        event: 'DISCONNECT_SUCCESS',
                        properties: {
                            namespace: chainNamespace || 'all'
                        }
                    });
                }
                catch (error) {
                    throw new Error(`Failed to disconnect chains: ${error.message}`);
                }
            },
            checkInstalled: (ids) => {
                if (!ids) {
                    return Boolean(window.ethereum);
                }
                return ids.some(id => Boolean(window.ethereum?.[String(id)]));
            },
            signMessage: async (message) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                const result = await adapter?.signMessage({
                    message,
                    address: AccountController/* AccountController */.U.state.address,
                    provider: ProviderUtil.getProvider(ChainController/* ChainController */.W.state.activeChain)
                });
                return result?.signature || '';
            },
            sendTransaction: async (args) => {
                const namespace = args.chainNamespace;
                if (utils_ConstantsUtil/* ConstantsUtil */.oU.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
                    const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                    const provider = ProviderUtil.getProvider(namespace);
                    const result = await adapter?.sendTransaction({
                        ...args,
                        caipNetwork: this.getCaipNetwork(),
                        provider
                    });
                    return result?.hash || '';
                }
                return '';
            },
            estimateGas: async (args) => {
                if (args.chainNamespace === ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM) {
                    const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                    const provider = ProviderUtil.getProvider(ChainController/* ChainController */.W.state.activeChain);
                    const caipNetwork = this.getCaipNetwork();
                    if (!caipNetwork) {
                        throw new Error('CaipNetwork is undefined');
                    }
                    const result = await adapter?.estimateGas({
                        ...args,
                        provider,
                        caipNetwork
                    });
                    return result?.gas || 0n;
                }
                return 0n;
            },
            getEnsAvatar: async () => {
                await this.syncIdentity({
                    address: AccountController/* AccountController */.U.state.address,
                    chainId: Number(this.getCaipNetwork()?.id),
                    chainNamespace: ChainController/* ChainController */.W.state.activeChain
                });
                return AccountController/* AccountController */.U.state.profileImage || false;
            },
            getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
            writeContract: async (args) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                const caipNetwork = this.getCaipNetwork();
                const caipAddress = this.getCaipAddress();
                const provider = ProviderUtil.getProvider(ChainController/* ChainController */.W.state.activeChain);
                if (!caipNetwork || !caipAddress) {
                    throw new Error('CaipNetwork or CaipAddress is undefined');
                }
                const result = await adapter?.writeContract({ ...args, caipNetwork, provider, caipAddress });
                return result?.hash;
            },
            parseUnits: (value, decimals) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                return adapter?.parseUnits({ value, decimals }) ?? 0n;
            },
            formatUnits: (value, decimals) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                return adapter?.formatUnits({ value, decimals }) ?? '0';
            },
            getCapabilities: async (params) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                return await adapter?.getCapabilities(params);
            },
            grantPermissions: async (params) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                return await adapter?.grantPermissions(params);
            },
            revokePermissions: async (params) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                if (adapter?.revokePermissions) {
                    return await adapter.revokePermissions(params);
                }
                return '0x';
            },
            walletGetAssets: async (params) => {
                const adapter = this.getAdapter(ChainController/* ChainController */.W.state.activeChain);
                return (await adapter?.walletGetAssets(params)) ?? {};
            },
            updateBalance: (namespace) => {
                const caipNetwork = this.getCaipNetwork(namespace);
                if (!caipNetwork || !AccountController/* AccountController */.U.state.address) {
                    return;
                }
                this.updateNativeBalance(AccountController/* AccountController */.U.state.address, caipNetwork?.id, namespace);
            }
        };
        this.networkControllerClient = {
            switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
            // eslint-disable-next-line @typescript-eslint/require-await
            getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
        };
        ConnectionController/* ConnectionController */.x.setClient(this.connectionControllerClient);
    }
    getApprovedCaipNetworksData() {
        const providerType = ProviderUtil.getProviderId(ChainController/* ChainController */.W.state.activeChain);
        if (providerType === src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_WALLET_CONNECT) {
            const namespaces = this.universalProvider?.session?.namespaces;
            return {
                /*
                 * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
                 * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
                 * will make it possible to switch to other networks.
                 */
                supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === 'MetaMask Wallet',
                approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
            };
        }
        return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
    }
    async switchCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
            return;
        }
        const networkNamespace = caipNetwork.chainNamespace;
        const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
        if (namespaceAddress) {
            const provider = ProviderUtil.getProvider(networkNamespace);
            const providerType = ProviderUtil.getProviderId(networkNamespace);
            if (caipNetwork.chainNamespace === ChainController/* ChainController */.W.state.activeChain) {
                const adapter = this.getAdapter(networkNamespace);
                await adapter?.switchNetwork({ caipNetwork, provider, providerType });
            }
            else {
                this.setCaipNetwork(caipNetwork);
                if (providerType === src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_WALLET_CONNECT) {
                    this.syncWalletConnectAccount();
                }
                else {
                    const address = this.getAddressByChainNamespace(networkNamespace);
                    if (address) {
                        this.syncAccount({
                            address,
                            chainId: caipNetwork.id,
                            chainNamespace: networkNamespace
                        });
                    }
                }
            }
        }
        else {
            this.setCaipNetwork(caipNetwork);
        }
    }
    getChainsFromNamespaces(namespaces = {}) {
        return Object.values(namespaces).flatMap((namespace) => {
            const chains = (namespace.chains || []);
            const accountsChains = namespace.accounts.map(account => {
                const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
                return `${chainNamespace}:${chainId}`;
            });
            return Array.from(new Set([...chains, ...accountsChains]));
        });
    }
    // -- Adapter Initialization ---------------------------------------------------
    createAdapters(blueprints) {
        this.createClients();
        return this.chainNamespaces.reduce((adapters, namespace) => {
            const blueprint = blueprints?.find(b => b.namespace === namespace);
            if (blueprint) {
                blueprint.construct({
                    namespace,
                    projectId: this.options?.projectId,
                    networks: this.getCaipNetworks()
                });
                adapters[namespace] = blueprint;
            }
            else {
                adapters[namespace] = new UniversalAdapter({
                    namespace: namespace,
                    networks: this.getCaipNetworks()
                });
            }
            return adapters;
            // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        }, {});
    }
    async initChainAdapter(namespace) {
        this.onConnectors(namespace);
        this.listenAdapter(namespace);
        await this.chainAdapters?.[namespace].syncConnectors(this.options, this);
        await this.createUniversalProviderForAdapter(namespace);
    }
    async initChainAdapters() {
        await Promise.all(this.chainNamespaces.map(async (namespace) => {
            await this.initChainAdapter(namespace);
        }));
    }
    onConnectors(chainNamespace) {
        const adapter = this.getAdapter(chainNamespace);
        adapter?.on('connectors', this.setConnectors.bind(this));
    }
    listenAdapter(chainNamespace) {
        const adapter = this.getAdapter(chainNamespace);
        if (!adapter) {
            return;
        }
        const connectionStatus = StorageUtil/* StorageUtil */.i.getConnectionStatus();
        if (connectionStatus === 'connected') {
            this.setStatus('connecting', chainNamespace);
        }
        else if (connectionStatus === 'disconnected') {
            /*
             * Address cache is kept after disconnecting from the wallet
             * but should be cleared if appkit is launched in disconnected state
             */
            StorageUtil/* StorageUtil */.i.clearAddressCache();
            this.setStatus(connectionStatus, chainNamespace);
        }
        else {
            this.setStatus(connectionStatus, chainNamespace);
        }
        adapter.on('switchNetwork', ({ address, chainId }) => {
            const caipNetwork = this.getCaipNetworks().find(n => n.id === chainId || n.caipNetworkId === chainId);
            const isSameNamespace = ChainController/* ChainController */.W.state.activeChain === chainNamespace;
            const accountAddress = ChainController/* ChainController */.W.getAccountProp('address', chainNamespace);
            if (caipNetwork) {
                const account = isSameNamespace && address ? address : accountAddress;
                if (account) {
                    this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
                }
            }
            else {
                this.setUnsupportedNetwork(chainId);
            }
        });
        adapter.on('disconnect', this.disconnect.bind(this, chainNamespace));
        adapter.on('connections', connections => {
            this.setConnections(connections, chainNamespace);
        });
        adapter.on('pendingTransactions', () => {
            const address = AccountController/* AccountController */.U.state.address;
            const activeCaipNetwork = ChainController/* ChainController */.W.state.activeCaipNetwork;
            if (!address || !activeCaipNetwork?.id) {
                return;
            }
            this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
        });
        adapter.on('accountChanged', ({ address, chainId }) => {
            const isActiveChain = ChainController/* ChainController */.W.state.activeChain === chainNamespace;
            if (isActiveChain && chainId) {
                this.syncAccount({
                    address,
                    chainId,
                    chainNamespace
                });
            }
            else if (isActiveChain && ChainController/* ChainController */.W.state.activeCaipNetwork?.id) {
                this.syncAccount({
                    address,
                    chainId: ChainController/* ChainController */.W.state.activeCaipNetwork?.id,
                    chainNamespace
                });
            }
            else {
                this.syncAccountInfo(address, chainId, chainNamespace);
            }
            this.syncAllAccounts(chainNamespace);
        });
    }
    async createUniversalProviderForAdapter(chainNamespace) {
        await this.getUniversalProvider();
        if (this.universalProvider) {
            this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);
        }
    }
    // -- Connection Sync ---------------------------------------------------
    async syncExistingConnection() {
        await Promise.allSettled(this.chainNamespaces.map(namespace => this.syncNamespaceConnection(namespace)));
    }
    async syncNamespaceConnection(namespace) {
        try {
            if (namespace === ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM && CoreHelperUtil/* CoreHelperUtil */.w.isSafeApp()) {
                ConnectorController/* ConnectorController */.a.setConnectorId(ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.SAFE, namespace);
            }
            const connectorId = ConnectorController/* ConnectorController */.a.getConnectorId(namespace);
            this.setStatus('connecting', namespace);
            switch (connectorId) {
                case ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT:
                    await this.syncWalletConnectAccount();
                    break;
                case ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH:
                    // Handled during initialization of adapters' auth provider
                    break;
                default:
                    await this.syncAdapterConnection(namespace);
            }
        }
        catch (err) {
            console.warn("AppKit couldn't sync existing connection", err);
            this.setStatus('disconnected', namespace);
        }
    }
    async syncAdapterConnection(namespace) {
        const adapter = this.getAdapter(namespace);
        const connectorId = ConnectorController/* ConnectorController */.a.getConnectorId(namespace);
        const caipNetwork = this.getCaipNetwork(namespace);
        const connectors = ConnectorController/* ConnectorController */.a.getConnectors(namespace);
        const connector = connectors.find(c => c.id === connectorId);
        try {
            if (!adapter || !connector) {
                throw new Error(`Adapter or connector not found for namespace ${namespace}`);
            }
            if (!caipNetwork?.id) {
                throw new Error('CaipNetwork not found');
            }
            const connection = await adapter?.syncConnection({
                namespace,
                id: connector.id,
                chainId: caipNetwork.id,
                rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]
            });
            if (connection) {
                const accounts = await adapter?.getAccounts({
                    namespace,
                    id: connector.id
                });
                if (accounts && accounts.accounts.length > 0) {
                    this.setAllAccounts(accounts.accounts, namespace);
                }
                else {
                    this.setAllAccounts([CoreHelperUtil/* CoreHelperUtil */.w.createAccount(namespace, connection.address, 'eoa')], namespace);
                }
                this.syncProvider({ ...connection, chainNamespace: namespace });
                await this.syncAccount({ ...connection, chainNamespace: namespace });
                this.setStatus('connected', namespace);
            }
            else {
                this.setStatus('disconnected', namespace);
            }
        }
        catch (e) {
            this.setStatus('disconnected', namespace);
        }
    }
    async syncWalletConnectAccount() {
        const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
            const adapter = this.getAdapter(chainNamespace);
            const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];
            // We try and find the address for this network in the session object.
            const activeChainId = ChainController/* ChainController */.W.state.activeCaipNetwork?.id;
            const sessionAddress = namespaceAccounts.find(account => {
                const { chainId } = ParseUtil.parseCaipAddress(account);
                return chainId === activeChainId?.toString();
            }) || namespaceAccounts[0];
            if (sessionAddress) {
                const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
                const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
                ProviderUtil.setProviderId(chainNamespace, src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_WALLET_CONNECT);
                if (this.caipNetworks &&
                    ChainController/* ChainController */.W.state.activeCaipNetwork &&
                    adapter?.namespace !== ConstantsUtil/* ConstantsUtil */.o.CHAIN.EVM) {
                    const provider = adapter?.getWalletConnectProvider({
                        caipNetworks: this.getCaipNetworks(),
                        provider: this.universalProvider,
                        activeCaipNetwork: ChainController/* ChainController */.W.state.activeCaipNetwork
                    });
                    ProviderUtil.setProvider(chainNamespace, provider);
                }
                else {
                    ProviderUtil.setProvider(chainNamespace, this.universalProvider);
                }
                ConnectorController/* ConnectorController */.a.setConnectorId(ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
                StorageUtil/* StorageUtil */.i.addConnectedNamespace(chainNamespace);
                this.syncWalletConnectAccounts(chainNamespace);
                await this.syncAccount({
                    address,
                    chainId,
                    chainNamespace
                });
            }
            else {
                this.setStatus('disconnected', chainNamespace);
            }
            this.syncConnectedWalletInfo(chainNamespace);
            await ChainController/* ChainController */.W.setApprovedCaipNetworksData(chainNamespace);
        });
        await Promise.all(syncTasks);
    }
    syncWalletConnectAccounts(chainNamespace) {
        const addresses = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts
            ?.map(account => {
            const { address } = ParseUtil.parseCaipAddress(account);
            return address;
        })
            .filter((address, index, self) => self.indexOf(address) === index);
        if (addresses) {
            this.setAllAccounts(addresses.map(address => CoreHelperUtil/* CoreHelperUtil */.w.createAccount(chainNamespace, address, chainNamespace === 'bip122' ? 'payment' : 'eoa')), chainNamespace);
        }
    }
    syncProvider({ type, provider, id, chainNamespace }) {
        ProviderUtil.setProviderId(chainNamespace, type);
        ProviderUtil.setProvider(chainNamespace, provider);
        ConnectorController/* ConnectorController */.a.setConnectorId(id, chainNamespace);
    }
    async syncAllAccounts(namespace) {
        const connectorId = ConnectorController/* ConnectorController */.a.getConnectorId(namespace);
        if (!connectorId) {
            return;
        }
        const adapter = this.getAdapter(namespace);
        const accounts = await adapter?.getAccounts({ namespace, id: connectorId });
        if (accounts && accounts.accounts.length > 0) {
            this.setAllAccounts(accounts.accounts, namespace);
        }
    }
    async syncAccount(params) {
        const isActiveNamespace = params.chainNamespace === ChainController/* ChainController */.W.state.activeChain;
        const networkOfChain = ChainController/* ChainController */.W.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
        const { address, chainId, chainNamespace } = params;
        const { chainId: activeChainId } = StorageUtil/* StorageUtil */.i.getActiveNetworkProps();
        const chainIdToUse = chainId || activeChainId;
        const isUnsupportedNetwork = ChainController/* ChainController */.W.state.activeCaipNetwork?.name === ConstantsUtil/* ConstantsUtil */.o.UNSUPPORTED_NETWORK_NAME;
        const shouldSupportAllNetworks = ChainController/* ChainController */.W.getNetworkProp('supportsAllNetworks', chainNamespace);
        this.setStatus('connected', chainNamespace);
        if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
            return;
        }
        if (chainIdToUse) {
            let caipNetwork = this.getCaipNetworks().find(n => n.id.toString() === chainIdToUse.toString());
            let fallbackCaipNetwork = this.getCaipNetworks().find(n => n.chainNamespace === chainNamespace);
            // If doesn't support all networks, we need to use approved networks
            if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
                // Connection can be requested for a chain that is not supported by the wallet so we need to use approved networks here
                const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
                const caipNetworkId = caipNetworkIds.find(id => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());
                const fallBackCaipNetworkId = caipNetworkIds.find(id => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);
                caipNetwork = this.getCaipNetworks().find(n => n.caipNetworkId === caipNetworkId);
                fallbackCaipNetwork = this.getCaipNetworks().find(n => n.caipNetworkId === fallBackCaipNetworkId ||
                    // This is a workaround used in Solana network to support deprecated caipNetworkId
                    ('deprecatedCaipNetworkId' in n && n.deprecatedCaipNetworkId === fallBackCaipNetworkId));
            }
            const network = caipNetwork || fallbackCaipNetwork;
            if (network?.chainNamespace === ChainController/* ChainController */.W.state.activeChain) {
                // If the network is unsupported and the user doesn't allow unsupported chains, we show the unsupported chain UI
                if (OptionsController/* OptionsController */.H.state.enableNetworkSwitch &&
                    !OptionsController/* OptionsController */.H.state.allowUnsupportedChain &&
                    ChainController/* ChainController */.W.state.activeCaipNetwork?.name === ConstantsUtil/* ConstantsUtil */.o.UNSUPPORTED_NETWORK_NAME) {
                    ChainController/* ChainController */.W.showUnsupportedChainUI();
                }
                else {
                    this.setCaipNetwork(network);
                }
            }
            else if (!isActiveNamespace) {
                if (networkOfChain) {
                    this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
                }
            }
            this.syncConnectedWalletInfo(chainNamespace);
            if (!HelpersUtil/* HelpersUtil */.y.isLowerCaseMatch(address, AccountController/* AccountController */.U.state.address)) {
                this.syncAccountInfo(address, network?.id, chainNamespace);
            }
            if (isActiveNamespace) {
                await this.syncBalance({ address, chainId: network?.id, chainNamespace });
            }
            else {
                await this.syncBalance({ address, chainId: networkOfChain?.id, chainNamespace });
            }
        }
    }
    async syncAccountInfo(address, chainId, chainNamespace) {
        const caipAddress = this.getCaipAddress(chainNamespace);
        const newChainId = chainId || caipAddress?.split(':')[1];
        if (!newChainId) {
            return;
        }
        const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
        this.setCaipAddress(newCaipAddress, chainNamespace);
        await this.syncIdentity({
            address,
            chainId: newChainId,
            chainNamespace
        });
    }
    async syncReownName(address, chainNamespace) {
        try {
            const registeredWcNames = await this.getReownName(address);
            if (registeredWcNames[0]) {
                const wcName = registeredWcNames[0];
                this.setProfileName(wcName.name, chainNamespace);
            }
            else {
                this.setProfileName(null, chainNamespace);
            }
        }
        catch {
            this.setProfileName(null, chainNamespace);
        }
    }
    syncConnectedWalletInfo(chainNamespace) {
        const connectorId = ConnectorController/* ConnectorController */.a.getConnectorId(chainNamespace);
        const providerType = ProviderUtil.getProviderId(chainNamespace);
        if (providerType === src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_ANNOUNCED ||
            providerType === src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_INJECTED) {
            if (connectorId) {
                const connector = this.getConnectors().find(c => c.id === connectorId);
                if (connector) {
                    const { info, name, imageUrl } = connector;
                    const icon = imageUrl || this.getConnectorImage(connector);
                    this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
                }
            }
        }
        else if (providerType === src_ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_TYPE_WALLET_CONNECT) {
            const provider = ProviderUtil.getProvider(chainNamespace);
            if (provider?.session) {
                this.setConnectedWalletInfo({
                    ...provider.session.peer.metadata,
                    name: provider.session.peer.metadata.name,
                    icon: provider.session.peer.metadata.icons?.[0]
                }, chainNamespace);
            }
        }
        else if (connectorId) {
            if (connectorId === ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE) {
                const connector = this.getConnectors().find(c => c.id === ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.COINBASE);
                this.setConnectedWalletInfo({ name: 'Coinbase Wallet', icon: this.getConnectorImage(connector) }, chainNamespace);
            }
        }
    }
    async syncBalance(params) {
        const caipNetwork = NetworkUtil/* NetworkUtil */.L.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find(n => n.id.toString() === params.chainId?.toString());
        if (!caipNetwork || !params.chainId) {
            return;
        }
        await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
    }
    async ready() {
        await this.readyPromise;
    }
    async updateNativeBalance(address, chainId, namespace) {
        const adapter = this.getAdapter(namespace);
        const caipNetwork = ChainController/* ChainController */.W.getCaipNetworkByNamespace(namespace, chainId);
        if (adapter) {
            const balance = await adapter.getBalance({
                address,
                chainId,
                caipNetwork,
                tokens: this.options.tokens
            });
            this.setBalance(balance.balance, balance.symbol, namespace);
            return balance;
        }
        return undefined;
    }
    // -- Universal Provider ---------------------------------------------------
    async initializeUniversalAdapter() {
        const logger = LoggerUtil.createLogger((error, ...args) => {
            if (error) {
                this.handleAlertError(error);
            }
            // eslint-disable-next-line no-console
            console.error(...args);
        });
        const universalProviderOptions = {
            projectId: this.options?.projectId,
            metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : '',
                description: this.options?.metadata ? this.options?.metadata.description : '',
                url: this.options?.metadata ? this.options?.metadata.url : '',
                icons: this.options?.metadata ? this.options?.metadata.icons : ['']
            },
            logger
        };
        OptionsController/* OptionsController */.H.setManualWCControl(Boolean(this.options?.manualWCControl));
        this.universalProvider =
            this.options.universalProvider ?? (await index_es/* default */.A.init(universalProviderOptions));
        this.listenWalletConnect();
    }
    listenWalletConnect() {
        if (this.universalProvider) {
            this.universalProvider.on('display_uri', (uri) => {
                ConnectionController/* ConnectionController */.x.setUri(uri);
            });
            this.universalProvider.on('connect', ConnectionController/* ConnectionController */.x.finalizeWcConnection);
            this.universalProvider.on('disconnect', () => {
                this.chainNamespaces.forEach(namespace => {
                    this.resetAccount(namespace);
                });
                ConnectionController/* ConnectionController */.x.resetWcConnection();
            });
            this.universalProvider.on('chainChanged', (chainId) => {
                // eslint-disable-next-line eqeqeq
                const caipNetwork = this.getCaipNetworks().find(c => c.id == chainId);
                const currentCaipNetwork = this.getCaipNetwork();
                if (!caipNetwork) {
                    this.setUnsupportedNetwork(chainId);
                    return;
                }
                if (currentCaipNetwork?.id !== caipNetwork?.id) {
                    this.setCaipNetwork(caipNetwork);
                }
            });
            this.universalProvider.on('session_event', (callbackData) => {
                if (WcHelpersUtil.isSessionEventData(callbackData)) {
                    const { name, data } = callbackData.params.event;
                    if (name === 'accountsChanged' &&
                        Array.isArray(data) &&
                        CoreHelperUtil/* CoreHelperUtil */.w.isCaipAddress(data[0])) {
                        this.syncAccount(ParseUtil.parseCaipAddress(data[0]));
                    }
                }
            });
        }
    }
    createUniversalProvider() {
        if (!this.universalProviderInitPromise &&
            CoreHelperUtil/* CoreHelperUtil */.w.isClient() &&
            this.options?.projectId) {
            this.universalProviderInitPromise = this.initializeUniversalAdapter();
        }
        return this.universalProviderInitPromise;
    }
    async getUniversalProvider() {
        if (!this.universalProvider) {
            try {
                await this.createUniversalProvider();
            }
            catch (err) {
                EventsController/* EventsController */.E.sendEvent({
                    type: 'error',
                    event: 'INTERNAL_SDK_ERROR',
                    properties: {
                        errorType: 'UniversalProviderInitError',
                        errorMessage: err instanceof Error ? err.message : 'Unknown',
                        uncaught: false
                    }
                });
                // eslint-disable-next-line no-console
                console.error('AppKit:getUniversalProvider - Cannot create provider', err);
            }
        }
        return this.universalProvider;
    }
    // - Utils -------------------------------------------------------------------
    handleAlertError(error) {
        const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message }]) => error.message.includes(message));
        const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
        const { message, alertErrorKey } = errorValue ?? {};
        if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
            const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
            if (alertError) {
                AlertController/* AlertController */.h.open(alertError, 'error');
                this.reportedAlertErrors[errorKey] = true;
            }
        }
    }
    getAdapter(namespace) {
        if (!namespace) {
            return undefined;
        }
        return this.chainAdapters?.[namespace];
    }
    createAdapter(blueprint) {
        if (!blueprint) {
            return;
        }
        const namespace = blueprint.namespace;
        if (!namespace) {
            return;
        }
        this.createClients();
        const adapterBlueprint = blueprint;
        adapterBlueprint.namespace = namespace;
        adapterBlueprint.construct({
            namespace,
            projectId: this.options?.projectId,
            networks: this.getCaipNetworks()
        });
        if (!this.chainNamespaces.includes(namespace)) {
            this.chainNamespaces.push(namespace);
        }
        if (this.chainAdapters) {
            this.chainAdapters[namespace] = adapterBlueprint;
        }
    }
    // -- Public -------------------------------------------------------------------
    async open(options) {
        await this.injectModalUi();
        if (options?.uri) {
            ConnectionController/* ConnectionController */.x.setUri(options.uri);
        }
        if (options?.arguments) {
            switch (options?.view) {
                case 'Swap':
                    return ModalController/* ModalController */.W.open({ ...options, data: { swap: options.arguments } });
                default:
            }
        }
        return ModalController/* ModalController */.W.open(options);
    }
    async close() {
        await this.injectModalUi();
        ModalController/* ModalController */.W.close();
    }
    setLoading(loading, namespace) {
        ModalController/* ModalController */.W.setLoading(loading, namespace);
    }
    async disconnect(chainNamespace) {
        await ConnectionController/* ConnectionController */.x.disconnect(chainNamespace);
    }
    getSIWX() {
        return OptionsController/* OptionsController */.H.state.siwx;
    }
    // -- review these -------------------------------------------------------------------
    getError() {
        return '';
    }
    getChainId() {
        return ChainController/* ChainController */.W.state.activeCaipNetwork?.id;
    }
    async switchNetwork(appKitNetwork) {
        const network = this.getCaipNetworks().find(n => n.id === appKitNetwork.id);
        if (!network) {
            AlertController/* AlertController */.h.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, 'error');
            return;
        }
        await ChainController/* ChainController */.W.switchActiveNetwork(network);
    }
    getWalletProvider() {
        return ChainController/* ChainController */.W.state.activeChain
            ? ProviderUtil.state.providers[ChainController/* ChainController */.W.state.activeChain]
            : null;
    }
    getWalletProviderType() {
        return ProviderUtil.getProviderId(ChainController/* ChainController */.W.state.activeChain);
    }
    subscribeProviders(callback) {
        return ProviderUtil.subscribeProviders(callback);
    }
    getThemeMode() {
        return ThemeController/* ThemeController */.W.state.themeMode;
    }
    getThemeVariables() {
        return ThemeController/* ThemeController */.W.state.themeVariables;
    }
    setThemeMode(themeMode) {
        ThemeController/* ThemeController */.W.setThemeMode(themeMode);
        (0,esm_exports/* setColorTheme */.JX)(ThemeController/* ThemeController */.W.state.themeMode);
    }
    setTermsConditionsUrl(termsConditionsUrl) {
        OptionsController/* OptionsController */.H.setTermsConditionsUrl(termsConditionsUrl);
    }
    setPrivacyPolicyUrl(privacyPolicyUrl) {
        OptionsController/* OptionsController */.H.setPrivacyPolicyUrl(privacyPolicyUrl);
    }
    setThemeVariables(themeVariables) {
        ThemeController/* ThemeController */.W.setThemeVariables(themeVariables);
        (0,esm_exports/* setThemeVariables */.ds)(ThemeController/* ThemeController */.W.state.themeVariables);
    }
    subscribeTheme(callback) {
        return ThemeController/* ThemeController */.W.subscribe(callback);
    }
    getWalletInfo() {
        return AccountController/* AccountController */.U.state.connectedWalletInfo;
    }
    getAccount(namespace) {
        const authConnector = ConnectorController/* ConnectorController */.a.getAuthConnector(namespace);
        const accountState = ChainController/* ChainController */.W.getAccountData(namespace);
        const activeChain = ChainController/* ChainController */.W.state.activeChain;
        const activeConnectorId = StorageUtil/* StorageUtil */.i.getConnectedConnectorId(namespace || activeChain);
        if (!accountState) {
            return undefined;
        }
        return {
            allAccounts: accountState.allAccounts,
            caipAddress: accountState.caipAddress,
            address: CoreHelperUtil/* CoreHelperUtil */.w.getPlainAddress(accountState.caipAddress),
            isConnected: Boolean(accountState.caipAddress),
            status: accountState.status,
            embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil/* ConstantsUtil */.o.CONNECTOR_ID.AUTH
                ? {
                    user: accountState.user
                        ? {
                            ...accountState.user,
                            /*
                             * Getting the username from the chain controller works well for social logins,
                             * but Farcaster uses a different connection flow and doesn't emit the username via events.
                             * Since the username is stored in local storage before the chain controller updates,
                             * it's safe to use the local storage value here.
                             */
                            username: StorageUtil/* StorageUtil */.i.getConnectedSocialUsername()
                        }
                        : undefined,
                    authProvider: accountState.socialProvider ||
                        'email',
                    accountType: accountState.preferredAccountTypes?.[namespace || activeChain],
                    isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
                }
                : undefined
        };
    }
    subscribeAccount(callback, namespace) {
        const updateVal = () => {
            const account = this.getAccount(namespace);
            if (!account) {
                return;
            }
            callback(account);
        };
        if (namespace) {
            ChainController/* ChainController */.W.subscribeChainProp('accountState', updateVal, namespace);
        }
        else {
            ChainController/* ChainController */.W.subscribe(updateVal);
        }
        ConnectorController/* ConnectorController */.a.subscribe(updateVal);
    }
    subscribeNetwork(callback) {
        return ChainController/* ChainController */.W.subscribe(({ activeCaipNetwork }) => {
            callback({
                caipNetwork: activeCaipNetwork,
                chainId: activeCaipNetwork?.id,
                caipNetworkId: activeCaipNetwork?.caipNetworkId
            });
        });
    }
    subscribeWalletInfo(callback) {
        return AccountController/* AccountController */.U.subscribeKey('connectedWalletInfo', callback);
    }
    subscribeShouldUpdateToAddress(callback) {
        AccountController/* AccountController */.U.subscribeKey('shouldUpdateToAddress', callback);
    }
    subscribeCaipNetworkChange(callback) {
        ChainController/* ChainController */.W.subscribeKey('activeCaipNetwork', callback);
    }
    getState() {
        return PublicStateController/* PublicStateController */.z.state;
    }
    subscribeState(callback) {
        return PublicStateController/* PublicStateController */.z.subscribe(callback);
    }
    showErrorMessage(message) {
        SnackController/* SnackController */.P.showError(message);
    }
    showSuccessMessage(message) {
        SnackController/* SnackController */.P.showSuccess(message);
    }
    getEvent() {
        return { ...EventsController/* EventsController */.E.state };
    }
    subscribeEvents(callback) {
        return EventsController/* EventsController */.E.subscribe(callback);
    }
    replace(route) {
        RouterController/* RouterController */.I.replace(route);
    }
    redirect(route) {
        RouterController/* RouterController */.I.push(route);
    }
    popTransactionStack(status) {
        RouterController/* RouterController */.I.popTransactionStack(status);
    }
    isOpen() {
        return ModalController/* ModalController */.W.state.open;
    }
    isTransactionStackEmpty() {
        return RouterController/* RouterController */.I.state.transactionStack.length === 0;
    }
    static getInstance() {
        return this.instance;
    }
    updateFeatures(newFeatures) {
        OptionsController/* OptionsController */.H.setFeatures(newFeatures);
    }
    updateRemoteFeatures(newRemoteFeatures) {
        OptionsController/* OptionsController */.H.setRemoteFeatures(newRemoteFeatures);
    }
    updateOptions(newOptions) {
        const currentOptions = OptionsController/* OptionsController */.H.state || {};
        const updatedOptions = { ...currentOptions, ...newOptions };
        OptionsController/* OptionsController */.H.setOptions(updatedOptions);
    }
    setConnectMethodsOrder(connectMethodsOrder) {
        OptionsController/* OptionsController */.H.setConnectMethodsOrder(connectMethodsOrder);
    }
    setWalletFeaturesOrder(walletFeaturesOrder) {
        OptionsController/* OptionsController */.H.setWalletFeaturesOrder(walletFeaturesOrder);
    }
    setCollapseWallets(collapseWallets) {
        OptionsController/* OptionsController */.H.setCollapseWallets(collapseWallets);
    }
    setSocialsOrder(socialsOrder) {
        OptionsController/* OptionsController */.H.setSocialsOrder(socialsOrder);
    }
    getConnectMethodsOrder() {
        return WalletUtil/* WalletUtil */.A.getConnectOrderMethod(OptionsController/* OptionsController */.H.state.features, ConnectorController/* ConnectorController */.a.getConnectors());
    }
    /**
     * Adds a network to an existing adapter in AppKit.
     * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
     * @param network - The network configuration to add
     * @throws Error if adapter for namespace doesn't exist
     */
    addNetwork(namespace, network) {
        if (this.chainAdapters && !this.chainAdapters[namespace]) {
            throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
        }
        const extendedNetwork = this.extendCaipNetwork(network, this.options);
        if (!this.getCaipNetworks().find(n => n.id === extendedNetwork.id)) {
            ChainController/* ChainController */.W.addNetwork(extendedNetwork);
        }
    }
    /**
     * Removes a network from an existing adapter in AppKit.
     * @param namespace - The chain namespace the network belongs to
     * @param networkId - The network ID to remove
     * @throws Error if adapter for namespace doesn't exist or if removing last network
     */
    removeNetwork(namespace, networkId) {
        if (this.chainAdapters && !this.chainAdapters[namespace]) {
            throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
        }
        const networkToRemove = this.getCaipNetworks().find(n => n.id === networkId);
        if (!networkToRemove) {
            return;
        }
        ChainController/* ChainController */.W.removeNetwork(namespace, networkId);
    }
}
//# sourceMappingURL=appkit-base-client.js.map
;// ./node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js



// -- Export Controllers -------------------------------------------------------

// -- Helpers -------------------------------------------------------------------
let isInitialized = false;
// -- Client --------------------------------------------------------------------
class AppKit extends AppKitBaseClient {
    // -- Overrides --------------------------------------------------------------
    async open(options) {
        // Only open modal when not connected
        const isConnected = ConnectorController/* ConnectorController */.a.isConnected();
        if (!isConnected) {
            await super.open(options);
        }
    }
    async close() {
        await super.close();
        if (this.options.manualWCControl) {
            ConnectionController/* ConnectionController */.x.finalizeWcConnection();
        }
    }
    async syncIdentity(_request) {
        return Promise.resolve();
    }
    async syncBalance(_params) {
        return Promise.resolve();
    }
    async injectModalUi() {
        if (!isInitialized && CoreHelperUtil/* CoreHelperUtil */.w.isClient()) {
            await __webpack_require__.e(/* import() */ 1190).then(__webpack_require__.bind(__webpack_require__, 331190));
            await __webpack_require__.e(/* import() */ 5468).then(__webpack_require__.bind(__webpack_require__, 35468));
            const isElementCreated = document.querySelector('w3m-modal');
            if (!isElementCreated) {
                const modal = document.createElement('w3m-modal');
                if (!OptionsController/* OptionsController */.H.state.disableAppend && !OptionsController/* OptionsController */.H.state.enableEmbedded) {
                    document.body.insertAdjacentElement('beforeend', modal);
                }
            }
            isInitialized = true;
        }
    }
}
//# sourceMappingURL=appkit-core.js.map
;// ./node_modules/@reown/appkit/dist/esm/exports/constants.js
const PACKAGE_VERSION = '1.7.8';
//# sourceMappingURL=constants.js.map
;// ./node_modules/@reown/appkit/dist/esm/exports/core.js


function createAppKit(options) {
    return new AppKit({
        ...options,
        basic: true,
        sdkVersion: `html-core-${PACKAGE_VERSION}`
    });
}

//# sourceMappingURL=core.js.map

/***/ }),

/***/ 863450:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ AccountController)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(682419);
/* harmony import */ var _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(562944);
/* harmony import */ var _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(226742);
/* harmony import */ var _utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(923082);
/* harmony import */ var _BlockchainApiController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(775595);
/* harmony import */ var _ChainController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(806056);
/* harmony import */ var _SnackController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(121871);







// -- State --------------------------------------------- //
const state = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .proxy */ .BX)({
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: false,
    addressLabels: new Map(),
    allAccounts: []
});
// -- Controller ---------------------------------------- //
const controller = {
    state,
    replaceState(newState) {
        if (!newState) {
            return;
        }
        Object.assign(state, (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(newState));
    },
    subscribe(callback) {
        return _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.subscribeChainProp('accountState', accountState => {
            if (accountState) {
                return callback(accountState);
            }
            return undefined;
        });
    },
    subscribeKey(property, callback, chain) {
        let prev = undefined;
        return _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.subscribeChainProp('accountState', accountState => {
            if (accountState) {
                const nextValue = accountState[property];
                if (prev !== nextValue) {
                    prev = nextValue;
                    callback(nextValue);
                }
            }
        }, chain);
    },
    setStatus(status, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('status', status, chain);
    },
    getCaipAddress(chain) {
        return _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.getAccountProp('caipAddress', chain);
    },
    setCaipAddress(caipAddress, chain) {
        const newAddress = caipAddress ? _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .CoreHelperUtil */ .w.getPlainAddress(caipAddress) : undefined;
        if (chain === _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeChain) {
            _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeCaipAddress = caipAddress;
        }
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('caipAddress', caipAddress, chain);
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('address', newAddress, chain);
    },
    setBalance(balance, balanceSymbol, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('balance', balance, chain);
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('balanceSymbol', balanceSymbol, chain);
    },
    setProfileName(profileName, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('profileName', profileName, chain);
    },
    setProfileImage(profileImage, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('profileImage', profileImage, chain);
    },
    setUser(user, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('user', user, chain);
    },
    setAddressExplorerUrl(explorerUrl, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('addressExplorerUrl', explorerUrl, chain);
    },
    setSmartAccountDeployed(isDeployed, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('smartAccountDeployed', isDeployed, chain);
    },
    setCurrentTab(currentTab) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('currentTab', currentTab, _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeChain);
    },
    setTokenBalance(tokenBalance, chain) {
        if (tokenBalance) {
            _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('tokenBalance', tokenBalance, chain);
        }
    },
    setShouldUpdateToAddress(address, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('shouldUpdateToAddress', address, chain);
    },
    setAllAccounts(accounts, namespace) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('allAccounts', accounts, namespace);
    },
    addAddressLabel(address, label, chain) {
        const map = _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.getAccountProp('addressLabels', chain) || new Map();
        map.set(address, label);
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('addressLabels', map, chain);
    },
    removeAddressLabel(address, chain) {
        const map = _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.getAccountProp('addressLabels', chain) || new Map();
        map.delete(address);
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('addressLabels', map, chain);
    },
    setConnectedWalletInfo(connectedWalletInfo, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('connectedWalletInfo', connectedWalletInfo, chain, false);
    },
    setPreferredAccountType(preferredAccountType, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('preferredAccountTypes', {
            ...state.preferredAccountTypes,
            [chain]: preferredAccountType
        }, chain);
    },
    setPreferredAccountTypes(preferredAccountTypes) {
        state.preferredAccountTypes = preferredAccountTypes;
    },
    setSocialProvider(socialProvider, chain) {
        if (socialProvider) {
            _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('socialProvider', socialProvider, chain);
        }
    },
    setSocialWindow(socialWindow, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('socialWindow', socialWindow ? (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(socialWindow) : undefined, chain);
    },
    setFarcasterUrl(farcasterUrl, chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.setAccountProp('farcasterUrl', farcasterUrl, chain);
    },
    async fetchTokenBalance(onError) {
        state.balanceLoading = true;
        const chainId = _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeCaipNetwork?.caipNetworkId;
        const chain = _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeCaipNetwork?.chainNamespace;
        const caipAddress = _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.state.activeCaipAddress;
        const address = caipAddress ? _utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .CoreHelperUtil */ .w.getPlainAddress(caipAddress) : undefined;
        if (state.lastRetry &&
            !_utils_CoreHelperUtil_js__WEBPACK_IMPORTED_MODULE_2__/* .CoreHelperUtil */ .w.isAllowedRetry(state.lastRetry, 30 * _utils_ConstantsUtil_js__WEBPACK_IMPORTED_MODULE_3__/* .ConstantsUtil */ .oU.ONE_SEC_MS)) {
            state.balanceLoading = false;
            return [];
        }
        try {
            if (address && chainId && chain) {
                const response = await _BlockchainApiController_js__WEBPACK_IMPORTED_MODULE_4__/* .BlockchainApiController */ .T.getBalance(address, chainId);
                /*
                 * The 1Inch API includes many low-quality tokens in the balance response,
                 * which appear inconsistently. This filter prevents them from being displayed.
                 */
                const filteredBalances = response.balances.filter(balance => balance.quantity.decimals !== '0');
                AccountController.setTokenBalance(filteredBalances, chain);
                state.lastRetry = undefined;
                state.balanceLoading = false;
                return filteredBalances;
            }
        }
        catch (error) {
            state.lastRetry = Date.now();
            onError?.(error);
            _SnackController_js__WEBPACK_IMPORTED_MODULE_5__/* .SnackController */ .P.showError('Token Balance Unavailable');
        }
        finally {
            state.balanceLoading = false;
        }
        return [];
    },
    resetAccount(chain) {
        _ChainController_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainController */ .W.resetAccount(chain);
    }
};
const AccountController = (0,_utils_withErrorBoundary_js__WEBPACK_IMPORTED_MODULE_6__/* .withErrorBoundary */ .X)(controller);
//# sourceMappingURL=AccountController.js.map

/***/ }),

/***/ 923082:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ AppKitError),
  X: () => (/* binding */ withErrorBoundary)
});

// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla.mjs + 1 modules
var vanilla = __webpack_require__(682419);
// EXTERNAL MODULE: ./node_modules/valtio/esm/vanilla/utils.mjs
var utils = __webpack_require__(204707);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = __webpack_require__(226742);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/FetchUtil.js
var FetchUtil = __webpack_require__(25905);
// EXTERNAL MODULE: ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js + 1 modules
var OptionsController = __webpack_require__(500026);
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TelemetryController.js





// -- Constants ----------------------------------------- //
const DEFAULT_STATE = Object.freeze({
    enabled: true,
    events: []
});
const api = new FetchUtil/* FetchUtil */.Z({ baseUrl: CoreHelperUtil/* CoreHelperUtil */.w.getAnalyticsUrl(), clientId: null });
// Rate limiting constants
const MAX_ERRORS_PER_MINUTE = 5;
const ONE_MINUTE_MS = 60 * 1000;
// -- State --------------------------------------------- //
const state = (0,vanilla/* proxy */.BX)({
    ...DEFAULT_STATE
});
// -- Controller ---------------------------------------- //
const TelemetryController = {
    state,
    subscribeKey(key, callback) {
        return (0,utils/* subscribeKey */.u$)(state, key, callback);
    },
    async sendError(error, category) {
        if (!state.enabled) {
            return;
        }
        // Check rate limiting using events array
        const now = Date.now();
        const recentErrors = state.events.filter(event => {
            const eventTime = new Date(event.properties.timestamp || '').getTime();
            return now - eventTime < ONE_MINUTE_MS;
        });
        if (recentErrors.length >= MAX_ERRORS_PER_MINUTE) {
            // Exit silently
            return;
        }
        const errorEvent = {
            type: 'error',
            event: category,
            properties: {
                errorType: error.name,
                errorMessage: error.message,
                stackTrace: error.stack,
                timestamp: new Date().toISOString()
            }
        };
        state.events.push(errorEvent);
        try {
            if (typeof window === 'undefined') {
                return;
            }
            const { projectId, sdkType, sdkVersion } = OptionsController/* OptionsController */.H.state;
            await api.post({
                path: '/e',
                params: {
                    projectId,
                    st: sdkType,
                    sv: sdkVersion || 'html-wagmi-4.2.2'
                },
                body: {
                    eventId: CoreHelperUtil/* CoreHelperUtil */.w.getUUID(),
                    url: window.location.href,
                    domain: window.location.hostname,
                    timestamp: new Date().toISOString(),
                    props: {
                        type: 'error',
                        event: category,
                        errorType: error.name,
                        errorMessage: error.message,
                        stackTrace: error.stack
                    }
                }
            });
        }
        catch {
            // Do nothing
        }
    },
    enable() {
        state.enabled = true;
    },
    disable() {
        state.enabled = false;
    },
    clearEvents() {
        state.events = [];
    }
};
//# sourceMappingURL=TelemetryController.js.map
;// ./node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js

class AppKitError extends Error {
    constructor(message, category, originalError) {
        super(message);
        this.name = 'AppKitError';
        this.category = category;
        this.originalError = originalError;
        // Ensure `this instanceof AppKitError` is true, important for custom errors.
        Object.setPrototypeOf(this, AppKitError.prototype);
        let isStackConstructedFromOriginal = false;
        if (originalError instanceof Error &&
            typeof originalError.stack === 'string' &&
            originalError.stack) {
            const originalErrorStack = originalError.stack;
            /**
             * Most error stacks start with "ErrorName: ErrorMessage\n...frames..."
             * We want to take the "...frames..." part.
             */
            const firstNewlineIndex = originalErrorStack.indexOf('\n');
            if (firstNewlineIndex > -1) {
                const originalFrames = originalErrorStack.substring(firstNewlineIndex + 1);
                this.stack = `${this.name}: ${this.message}\n${originalFrames}`;
                isStackConstructedFromOriginal = true;
            }
        }
        if (!isStackConstructedFromOriginal) {
            /**
             * If stack was not (or could not be) constructed from originalError,
             * generate a standard stack trace for this AppKitError instance.
             * This will point to where `new AppKitError()` was called.
             */
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, AppKitError);
            }
            else if (!this.stack) {
                /**
                 * Fallback for environments without Error.captureStackTrace.
                 * `super(message)` might have set a stack.
                 * If `this.stack` is still undefined/empty, provide a minimal one.
                 * Node.js and modern browsers typically set `this.stack` from `super(message)`.
                 */
                this.stack = `${this.name}: ${this.message}`;
            }
        }
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function errorHandler(err, defaultCategory) {
    const error = err instanceof AppKitError
        ? err
        : new AppKitError(err instanceof Error ? err.message : String(err), defaultCategory, err);
    TelemetryController.sendError(error, error.category);
    throw error;
}
function withErrorBoundary(controller, defaultCategory = 'INTERNAL_SDK_ERROR') {
    const newController = {};
    Object.keys(controller).forEach(key => {
        const original = controller[key];
        if (typeof original === 'function') {
            let wrapped = original;
            if (original.constructor.name === 'AsyncFunction') {
                wrapped = async (...args) => {
                    try {
                        return await original(...args);
                    }
                    catch (err) {
                        return errorHandler(err, defaultCategory);
                    }
                };
            }
            else {
                wrapped = (...args) => {
                    try {
                        return original(...args);
                    }
                    catch (err) {
                        return errorHandler(err, defaultCategory);
                    }
                };
            }
            newController[key] = wrapped;
        }
        else {
            newController[key] = original;
        }
    });
    return newController;
}
//# sourceMappingURL=withErrorBoundary.js.map

/***/ }),

/***/ 926109:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JX: () => (/* binding */ setColorTheme),
/* harmony export */   RF: () => (/* binding */ initializeTheming),
/* harmony export */   W5: () => (/* binding */ resetStyles),
/* harmony export */   ck: () => (/* binding */ colorStyles),
/* harmony export */   ds: () => (/* binding */ setThemeVariables),
/* harmony export */   fD: () => (/* binding */ elementStyles)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(197199);
/* harmony import */ var _reown_appkit_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(323096);


let themeTag = undefined;
let darkModeTag = undefined;
let lightModeTag = undefined;
function initializeTheming(themeVariables, themeMode) {
    themeTag = document.createElement('style');
    darkModeTag = document.createElement('style');
    lightModeTag = document.createElement('style');
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
    document.head.appendChild(themeTag);
    document.head.appendChild(darkModeTag);
    document.head.appendChild(lightModeTag);
    setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
    if (darkModeTag && lightModeTag) {
        if (themeMode === 'light') {
            darkModeTag.removeAttribute('media');
            lightModeTag.media = 'enabled';
        }
        else {
            lightModeTag.removeAttribute('media');
            darkModeTag.media = 'enabled';
        }
    }
}
function setThemeVariables(themeVariables) {
    if (themeTag && darkModeTag && lightModeTag) {
        themeTag.textContent = createRootStyles(themeVariables).core.cssText;
        darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
        lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
    }
}
function createRootStyles(themeVariables) {
    return {
        core: (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-color-mix-strength']
            ? `${themeVariables['--w3m-color-mix-strength']}%`
            : '0%')};
        --w3m-font-family: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-font-family'] ||
            'Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;')};
        --w3m-font-size-master: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-font-size-master'] || '10px')};
        --w3m-border-radius-master: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-border-radius-master'] || '4px')};
        --w3m-z-index: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-z-index'] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
        light: (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
      :root {
        --w3m-color-mix: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-color-mix'] || '#fff')};
        --w3m-accent: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)((0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_1__/* .getW3mThemeVariables */ .o)(themeVariables, 'dark')['--w3m-accent'])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)((0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_1__/* .getW3mThemeVariables */ .o)(themeVariables, 'dark')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
        dark: (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
      :root {
        --w3m-color-mix: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)(themeVariables?.['--w3m-color-mix'] || '#000')};
        --w3m-accent: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)((0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_1__/* .getW3mThemeVariables */ .o)(themeVariables, 'light')['--w3m-accent'])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${(0,lit__WEBPACK_IMPORTED_MODULE_0__/* .unsafeCSS */ .iz)((0,_reown_appkit_common__WEBPACK_IMPORTED_MODULE_1__/* .getW3mThemeVariables */ .o)(themeVariables, 'light')['--w3m-background'])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
    };
}
const resetStyles = (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = (0,lit__WEBPACK_IMPORTED_MODULE_0__/* .css */ .AH) `
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
//# sourceMappingURL=ThemeUtil.js.map

/***/ })

};
;