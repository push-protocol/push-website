"use strict";(self.webpackChunkpush_website=self.webpackChunkpush_website||[]).push([[1230],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var r=i(296540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},611350:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=i(474848),s=i(28453);const a={id:"docs-create-universal-signer",title:"Create Universal Signer",hide_title:!0,slug:"./create-universal-signer",displayed_sidebar:"pushChainSidebar",sidebar_position:11,image:"/assets/docs/previews/docs--create_universal_signer.png"},t="Create Universal Signer",o={id:"chain/build/docs-create-universal-signer",title:"Create Universal Signer",description:"The Universal Signer is a standardized way to sign messages and transactions across different blockchain libraries and wallets in the Push Protocol Core SDK. It provides a unified interface that abstracts away the complexity of different signing implementations, allowing you to work seamlessly with various wallet providers and blockchain libraries.",source:"@site/docs/chain/02-build/11-Create-Universal-Signer.mdx",sourceDirName:"chain/02-build",slug:"/chain/build/create-universal-signer",permalink:"/push-website/pr-preview/pr-1061/docs/chain/build/create-universal-signer",draft:!1,unlisted:!1,editUrl:"https://github.com/push-protocol/push-website/blob/main/docs/chain/02-build/11-Create-Universal-Signer.mdx",tags:[],version:"current",sidebarPosition:11,frontMatter:{id:"docs-create-universal-signer",title:"Create Universal Signer",hide_title:!0,slug:"./create-universal-signer",displayed_sidebar:"pushChainSidebar",sidebar_position:11,image:"/assets/docs/previews/docs--create_universal_signer.png"},sidebar:"pushChainSidebar",previous:{title:"WebSocket",permalink:"/push-website/pr-preview/pr-1061/docs/chain/build/websocket"},next:{title:"UI Components",permalink:"/push-website/pr-preview/pr-1061/docs/chain/ui-components"}},c={},l=[{value:"Creating Universal Signers",id:"creating-universal-signers",level:2},{value:"Method 1: From Existing Library Signers",id:"method-1-from-existing-library-signers",level:3},{value:"Viem Signer Example",id:"viem-signer-example",level:4},{value:"Ethers Signer Example",id:"ethers-signer-example",level:4},{value:"Solana Web3.js Signer Example",id:"solana-web3js-signer-example",level:4},{value:"Method 2: Custom Signer Construction",id:"method-2-custom-signer-construction",level:3},{value:"Method 3: From Key Pair",id:"method-3-from-key-pair",level:3},{value:"Type Definitions",id:"type-definitions",level:2},{value:"UniversalSigner",id:"universalsigner",level:3},{value:"UniversalSignerSkeleton",id:"universalsignerskeleton",level:3},{value:"ViemSigner",id:"viemsigner",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"PushChain.signer.construct()",id:"pushchainsignerconstruct",level:3},{value:"PushChain.signer.toUniversal()",id:"pushchainsignertouniversal",level:3},{value:"PushChain.signer.toUniversalFromKeyPair()",id:"pushchainsignertouniversalfromkeypair",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"create-universal-signer",children:"Create Universal Signer"}),"\n",(0,r.jsx)(n.p,{children:"The Universal Signer is a standardized way to sign messages and transactions across different blockchain libraries and wallets in the Push Protocol Core SDK. It provides a unified interface that abstracts away the complexity of different signing implementations, allowing you to work seamlessly with various wallet providers and blockchain libraries."}),"\n",(0,r.jsx)(n.h2,{id:"creating-universal-signers",children:"Creating Universal Signers"}),"\n",(0,r.jsx)(n.p,{children:"There are several ways to create a Universal Signer depending on your setup:"}),"\n",(0,r.jsx)(n.h3,{id:"method-1-from-existing-library-signers",children:"Method 1: From Existing Library Signers"}),"\n",(0,r.jsx)(n.p,{children:"If you already have a signer from a supported library (Viem, Ethers, Solana), you can directly convert it to a Universal Signer."}),"\n",(0,r.jsx)(n.h4,{id:"viem-signer-example",children:"Viem Signer Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { PushChain } from '@pushprotocol/core';\nimport { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { mainnet } from 'viem/chains';\n\n// Create a Viem wallet client\nconst account = privateKeyToAccount('0x...');\nconst viemClient = createWalletClient({\n  account,\n  chain: mainnet,\n  transport: http()\n});\n\n// Convert to Universal Signer\nconst universalSigner = await PushChain.signer.toUniversal(viemClient);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"ethers-signer-example",children:"Ethers Signer Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { PushChain } from '@pushprotocol/core';\nimport { ethers } from 'ethers';\n\n// Create an Ethers signer\nconst provider = new ethers.providers.JsonRpcProvider('...');\nconst ethersSigner = new ethers.Wallet('0x...', provider);\n\n// Convert to Universal Signer\nconst universalSigner = await PushChain.signer.toUniversal(ethersSigner);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"solana-web3js-signer-example",children:"Solana Web3.js Signer Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { PushChain } from '@pushprotocol/core';\nimport { Keypair } from '@solana/web3.js';\n\n// Create a Solana keypair\nconst solanaKeypair = Keypair.generate();\n\n// Convert to Universal Signer\nconst universalSigner = await PushChain.signer.toUniversal(solanaKeypair);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-2-custom-signer-construction",children:"Method 2: Custom Signer Construction"}),"\n",(0,r.jsx)(n.p,{children:"If you don't have a supported library or want to create a custom signer, you can construct one manually."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { PushChain } from '@pushprotocol/core';\n\n// Define your custom signing functions\nconst customSignMessage = async (data: Uint8Array): Promise<Uint8Array> => {\n  // Your custom message signing logic\n  return new Uint8Array(/* signed data */);\n};\n\nconst customSignTransaction = async (unsignedTx: Uint8Array): Promise<Uint8Array> => {\n  // Your custom transaction signing logic\n  return new Uint8Array(/* signed transaction */);\n};\n\nconst customSignTypedData = async ({\n  domain,\n  types,\n  primaryType,\n  message,\n}: {\n  domain: TypedDataDomain;\n  types: TypedData;\n  primaryType: string;\n  message: Record<string, any>;\n}): Promise<Uint8Array> => {\n  // Your custom typed data signing logic\n  return new Uint8Array(/* signed typed data */);\n};\n\n// Create Universal Account\nconst account = {\n  address: '0x...',\n  chain: 'evm' // or 'solana'\n};\n\n// Step 1: Construct the skeleton\nconst signerSkeleton = PushChain.signer.construct({\n  signMessage: customSignMessage,\n  signTransaction: customSignTransaction,\n  signTypedData: customSignTypedData,\n  account: account,\n  signerId: 'CustomGeneratedSigner'\n});\n\n// Step 2: Convert to Universal Signer\nconst universalSigner = await PushChain.signer.toUniversal(signerSkeleton);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-3-from-key-pair",children:"Method 3: From Key Pair"}),"\n",(0,r.jsx)(n.p,{children:"You can create Universal Signers from key pairs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { PushChain, CHAIN, LIBRARY } from '@pushprotocol/core';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// For Viem\nconst account = privateKeyToAccount('0x...');\nconst universalSigner = PushChain.signer.toUniversalFromKeyPair(\n  account,\n  { chain: CHAIN.ETH_MAINNET, library: LIBRARY.VIEM }\n);\n\n// For Ethers\nconst ethersWallet = new ethers.Wallet('0x...');\nconst universalSigner2 = PushChain.signer.toUniversalFromKeyPair(\n  ethersWallet,\n  { chain: CHAIN.ETH_MAINNET, library: LIBRARY.ETHERS }\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,r.jsx)(n.h3,{id:"universalsigner",children:"UniversalSigner"}),"\n",(0,r.jsx)(n.p,{children:"The final Universal Signer interface that you'll use throughout the Push Protocol:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface UniversalSigner {\n  account: {\n    address: string;\n    chain: string;\n  };\n  signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n  signTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n  signTypedData: ({\n    domain,\n    types,\n    primaryType,\n    message,\n  }: {\n    domain: TypedDataDomain;\n    types: TypedData;\n    primaryType: string;\n    message: Record<string, any>;\n  }) => Promise<Uint8Array>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"universalsignerskeleton",children:"UniversalSignerSkeleton"}),"\n",(0,r.jsx)(n.p,{children:"An intermediate structure used during signer construction:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface UniversalSignerSkeleton {\n  signerId: 'CustomGeneratedSigner';\n  account: UniversalAccount;\n  signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n  signTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n  signTypedData: ({\n    domain,\n    types,\n    primaryType,\n    message,\n  }: {\n    domain: TypedDataDomain;\n    types: TypedData;\n    primaryType: string;\n    message: Record<string, any>;\n  }) => Promise<Uint8Array>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"viemsigner",children:"ViemSigner"}),"\n",(0,r.jsx)(n.p,{children:"The expected interface for Viem signers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ViemSigner {\n  signTypedData: (args: {\n    account: any;\n    domain: any;\n    types: any;\n    primaryType: any;\n    message: any;\n  }) => Promise<`0x${string}`>;\n  getChainId: () => Promise<number>;\n  signMessage: (args: {\n    message: any;\n    account: any;\n    [key: string]: any;\n  }) => Promise<`0x${string}`>;\n  account: { [key: string]: any };\n  privateKey?: string;\n  provider?: any;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.h3,{id:"pushchainsignerconstruct",children:"PushChain.signer.construct()"}),"\n",(0,r.jsx)(n.p,{children:"Creates a Universal Signer Skeleton from custom signing functions."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signMessage: (data: Uint8Array) => Promise<Uint8Array>"})," - Function to sign raw message data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>"})," - Function to sign transaction data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signTypedData: (params) => Promise<Uint8Array>"})," - Function to sign typed data (EIP-712)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"account: UniversalAccount"})," - Account information (address and chain)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signerId: 'CustomGeneratedSigner'"})," - Identifier for custom signers"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.code,{children:"UniversalSignerSkeleton"})]}),"\n",(0,r.jsx)(n.h3,{id:"pushchainsignertouniversal",children:"PushChain.signer.toUniversal()"}),"\n",(0,r.jsx)(n.p,{children:"Converts various signer types to Universal Signer format."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signer: ViemSigner | EthersSigner | SolanaWeb3jsSigner | UniversalSignerSkeleton"})," - The signer to convert"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.code,{children:"Promise<UniversalSigner>"})]}),"\n",(0,r.jsx)(n.h3,{id:"pushchainsignertouniversalfromkeypair",children:"PushChain.signer.toUniversalFromKeyPair()"}),"\n",(0,r.jsx)(n.p,{children:"Method for creating Universal Signers from key pairs or wallet clients."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"clientOrAccount: WalletClient | Account | Keypair"})," - The wallet client, account, or keypair"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options: { chain: CHAIN; library: LIBRARY }"})," - Chain and library configuration"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.code,{children:"UniversalSigner"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);