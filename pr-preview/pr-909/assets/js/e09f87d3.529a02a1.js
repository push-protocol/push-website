"use strict";(self.webpackChunkpush_website=self.webpackChunkpush_website||[]).push([[25397],{476779:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(474848),i=t(28453);t(411470),t(119365);const s={id:"docs-slider-settings-with-showrunners-example",title:"Notification Settings in BTC Tracker",hide_title:!0,slug:"./btc-tracker-with-showrunners-example",displayed_sidebar:"pushNotificationSidebar",sidebar_position:9,image:"/assets/docs/previews/docs_slider_settings_with_showrunners_example--notification_settings_in_btc_tracker.png"},a="Notification Settings in BTC Tracker Channel",o={id:"notifications/showrunners-scaffold/Examples/docs-slider-settings-with-showrunners-example",title:"Notification Settings in BTC Tracker",description:"This example is intended to get you understand slider based notification settings with a real-world application. For the example we are going to look at a scenario where users can choose a time interval and showrunners framework will notify them as per their request. Checkout Showrunners Docs, Showrunners Framework, Channel Settings Docs and Channel Settings Demo for better understanding!",source:"@site/docs/notifications/04-showrunners-scaffold/03-Examples/09-Showrunner-Example-Btc-Tracker.mdx",sourceDirName:"notifications/04-showrunners-scaffold/03-Examples",slug:"/notifications/showrunners-scaffold/Examples/btc-tracker-with-showrunners-example",permalink:"/push-website/pr-preview/pr-909/docs/notifications/showrunners-scaffold/Examples/btc-tracker-with-showrunners-example",draft:!1,unlisted:!1,editUrl:"https://github.com/push-protocol/push-website/blob/main/docs/notifications/04-showrunners-scaffold/03-Examples/09-Showrunner-Example-Btc-Tracker.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{id:"docs-slider-settings-with-showrunners-example",title:"Notification Settings in BTC Tracker",hide_title:!0,slug:"./btc-tracker-with-showrunners-example",displayed_sidebar:"pushNotificationSidebar",sidebar_position:9,image:"/assets/docs/previews/docs_slider_settings_with_showrunners_example--notification_settings_in_btc_tracker.png"},sidebar:"pushNotificationSidebar",previous:{title:"Notification Settings in ETH Tracker",permalink:"/push-website/pr-preview/pr-909/docs/notifications/showrunners-scaffold/Examples/eth-tracker-with-showrunners-example"},next:{title:"Price Tracker Channel",permalink:"/push-website/pr-preview/pr-909/docs/notifications/showrunners-scaffold/Examples/price-tracker-with-showrunners-example"}},c={},l=[{value:"What we gonna build?",id:"what-we-gonna-build",level:2},{value:"Creating BTC Tracker in Showrunners",id:"creating-btc-tracker-in-showrunners",level:2},{value:"Step 1: Setup the Showrunners in your local machine",id:"step-1-setup-the-showrunners-in-your-local-machine",level:3},{value:"Step 2: Install Dependencies &amp; start up",id:"step-2-install-dependencies--start-up",level:3},{value:"Step 3: Import the Push SDK",id:"step-3-import-the-push-sdk",level:3},{value:"Step 4: Create a <code>btcTickerKeys.json</code> file in the channel folder",id:"step-4-create-a-btctickerkeysjson-file-in-the-channel-folder",level:3},{value:"Step 5: Create a <code>btcTickerSettings.json</code> file in the channel folder",id:"step-5-create-a-btctickersettingsjson-file-in-the-channel-folder",level:3},{value:"Step 6: Create a <code>btcTickerChannel.ts</code> file in the channel folder",id:"step-6-create-a-btctickerchannelts-file-in-the-channel-folder",level:3},{value:"Step 7: Getting started with the channel logic",id:"step-7-getting-started-with-the-channel-logic",level:3},{value:"Step 8: Create a <code>btcTickerModel.ts</code> file in the folder.",id:"step-8-create-a-btctickermodelts-file-in-the-folder",level:3},{value:"Step 9: Create a <code>btcTickerJobs.ts</code> file in the folder.",id:"step-9-create-a-btctickerjobsts-file-in-the-folder",level:3},{value:"Wrapping it UP \ud83d\ude80",id:"wrapping-it-up-rocket",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Head:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"notification-settings-in-btc-tracker-channel",children:"Notification Settings in BTC Tracker Channel"}),"\n",(0,r.jsxs)(n.p,{children:["This example is intended to get you understand slider based notification settings with a real-world application. For the example we are going to look at a scenario where users can choose a time interval and showrunners framework will notify them as per their request. Checkout ",(0,r.jsx)(n.a,{href:"https://push.org/docs/notifications/showrunners-scaffold/get-started/",title:"Push Showrunners Docs",children:"Showrunners Docs"}),", ",(0,r.jsx)(n.a,{href:"https://github.com/push-protocol/push-showrunners-framework/tree/main",title:"Push Showrunners Github",children:"Showrunners Framework"}),", ",(0,r.jsx)(n.a,{href:"https://push.org/docs/notifications/build/create-channel-settings/",title:"Push Channel Settings Docs",children:"Channel Settings Docs"})," and ",(0,r.jsx)(n.a,{href:"https://github.com/push-protocol/push-showrunners-framework/tree/main/src/sample_showrunners/bank",title:"Channel Settings Example Github",children:"Channel Settings Demo"})," for better understanding!"]}),"\n",(0,r.jsx)(t,{children:(0,r.jsx)("title",{children:"Price Alerts with Showrunners tutorial | Push Notification | Push Documentation"})}),"\n","\n","\n",(0,r.jsx)(n.h2,{id:"what-we-gonna-build",children:"What we gonna build?"}),"\n",(0,r.jsx)(n.p,{children:"Imagine you are a crypto trader or a general crypto enthusiast. You want to be notified every once in a while about the price movements and activities in the market. But you either lose track of time or forget about it. To solve this exact problem, we will be looking into a slider type notification settings implementation where you as a user can specify the time interval and/or required percentage change of a token on which he/she would like to get notified."}),"\n",(0,r.jsxs)(n.p,{children:["We will choose the ",(0,r.jsx)(n.a,{href:"https://github.com/push-protocol/push-showrunners-framework/tree/main/src/sample_showrunners/btcTicker",title:"Push Channel BTC Tracker",children:"BTC Tracker"})," channel to demonstrate this example."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-btc-tracker-in-showrunners",children:"Creating BTC Tracker in Showrunners"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-setup-the-showrunners-in-your-local-machine",children:"Step 1: Setup the Showrunners in your local machine"}),"\n",(0,r.jsxs)(n.p,{children:["For detailed, step-by-step guide visit the Showrunners ",(0,r.jsx)(n.a,{href:"https://push.org/docs/notifications/showrunners-scaffold/get-started/",title:"Push Showrunners Docs",children:"docs"}),". First we need to create a folder in ",(0,r.jsx)(n.code,{children:"src/showrunners/<your_channel_name>"})]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-install-dependencies--start-up",children:"Step 2: Install Dependencies & start up"}),"\n",(0,r.jsx)(n.p,{children:"Navigate to the SDK directory and install required dependencies."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd push-showrunners-framework\nyarn install\ndocker-compose up\nyarn run dev\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-import-the-push-sdk",children:"Step 3: Import the Push SDK"}),"\n",(0,r.jsxs)(n.p,{children:["After you have created a channel folder. Refer to Showrunners ",(0,r.jsx)(n.a,{href:"https://push.org/docs/notifications/showrunners-scaffold/get-started/",title:"Push Showrunners Docs",children:"docs"}),". Move to the [name]Channel.ts file and import the dependencies."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { PushAPI } from '@pushprotocol/restapi';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"step-4-create-a-btctickerkeysjson-file-in-the-channel-folder",children:["Step 4: Create a ",(0,r.jsx)(n.code,{children:"btcTickerKeys.json"})," file in the channel folder"]}),"\n",(0,r.jsx)(n.p,{children:"Use the boilerplate for the keys file.\n."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'{\n  "PRIVATE_KEY_NEW_STANDARD": {\n    "PK": "0x{PRIVATE_KEY_HERE}",\n    "CHAIN_ID": "eip155:11155111"\n  },\n  "PRIVATE_KEY_OLD_STANDARD": "0x{PRIVATE_KEY_HERE}"\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"step-5-create-a-btctickersettingsjson-file-in-the-channel-folder",children:["Step 5: Create a ",(0,r.jsx)(n.code,{children:"btcTickerSettings.json"})," file in the channel folder"]}),"\n",(0,r.jsx)(n.p,{children:"Use the below code for the settings file."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'{\n  "cmcEndpoint": "https://pro-api.coinmarketcap.com/",\n  "providerUrl":"SEPOLIA_PROVIDER_HERE",\n  "route":"v1/cryptocurrency/quotes/latest",\n  "cmcKey":"CMC_API_KEY_HERE",\n  "id": 1\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"step-6-create-a-btctickerchannelts-file-in-the-channel-folder",children:["Step 6: Create a ",(0,r.jsx)(n.code,{children:"btcTickerChannel.ts"})," file in the channel folder"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"btcTickerChannel.ts"})," will be the file which will contain all the logic for the fetching the data and constructing the payload."]}),"\n",(0,r.jsx)(n.p,{children:"There is some boilerplate code involved in creating a channel. The channel.ts file will contain the following boilerplate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Inject, Service } from 'typedi';\nimport { Logger } from 'winston';\nimport config, { defaultSdkSettings } from '../../config';\nimport { EPNSChannel } from '../../helpers/epnschannel';\n\nconst NETWORK_TO_MONITOR = config.web3MainnetNetwork;\n\n@Service()\nexport default class BtcTickerChannel extends EPNSChannel {\n  constructor(@Inject('logger') public logger: Logger, @Inject('cached') public cached) {\n    super(logger, {\n      sdkSettings: {\n        epnsCoreSettings: defaultSdkSettings.epnsCoreSettings,\n        epnsCommunicatorSettings: defaultSdkSettings.epnsCommunicatorSettings,\n        networkSettings: defaultSdkSettings.networkSettings,\n      },\n      networkToMonitor: NETWORK_TO_MONITOR,\n      dirname: __dirname,\n      name: 'BTC Tracker',\n      url: 'https://push.org/',\n      useOffChain: true,\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What's going on here?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"W"}),"e are creating a new class ",(0,r.jsx)(n.code,{children:"BtcTickerChannel"})," which extends the Push Channel class."]}),"\n",(0,r.jsxs)(n.li,{children:["In the ",(0,r.jsx)(n.code,{children:"super()"})," the constructor we pass in certain arguments required for the channel like the ",(0,r.jsx)(n.code,{children:"networkToMonitor"})," , name, and URL for the channel."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"useOffChain the"})," parameter tells the showrunner to use the off-chain notification instead of an on-chain one."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-7-getting-started-with-the-channel-logic",children:"Step 7: Getting started with the channel logic"}),"\n",(0,r.jsx)(n.p,{children:"Our objective is to create a channel to send notifications about price movements depending upon users' settings (Time interval and Percentage change here).\nSo, to achieve this we will follow the following logic:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetch current prices of tokens using the CoinMarketCap API"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// API URL components and settings\nconst cmcroute = settings.route;\nconst cmcEndpoint = settings.cmcEndpoint;\nconst pollURL = `${cmcEndpoint}${cmcroute}?id=${\n  settings.id\n}&aux=cmc_rank&CMC_PRO_API_KEY=${settings.cmcKey || config.cmcAPIKey}`;\n// Fetching data from the CMC API\nlet { data } = await axios.get(pollURL);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Initialize ",(0,r.jsx)(n.code,{children:"userAlice"})," for the channel using your private key and signer."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Initalize provider, signer and userAlice for Channel interaction\nconst provider = new ethers.providers.JsonRpcProvider(settings.providerUrl);\nconst signer = new ethers.Wallet(keys.PRIVATE_KEY_NEW_STANDARD.PK, provider);\nconst userAlice = await PushAPI.initialize(signer, {\n  env: CONSTANTS.ENV.STAGING,\n});\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fetch the current prices, hourly, daily and weekly change for notification payload."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Get the required prices here\nconst price = data.BTC.quote.USD.price;\nconst formattedPrice = Number(Number(price).toFixed(2));\n\nconst hourChange = Number(data.BTC.quote.USD.percent_change_1h);\nconst dayChange = Number(data.BTC.quote.USD.percent_change_24h);\nconst weekChange = Number(data.BTC.quote.USD.percent_change_7d);\n\nconst hourChangeFixed = hourChange.toFixed(2);\nconst dayChangeFixed = dayChange.toFixed(2);\nconst weekChangeFixed = weekChange.toFixed(2);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Before we begin with the logic, we need to fetch the get the current cycles and previous BTC price from our database."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Retrive Global data\nconst btcTrackerGlobalData =\n  (await btcTickerGlobalModel.findOne({ _id: 'btcTrackerGlobal' })) ||\n  (await btcTickerGlobalModel.create({\n    _id: 'btcTrackerGlobal',\n    prevBtcPrice: Number(formattedPrice),\n    cycles: 0,\n  }));\n\n// Assign cycles and prevBtcPrice\nconst CYCLES = btcTrackerGlobalData.cycles ? btcTrackerGlobalData.cycles : 0;\nconst prevPrice = btcTrackerGlobalData.prevBtcPrice\n  ? btcTrackerGlobalData.prevBtcPrice\n  : 0;\n\n// Update current price as prev price\nawait btcTickerGlobalModel.findByIdAndUpdate(\n  { _id: 'btcTrackerGlobal' },\n  { prevBtcPrice: Number(formattedPrice) },\n  { upsert: true }\n);\n\n// Calculate percentage change\nconst globalChangePercentage = Math.round(\n  (Math.abs(formattedPrice - prevPrice) / prevPrice) * 100\n);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Build a payload using the above details"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Build Payload Content\nlet changeInper = Number(\n  ((Math.abs(formattedPrice - prevPrice) / prevPrice) * 100).toFixed(2)\n);\n\nconst title = 'BTC at $' + formattedPrice;\nconst message = `\\nHourly Movement: ${hourChangeFixed}%\\nDaily Movement: ${dayChangeFixed}%\\nWeekly Movement: ${weekChangeFixed}%`;\nconst payloadTitle = `BTC Price Movement`;\nconst globalPayloadMsg = `BTC at [t:$${formattedPrice} (${\n  changeInper >= 0\n    ? changeInper < 100\n      ? `+` + changeInper + '%'\n      : '+' + 0 + '%'\n    : `-` + changeInper + '%'\n})]\\n\\nHourly Movement: ${\n  hourChange >= 0\n    ? '[s: +' + hourChangeFixed + '%]'\n    : '[d: -' + hourChangeFixed + '%]'\n}\\nDaily Movement: ${\n  dayChange >= 0\n    ? '[s: +' + dayChangeFixed + '%]'\n    : '[d: -' + dayChangeFixed + '%]'\n}\\nWeekly Movement: ${\n  weekChange >= 0\n    ? '[s: +' + weekChangeFixed + '%]'\n    : '[d: -' + weekChangeFixed + '%]'\n}[timestamp: ${Math.floor(Date.now() / 1000)}]`;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Here, you can use colours as per your wish. For example price pump is shown in blue and price dump is shown in red/pink colour in this case."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetch the current subscribers of the channel using ",(0,r.jsx)(n.code,{children:"subscribers()"})," in the Push SDK"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Looping for subscribers' data in the channel\nwhile (true) {\n  const userData: any = await userAlice.channel.subscribers({\n    page: i,\n    limit: 30,\n    setting: true,\n  });\n  if (userData.itemcount != 0) {\n    i++;\n  } else {\n    i = 1;\n    // UPDATE CYCLES VALUE\n    // HERE\n    await btcTickerGlobalModel.findOneAndUpdate(\n      { _id: 'btcTrackerGlobal' },\n      { $inc: { cycles: 3 } },\n      { upsert: true },\n    );\n\n    break;\n  }\n\n  // Next block of code goes here\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Loop across each subscriber to fetch their ",(0,r.jsx)(n.code,{children:"userSettings"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Here, we need to track the price of BTC at which a user got notified and send a notification accordingly. Therefore, we need to build custom notifications for the user. Here, is how we can do it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"await Promise.all(\n  userData.subscribers.map(async (subscriberObj: { settings: string; subscriber: any }) => {\n\n  // Converting String to JS object\n  const userSettings = JSON.parse(subscriberObj.settings);\n\n  // Fetch users last btc price & last cycle values\n  const userDBValue =\n    (await btcTickerUserModel.findOne({ _id: subscriberObj.subscriber })) ||\n    (await btcTickerUserModel.create({\n      _id: subscriberObj.subscriber,\n      lastCycle: btcTrackerGlobalData.cycles,\n      lastbtcPrice: btcTrackerGlobalData.prevBtcPrice,\n    }));\n\n  // Calculation of percentage change for each subscriber\n  const changePercentage = (\n    (Math.abs(formattedPrice - Number(userDBValue.lastBtcPrice) || prevPrice) /\n      Number(userDBValue.lastBtcPrice) || prevPrice) * 100\n  ).toFixed(2);\n\n  // Build payload message for each subscriber\n  let payloadMsg;\n\n  if (Number(changePercentage) == 0) {\n    payloadMsg = `BTC at [t:$${formattedPrice} ( 0 %\n    )]\\n\\nHourly Movement: ${\n      hourChange >= 0 ? '[s: +' + hourChangeFixed + '%]' : '[d: ' + hourChangeFixed + '%]'\n    }\\nDaily Movement: ${\n      dayChange >= 0 ? '[s: +' + dayChangeFixed + '%]' : '[d: ' + dayChangeFixed + '%]'\n    }\\nWeekly Movement: ${\n      weekChange >= 0 ? '[s: +' + weekChangeFixed + '%]' : '[d: ' + weekChangeFixed + '%]'\n    }[timestamp: ${Math.floor(Date.now() / 1000)}]`;\n  } else {\n    let changeInpercentage = Number(\n      (\n        ((formattedPrice - Number(userDBValue.lastBtcPrice) || prevPrice) /\n          Number(userDBValue.lastBtcPrice) || prevPrice) * 100\n      ).toFixed(2),\n    );\n    payloadMsg = `BTC at [t:$${formattedPrice} (${\n      changeInpercentage > 0\n        ? changeInpercentage < 100\n          ? `+` + changeInpercentage + '%'\n          : '+' + 0 + '%'\n        : `-` + changeInpercentage + '%'\n    })]\\n\\nHourly Movement: ${\n      hourChange >= 0 ? '[s: +' + hourChangeFixed + '%]' : '[d: ' + hourChangeFixed + '%]'\n    }\\nDaily Movement: ${\n      dayChange >= 0 ? '[s: +' + dayChangeFixed + '%]' : '[d: ' + dayChangeFixed + '%]'\n    }\\nWeekly Movement: ${\n      weekChange >= 0 ? '[s: +' + weekChangeFixed + '%]' : '[d: ' + weekChangeFixed + '%]'\n    }[timestamp: ${Math.floor(Date.now() / 1000)}]`;\n  }\n\n  // Only perform computation if user settings exist\n  if (userSettings !== null) {\n    /*\n    {\n      Handle the notification trigger cases here\n    }\n    */\n  } else {\n    //Send Notifications to old users\n    // Build Payload\n    await btcTickerUserModel.findOneAndUpdate(\n      { _id: subscriberObj.subscriber },\n      { lastCycle: CYCLES, lastBtcPrice: Number(formattedPrice) },\n      { upsert: true },\n    );\n\n    const payload = {\n      type: 3, // Type of Notification\n      notifTitle: title, // Title of Notification\n      notifMsg: message, // Message of Notification\n      title: payloadTitle, // Internal Title\n      msg: payloadMsg, // Internal Message\n      recipient: subscriberObj.subscriber, // Recipient\n    };\n    // Send notification\n    this.sendNotification({\n      recipient: payload.recipient, // new\n      title: payload.notifTitle,\n      message: payload.notifMsg,\n      payloadTitle: payload.title,\n      payloadMsg: payload.msg,\n      notificationType: payload.type,\n      simulate: simulate,\n      image: null,\n    });\n  }\n})\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Now, we need to trigger notifications as per the users' channel settings combination. i) User opted for both time interval and percentage change, ii) Only percentage change and iii) Only Time interval"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// if both Change percentage and Time interval is enabled\nif (userSettings[0]?.enabled == true && userSettings[1]?.enabled == true) {\n  const settingUserValue1 = userSettings[0].user; // Percent Change\n  const settingUserValue2 =\n    userSettings[1].user == 0 ? 3 : userSettings[1].user; // Time interval\n\n  // Case for if user opts-in, opts-out and again opts-in later in time interval\n  const presentInDb = (await btcTickerUserModel.findOne({\n    _id: subscriberObj.subscriber,\n  }))\n    ? true\n    : false;\n\n  if (presentInDb) {\n    const userDBValueCheck = await btcTickerUserModel.findOne({\n      _id: subscriberObj.subscriber,\n    });\n\n    if (\n      Number(userDBValueCheck.lastCycle + settingUserValue2) < Number(CYCLES)\n    ) {\n      // Set current cycle as lastCycle\n      await btcTickerUserModel.findOneAndUpdate(\n        { _id: subscriberObj.subscriber },\n        { lastCycle: CYCLES },\n        { upsert: true }\n      );\n    }\n  }\n\n  // --------------------------------------------------------------------------------\n\n  // Check if user changed their settings\n  const userDBValueBefore =\n    (await btcTickerUserModel.findOne({ _id: subscriberObj.subscriber })) ||\n    (await btcTickerUserModel.create({\n      _id: subscriberObj.subscriber,\n      lastCycle: CYCLES,\n      settingsValue: settingUserValue2,\n    }));\n\n  const userSettingsDBValue = userDBValueBefore.settingsValue\n    ? userDBValueBefore.settingsValue\n    : 0;\n  const userChangedValue = userSettingsDBValue != settingUserValue2; // true\n\n  if (userChangedValue) {\n    await btcTickerUserModel.findOneAndUpdate(\n      { _id: subscriberObj.subscriber },\n      { lastCycle: CYCLES, settingsValue: settingUserValue2 }\n    );\n  }\n\n  // ------------------------------------------------------------------------\n\n  const userDBValue = await btcTickerUserModel.findOne({\n    _id: subscriberObj.subscriber,\n  });\n\n  if (userDBValue.lastCycle + settingUserValue2 == CYCLES) {\n    if (changePercentage >= settingUserValue1) {\n      // UPDATE the users mapped value in DB\n      await btcTickerUserModel.findOneAndUpdate(\n        { _id: subscriberObj.subscriber },\n        { lastCycle: CYCLES, lastBtcPrice: Number(formattedPrice) },\n        { upsert: true }\n      );\n\n      // Sending Notification\n      try {\n        // Build Payload\n        const payload = {\n          type: 3, // Type of Notification\n          notifTitle: title, // Title of Notification\n          notifMsg: message, // Message of Notification\n          title: payloadTitle, // Internal Title\n          msg: payloadMsg, // Internal Message\n          recipient: subscriberObj.subscriber, // Recipient\n        };\n\n        // Send notification\n        this.sendNotification({\n          recipient: payload.recipient, // new\n          title: payload.notifTitle,\n          message: payload.notifMsg,\n          payloadTitle: payload.title,\n          payloadMsg: payload.msg,\n          notificationType: payload.type,\n          simulate: simulate,\n          image: null,\n        });\n      } catch (error) {\n        this.logError(`Error sending notification: ${error}`);\n      }\n    } else {\n      // UPDATE the users mapped value in DB\n      await btcTickerUserModel.findOneAndUpdate(\n        { _id: subscriberObj.subscriber },\n        { lastCycle: CYCLES, lastBtcPrice: Number(formattedPrice) },\n        { upsert: true }\n      );\n    }\n  }\n}\n// if only Change percentage is enabled\nelse if (userSettings[0]?.enabled === true) {\n  const settingUserValue1 = userSettings[0].user; // Percent Change\n\n  if (Math.abs(Number(globalChangePercentage)) >= settingUserValue1) {\n    // Sending Notification\n    try {\n      // Build Payload\n      const payload = {\n        type: 3, // Type of Notification\n        notifTitle: title, // Title of Notification\n        notifMsg: message, // Message of Notification\n        title: payloadTitle, // Internal Title\n        msg: globalPayloadMsg, // Internal Message\n        recipient: subscriberObj.subscriber, // Recipient\n      };\n\n      // Send notification\n      this.sendNotification({\n        recipient: payload.recipient, // new\n        title: payload.notifTitle,\n        message: payload.notifMsg,\n        payloadTitle: payload.title,\n        payloadMsg: payload.msg,\n        notificationType: payload.type,\n        simulate: simulate,\n        image: null,\n      });\n    } catch (error) {\n      this.logError(`Error sending notification: ${error}`);\n    }\n  }\n}\n// if only Time interval is enabled\nelse if (userSettings[1]?.enabled === true) {\n  const settingUserValue2 =\n    userSettings[1].user == 0 ? 3 : userSettings[1].user; // Time interval\n\n  // Case for if user opts-in, opts-out and again opts-in later in time interval\n  const presentInDb = (await btcTickerUserModel.findOne({\n    _id: subscriberObj.subscriber,\n  }))\n    ? true\n    : false;\n\n  if (presentInDb) {\n    const userDBValueCheck = await btcTickerUserModel.findOne({\n      _id: subscriberObj.subscriber,\n    });\n\n    if (\n      Number(userDBValueCheck.lastCycle + settingUserValue2) < Number(CYCLES)\n    ) {\n      // Set current cycle as lastCycle\n      await btcTickerUserModel.findOneAndUpdate(\n        { _id: subscriberObj.subscriber },\n        { lastCycle: CYCLES },\n        { upsert: true }\n      );\n    }\n  }\n\n  // --------------------------------------------------------------------------------\n\n  // Check if user changed their settings\n  const userDBValueBefore =\n    (await btcTickerUserModel.findOne({ _id: subscriberObj.subscriber })) ||\n    (await btcTickerUserModel.create({\n      _id: subscriberObj.subscriber,\n      lastCycle: CYCLES,\n      settingsValue: settingUserValue2,\n    }));\n\n  const userSettingsDBValue = userDBValueBefore.settingsValue\n    ? userDBValueBefore.settingsValue\n    : 0;\n  const userChangedValue = userSettingsDBValue != settingUserValue2;\n\n  if (userChangedValue) {\n    await btcTickerUserModel.findOneAndUpdate(\n      { _id: subscriberObj.subscriber },\n      { lastCycle: CYCLES, settingsValue: settingUserValue2 }\n    );\n  }\n\n  // ------------------------------------------------------------------------\n\n  const userDBValue = await btcTickerUserModel.findOne({\n    _id: subscriberObj.subscriber,\n  });\n\n  if (userDBValue.lastCycle + settingUserValue2 == CYCLES) {\n    // UPDATE the users mapped value in DB\n    await btcTickerUserModel.findOneAndUpdate(\n      { _id: subscriberObj.subscriber },\n      { lastCycle: CYCLES, lastBtcPrice: Number(formattedPrice) },\n      { upsert: true }\n    );\n\n    // Sending Notification\n    try {\n      // Build Payload\n      const payload = {\n        type: 3, // Type of Notification\n        notifTitle: title, // Title of Notification\n        notifMsg: message, // Message of Notification\n        title: payloadTitle, // Internal Title\n        msg: payloadMsg, // Internal Message\n        recipient: subscriberObj.subscriber, // Recipient\n      };\n\n      // Send notification\n      this.sendNotification({\n        recipient: payload.recipient, // new\n        title: payload.notifTitle,\n        message: payload.notifMsg,\n        payloadTitle: payload.title,\n        payloadMsg: payload.msg,\n        notificationType: payload.type,\n        simulate: simulate,\n        image: null,\n      });\n    } catch (error) {\n      this.logError(`Error sending notification: ${error}`);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\ud83e\udd2fThose were a lots of code out there. Let's understand what is actually happening there and what conditions trigger the notifications in different cases."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case 1: Both percent change and time interval is enabled"})," - When a user opts in to both these settings, what the user want is to receive a notification for their selected tokens when there is a particular change in price and it occured within the time interval.\nSo, the basic logic here is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"if (userDBValue.lastCycle + settingUserValue2 == CYCLES) {\n  if (changePercentage >= settingUserValue1) {\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We just fetched the prices from the CMC API and using the previous price stored in database as per user, we can calculate the ",(0,r.jsx)(n.code,{children:"changePercentage"})," value.\nFor the ",(0,r.jsx)(n.code,{children:"CYCLES"})," variable, everytime our showrunners framework is executed it is incremented by 3 as the lowest ",(0,r.jsx)(n.code,{children:"ticker"})," value in the slider is 3. You can change it as per your channel and logic. This helps us to calculate when a new user will receive a notification based on on which cycle did he opted in.\nAlso, there are 3 conditions that you need to lookout for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"i) What happens when time is triggered but not percentage?"}),"\n",(0,r.jsx)(n.li,{children:"ii) What happens if a user opts-in, opts-out and then again after several days opt-in?"}),"\n",(0,r.jsx)(n.li,{children:"iii) What happens if someone changes their time-interval settings?"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We have already handled these edge cases in the code. Test yourself and see if you can find them\ud83d\ude09."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case 2: Only percent change is enabled"})," - Here, a user want to receive notification when there is a particular change in price. So, the basic logic here is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Condition to trigger notification\nif (Number(changePercentage) >= userValue) {\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The calculation for the ",(0,r.jsx)(n.code,{children:"changePercentage"})," is same like ",(0,r.jsx)(n.code,{children:"Case 1"}),". The only difference here is we use the ",(0,r.jsx)(n.code,{children:"globalChangePercentage"})," instead of the users last price."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case 3: Only time interval is enabled"})," - Here, a user want to receive notification as per their chosen interval. So, the basic logic here is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Condition to trigger notification\nif (userDBValue.lastCycle + userValue == CYCLES) {\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The calculation and significance of the ",(0,r.jsx)(n.code,{children:"CYCLES"})," variable is explained in ",(0,r.jsx)(n.code,{children:"Case 1"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This wraps up the channel logic. Now, let's move onto buidling the cron-jobs file and model file."}),"\n",(0,r.jsxs)(n.h3,{id:"step-8-create-a-btctickermodelts-file-in-the-folder",children:["Step 8: Create a ",(0,r.jsx)(n.code,{children:"btcTickerModel.ts"})," file in the folder."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { model, Schema } from 'mongoose';\n\nexport interface BtcTickerUserData {\n  _id?: string;\n  lastCycle?: number;\n  lastBtcPrice?: number;\n  settingsValue?: number;\n}\n\nconst btcTickerUserSchema = new Schema<BtcTickerUserData>({\n  _id: {\n    type: String,\n  },\n  lastCycle: {\n    type: Number,\n  },\n  lastBtcPrice: {\n    type: Number\n  },\n  settingsValue: {\n    type: Number,\n  }\n});\n\nexport const btcTickerUserModel = model<BtcTickerUserData>('btcTickerUserDB', btcTickerUserSchema);\n\nexport interface BtcTickerGlobal {\n  _id?: string;\n  prevBtcPrice?: number;\n  cycles?: number;\n}\n\nconst btcTickerGlobalSchema = new Schema<BtcTickerGlobal>({\n  _id: {\n    type: String,\n  },\n  prevBtcPrice: {\n    type: Number,\n  },\n  cycles: {\n    type: Number,\n  },\n});\n\nexport const btcTickerGlobalModel = model<BtcTickerGlobal>('btcTickerGlobalDB', btcTickerGlobalSchema);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is a good practice to write your ",(0,r.jsx)(n.code,{children:"Interface"})," then ",(0,r.jsx)(n.code,{children:"Schema"})," and then create your ",(0,r.jsx)(n.code,{children:"Model"}),". Remember to keep different names of your database for each model."]}),"\n",(0,r.jsxs)(n.h3,{id:"step-9-create-a-btctickerjobsts-file-in-the-folder",children:["Step 9: Create a ",(0,r.jsx)(n.code,{children:"btcTickerJobs.ts"})," file in the folder."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Do Scheduling\n// https://github.com/node-schedule/node-schedule\n// *    *    *    *    *    *\n// \u252c    \u252c    \u252c    \u252c    \u252c    \u252c\n// \u2502    \u2502    \u2502    \u2502    \u2502    \u2502\n// \u2502    \u2502    \u2502    \u2502    \u2502    \u2514 day of week (0 - 7) (0 or 7 is Sun)\n// \u2502    \u2502    \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n// \u2502    \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)\n// \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n// \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 second (0 - 59, OPTIONAL)\n// Execute a cron job every 5 Minutes = */5 * * * *\n// Starts from seconds = * * * * * *\n\nimport logger from '../../loaders/logger';\n\nimport { Container } from 'typedi';\nimport schedule from 'node-schedule';\n\nimport BtcTickerChannel from './btcTickerChannel';\n\nexport default async () => {\n  const startTime = new Date(new Date().setHours(0, 0, 0, 0));\n\n  const threeHourRule = new schedule.RecurrenceRule();\n  threeHourRule.hour = new schedule.Range(0, 23, 3);\n  threeHourRule.minute = 0;\n  threeHourRule.second = 0;\n\n  const channel = Container.get(BtcTickerChannel);\n  channel.logInfo(`\ud83d\udef5 Scheduling Showrunner`);\n\n  schedule.scheduleJob(\n    { start: startTime, rule: threeHourRule },\n    async function () {\n      const taskName = 'BTC Ticker Fetch and sendMessageToContract()';\n      try {\n        await channel.sendMessageToContract(true);\n        logger.info(\n          `[${new Date(Date.now())}] \ud83d\udc23 Cron Task Completed -- ${taskName}`\n        );\n      } catch (err) {\n        logger.error(\n          `[${new Date(Date.now())}] \u274c Cron Task Failed -- ${taskName}`\n        );\n        logger.error(`[${new Date(Date.now())}] Error Object: %o`, err);\n      }\n    }\n  );\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can change the scheduling frequency as per your use-case."}),"\n",(0,r.jsxs)(n.h3,{id:"wrapping-it-up-rocket",children:["Wrapping it UP ","\ud83d\ude80"]}),"\n",(0,r.jsx)(n.p,{children:"Congratulations\ud83c\udf8a...you have just built a amazing channel that tracks and notifies you about BTC price without you worrying about missing on important price movements and always be in the game. Isn't it cool?"}),"\n",(0,r.jsx)(n.p,{children:"Channel settings just opened a whole new notification experience window for users just like you and me. Now, you have all the divine knowledge about the channel settings. So, put your thinking caps on and built some cool stuff with it."}),"\n",(0,r.jsx)(n.p,{children:"See you until the next time. Keep Building\ud83c\udf8a"})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},119365:(e,n,t)=>{t.d(n,{A:()=>a});t(296540);var r=t(618215);const i={tabItem:"tabItem_Ymn6"};var s=t(474848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,a),hidden:t,children:n})}},411470:(e,n,t)=>{t.d(n,{A:()=>j});var r=t(296540),i=t(618215),s=t(823104),a=t(956347),o=t(300205),c=t(757485),l=t(231682),d=t(289466);function u(e){var n,t;return null!==(n=null===(t=r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))||void 0===t?void 0:t.filter(Boolean))&&void 0!==n?n:[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:i}}=e;return{value:n,label:t,attributes:r,default:i}}))}(t);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const i=(0,a.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,c.aZ)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,s=h(e),[a,c]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const i=null!==(n=r.find((e=>e.default)))&&void 0!==n?n:r[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:s}))),[l,u]=g({queryString:t,groupId:i}),[b,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,s]=(0,d.Dv)(t);return[i,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:i}),m=(()=>{const e=null!=l?l:b;return p({value:e,tabValues:s})?e:null})();(0,o.A)((()=>{m&&c(m)}),[m]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),f(e)}),[u,f,s]),tabValues:s}}var f=t(992303);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=t(474848);function y(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),i=o[t].value;i!==r&&(l(n),a(i))},u=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var r;const n=c.indexOf(e.currentTarget)+1;t=null!==(r=c[n])&&void 0!==r?r:c[0];break}case"ArrowLeft":{var i;const n=c.indexOf(e.currentTarget)-1;t=null!==(i=c[n])&&void 0!==i?i:c[c.length-1];break}}null===(n=t)||void 0===n||n.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>c.push(e),onKeyDown:u,onClick:d,...s,className:(0,i.A)("tabs__item",m.tabItem,null==s?void 0:s.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)}))})}function x(e){let{lazy:n,children:t,selectedValue:i}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===i));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function C(e){const n=b(e);return(0,w.jsxs)("div",{className:(0,i.A)("tabs-container",m.tabList),children:[(0,w.jsx)(y,{...e,...n}),(0,w.jsx)(x,{...e,...n})]})}function j(e){const n=(0,f.A)();return(0,w.jsx)(C,{...e,children:u(e.children)},String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(296540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);