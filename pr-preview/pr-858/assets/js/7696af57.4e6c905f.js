"use strict";
(self["webpackChunkpush_website"] = self["webpackChunkpush_website"] || []).push([[20156],{

/***/ 990079:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assets: () => (/* binding */ assets),
/* harmony export */   contentTitle: () => (/* binding */ contentTitle),
/* harmony export */   "default": () => (/* binding */ MDXContent),
/* harmony export */   frontMatter: () => (/* binding */ frontMatter),
/* harmony export */   metadata: () => (/* binding */ metadata),
/* harmony export */   toc: () => (/* binding */ toc)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(474848);
/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28453);
/* harmony import */ var _site_src_css_SharedStyling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113490);


const frontMatter = {
	slug: 'push-token-economics',
	title: 'PUSH Token Economics',
	description: 'PUSH Token Economics',
	authors: [
		'push'
	],
	image: './cover-image.webp',
	text: 'Ethereum Push Notification Service (EPNS) is a protocol for decentralized notifications on the Ethereum blockchain. EPNS enables applications and users to create and subscribe to notification channels, enabling blockchain-native communication between apps and users.',
	tags: [
		'Token Economics',
		'Token',
		'Governance',
		'Ethereum',
		'Announcements'
	]
};
const contentTitle = 'Reward Accrual';
const metadata = {
  "permalink": "/push-website/pr-preview/pr-858/blog/push-token-economics",
  "source": "@site/blog/2021-03-31-push-token-economics/index.md",
  "title": "PUSH Token Economics",
  "description": "PUSH Token Economics",
  "date": "2021-03-31T00:00:00.000Z",
  "formattedDate": "March 31, 2021",
  "tags": [
    {
      "label": "Token Economics",
      "permalink": "/push-website/pr-preview/pr-858/blog/tags/token-economics"
    },
    {
      "label": "Token",
      "permalink": "/push-website/pr-preview/pr-858/blog/tags/token"
    },
    {
      "label": "Governance",
      "permalink": "/push-website/pr-preview/pr-858/blog/tags/governance"
    },
    {
      "label": "Ethereum",
      "permalink": "/push-website/pr-preview/pr-858/blog/tags/ethereum"
    },
    {
      "label": "Announcements",
      "permalink": "/push-website/pr-preview/pr-858/blog/tags/announcements"
    }
  ],
  "readingTime": 1.66,
  "hasTruncateMarker": true,
  "authors": [
    {
      "name": "Push Protocol",
      "url": "https://twitter.com/pushprotocol",
      "imageURL": "/assets/blog/authors/authorpush.png",
      "key": "push"
    }
  ],
  "frontMatter": {
    "slug": "push-token-economics",
    "title": "PUSH Token Economics",
    "description": "PUSH Token Economics",
    "authors": [
      "push"
    ],
    "image": "./cover-image.webp",
    "text": "Ethereum Push Notification Service (EPNS) is a protocol for decentralized notifications on the Ethereum blockchain. EPNS enables applications and users to create and subscribe to notification channels, enabling blockchain-native communication between apps and users.",
    "tags": [
      "Token Economics",
      "Token",
      "Governance",
      "Ethereum",
      "Announcements"
    ]
  },
  "unlisted": false,
  "prevItem": {
    "title": "Announcing the EPNS $PUSH Token Generation Event",
    "permalink": "/push-website/pr-preview/pr-858/blog/announcing-the-epns-push-token-generation-event"
  },
  "nextItem": {
    "title": "Accelerating DeFi with EPNS",
    "permalink": "/push-website/pr-preview/pr-858/blog/accelerating-defi-with-epns"
  }
};
const assets = {
"image": (__webpack_require__(861865)/* ["default"] */ .A),
"authorsImageUrls": [undefined],
};




const toc = [];
function _createMdxContent(props) {
  const _components = {
    a: "a",
    blockquote: "blockquote",
    em: "em",
    h1: "h1",
    img: "img",
    p: "p",
    strong: "strong",
    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__/* .useMDXComponents */ .R)(),
    ...props.components
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.p, {
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.img, {
        alt: "Cover Image of PUSH Token Economics",
        src: (__webpack_require__(751608)/* ["default"] */ .A) + "",
        width: "1400",
        height: "700"
      })
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.blockquote, {
      children: ["\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.strong, {
          children: "Update:"
        }), " Push Protocol (Previously EPNS) and $PUSH is evolving, The evolved version of Pusheconomics can be found here: ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.a, {
          href: "https://push.org/docs/tokenomics/deepdive/$push/",
          children: "https://push.org/docs/tokenomics/deepdive/$push/"
        })]
      }), "\n"]
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.p, {
      children: "Ethereum Push Notification Service (EPNS) is a protocol for decentralized notifications on the Ethereum blockchain. EPNS enables applications and users to create and subscribe to notification channels, enabling blockchain-native communication between apps and users. The Web3 ecosystem today communicates through channels like email, Medium, Twitter, Discord, WeChat, and more. For rapidly-evolving use cases like DeFi, these forms of communication struggle to scale. EPNS protocol lets applications send push notifications to users regarding updates, account information, product drops, and more. Users can also set up custom notifications in response to on-chain events to better monitor investments, transactions, app security, protocol performance, and more."
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
      children: ["$PUSH is the native governance token of the EPNS protocol. PUSH provides its holders with two primary benefits: ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.strong, {
        children: "governance rights"
      }), " and ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.strong, {
        children: "reward accrual"
      }), ". Following the network token generation event, PUSH holders will be able to participate in the evolution of the EPNS protocol and earn rewards from the fees paid to the network."]
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
      children: ["The EPNS platform consists of ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.em, {
        children: "services, channels,"
      }), " and ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.em, {
        children: "subscribers."
      }), " Services are dapps or smart contracts that wish to send notifications. Services set up ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.em, {
        children: "channels"
      }), " that send notifications when certain events happen or parameters are met. ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.em, {
        children: "Subscribers"
      }), " are the users that sign up to those channels and elect to receive notifications."]
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.p, {
      children: "When services set up a channel, they must deposit at least 50 DAI into a common staking pool. The common staking pool is an aggregation of the fees from all channels across the EPNS protocol. The common staking pool is then staked in AAVE (at the time of launch), where it accrues value. Accrued DAI is distributed to subscribers of EPNS channels in proportion to how early they joined. Fees are implemented when services close channels, to disincentivize gaming."
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
      children: ["The EPNS protocol also has the ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.em, {
        children: "fee pool,"
      }), " which is tied to $PUSH ownership. The fee pool is a collection of micro-payments paid by services either in a per-notification or yearly subscription model. Fees are paid in DAI or ETH, and collected in the fee pool. The fee pool is distributed to the community. 70% goes to $PUSH holders and 30% goes to the ecosystem development fund. The fee pool will not be live with mainnet launch, and will be activated within a year or so following the protocolâ€™s launch."]
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.h1, {
      id: "governance-rights",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.strong, {
        children: "Governance Rights"
      })
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.p, {
      children: "$PUSH also gives owners the right to vote on protocol decisions, including the staking structure, staking mechanism, and reward distribution rates. Governance votes can include the structure of the fees paid by services (i.e. per notification or yearly subscription), the DeFi mechanism for the staking pool (i.e. staking through AAVE or elsewhere), and other critical incentivization and financial elements of the protocol."
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
      children: ["Learn more about EPNS and $PUSH in our ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.a, {
        href: "https://whitepaper.epns.io/",
        children: "whitepaper"
      }), "."]
    }), "\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.blockquote, {
      children: ["\n", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components.p, {
        children: ["Update: Token Generation Event Announced! Read about $PUSH token allocation and plan ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components.a, {
          href: "https://medium.com/ethereum-push-notification-service/announcing-the-epns-push-token-generation-event-4d1699e716f5",
          children: "here"
        }), "."]
      }), "\n"]
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = {
    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__/* .useMDXComponents */ .R)(),
    ...props.components
  };
  return MDXLayout ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MDXLayout, {
    ...props,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_createMdxContent, {
      ...props
    })
  }) : _createMdxContent(props);
}



/***/ }),

/***/ 861865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "assets/images/cover-image-91f03254205cf5a50f2de32bf2451e31.webp");

/***/ }),

/***/ 751608:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "assets/images/cover-image-91f03254205cf5a50f2de32bf2451e31.webp");

/***/ }),

/***/ 28453:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ useMDXComponents),
/* harmony export */   x: () => (/* binding */ MDXProvider)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(296540);
/**
 * @typedef {import('mdx/types.js').MDXComponents} MDXComponents
 * @typedef {import('react').Component<{}, {}, unknown>} Component
 * @typedef {import('react').ReactNode} ReactNode
 */

/**
 * @callback MergeComponents
 *   Custom merge function.
 * @param {Readonly<MDXComponents>} currentComponents
 *   Current components from the context.
 * @returns {MDXComponents}
 *   Additional components.
 *
 * @typedef Props
 *   Configuration for `MDXProvider`.
 * @property {ReactNode | null | undefined} [children]
 *   Children (optional).
 * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]
 *   Additional components to use or a function that creates them (optional).
 * @property {boolean | null | undefined} [disableParentContext=false]
 *   Turn off outer component context (default: `false`).
 */



/** @type {Readonly<MDXComponents>} */
const emptyComponents = {}

const MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents)

/**
 * Get current components from the MDX Context.
 *
 * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]
 *   Additional components to use or a function that creates them (optional).
 * @returns {MDXComponents}
 *   Current components.
 */
function useMDXComponents(components) {
  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)

  // Memoize to avoid unnecessary top-level context changes
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    function () {
      // Custom merge via a function prop
      if (typeof components === 'function') {
        return components(contextComponents)
      }

      return {...contextComponents, ...components}
    },
    [contextComponents, components]
  )
}

/**
 * Provider for MDX context.
 *
 * @param {Readonly<Props>} properties
 *   Properties.
 * @returns {JSX.Element}
 *   Element.
 * @satisfies {Component}
 */
function MDXProvider(properties) {
  /** @type {Readonly<MDXComponents>} */
  let allComponents

  if (properties.disableParentContext) {
    allComponents =
      typeof properties.components === 'function'
        ? properties.components(emptyComponents)
        : properties.components || emptyComponents
  } else {
    allComponents = useMDXComponents(properties.components)
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    MDXContext.Provider,
    {value: allComponents},
    properties.children
  )
}


/***/ })

}]);